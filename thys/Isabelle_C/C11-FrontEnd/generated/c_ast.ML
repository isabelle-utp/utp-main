(* Generated from Run.thy; DO NOT EDIT! *)

structure C_Ast : sig
  datatype inta = Int_of_integer of int
  datatype num = One | Bit0 of num | Bit1 of num
  val one_inta : inta
  type 'a one
  val one : 'a one -> 'a
  val one_int : inta one
  val integer_of_int : inta -> int
  val times_inta : inta -> inta -> inta
  type 'a times
  val times : 'a times -> 'a -> 'a -> 'a
  type 'a power
  val one_power : 'a power -> 'a one
  val times_power : 'a power -> 'a times
  val times_int : inta times
  val power_int : inta power
  datatype nat = Nat of int
  val integer_of_nat : nat -> int
  val equal_nata : nat -> nat -> bool
  type 'a equal
  val equala : 'a equal -> 'a -> 'a -> bool
  val equal_nat : nat equal
  val zero_nata : nat
  type 'a zero
  val zero : 'a zero -> 'a
  val zero_nat : nat zero
  val eq : 'a equal -> 'a -> 'a -> bool
  val equal_lista : 'a equal -> 'a list -> 'a list -> bool
  val equal_list : 'a equal -> ('a list) equal
  val equal_bool : bool -> bool -> bool
  datatype char = Chara of bool * bool * bool * bool * bool * bool * bool * bool
  val equal_chara : char -> char -> bool
  val equal_char : char equal
  val shows_prec_char : nat -> char -> char list -> char list
  val shows_string : char list -> char list -> char list
  val shows_list_char : char list -> char list -> char list
  type 'a show
  val shows_prec : 'a show -> nat -> 'a -> char list -> char list
  val shows_list : 'a show -> 'a list -> char list -> char list
  val show_char : char show
  datatype string_b_a_s_e = ST of string | STa of int list
  val equal_integer : int equal
  val equal_string_b_a_s_e : string_b_a_s_e -> string_b_a_s_e -> bool
  datatype abr_string = SS_base of string_b_a_s_e | String_concatWith of abr_string * abr_string list
  val equal_abr_stringa : abr_string -> abr_string -> bool
  val equal_abr_string : abr_string equal
  datatype sourcePos = Ta of int * abr_string * int
  val equal_SourcePos : sourcePos -> sourcePos -> bool
  datatype region = Bogus | T of sourcePos * sourcePos
  val equal_Region : region -> region -> bool
  datatype 'a region_Wrap = Tb of 'a * region
  val equal_Region_Wrap : 'a equal -> 'a region_Wrap -> 'a region_Wrap -> bool
  datatype stringCvt_radix = BIN | OCT | DEC | HEX
  datatype literalconstant_node = NUMCONST of int * abr_string * stringCvt_radix | STRING_LIT of abr_string
  datatype 'a unsynchronized_ref = Unsynchronized_ref of 'a
  datatype more_info = MungedVar of abr_string * abr_string option | EnumC | FunctionName
  datatype binoptype = LogOr | LogAnd | Equals | NotEquals | BitwiseAnd | BitwiseOr | BitwiseXOr | Lt | Gt | Leq | Geq | Plus | Minus | Times | Divides | Modulus | RShift | LShift
  datatype unoptype = Negate | Not | Addr | BitNegate
  datatype base_inttype = Charb | Short | Inta | Long | LongLong | Double | Float
  datatype 'a ctype = Signed of base_inttype | Unsigned of base_inttype | Bool | PlainChar | StructTy of abr_string | UnionTy of abr_string | EnumTy of abr_string option | Ptr of 'a ctype | Array of 'a ctype * 'a option |
    Bitfield of bool * 'a | Identa of abr_string | Function of 'a ctype * 'a ctype list | Void
  datatype expr = E of expr_node region_Wrap
  and designator = DesignE of expr | DesignFld of abr_string
  and initializer = InitE of expr | InitList of (designator list * initializer) list
  and expr_node = BinOp of binoptype * expr * expr | UnOp of unoptype * expr | CondExp of expr * expr * expr | Constant of literalconstant_node region_Wrap | Vara of abr_string * ((int ctype * more_info) option) unsynchronized_ref |
    StructDot of expr * abr_string | ArrayDeref of expr * expr | Deref of expr | TypeCast of expr ctype region_Wrap * expr | Sizeof of expr | SizeofTy of expr ctype region_Wrap | EFnCall of expr * expr list |
    CompLiteral of expr ctype * (designator list * initializer) list | Arbitrary of expr ctype | MKBOOL of expr
  val equal_Unsynchronized_ref : 'a equal -> 'a unsynchronized_ref -> 'a unsynchronized_ref -> bool
  val equal_binoptype : binoptype -> binoptype -> bool
  val equal_unoptype : unoptype -> unoptype -> bool
  val equal_base_inttype : base_inttype -> base_inttype -> bool
  val equal_optiona : 'a equal -> 'a option -> 'a option -> bool
  val equal_ctypea : 'a equal -> 'a ctype -> 'a ctype -> bool
  val equal_ctype : 'a equal -> 'a ctype equal
  val equal_StringCvt_radix : stringCvt_radix -> stringCvt_radix -> bool
  val equal_literalconstant_nodea : literalconstant_node -> literalconstant_node -> bool
  val equal_literalconstant_node : literalconstant_node equal
  val equal_proda : 'a equal -> 'b equal -> 'a * 'b -> 'a * 'b -> bool
  val equal_prod : 'a equal -> 'b equal -> ('a * 'b) equal
  val equal_more_infoa : more_info -> more_info -> bool
  val equal_more_info : more_info equal
  val equal_option : 'a equal -> ('a option) equal
  val equal_expr : expr equal
  val equal_expr_nodea : expr_node -> expr_node -> bool
  val equal_expr_node : expr_node equal
  val equal_expra : expr -> expr -> bool
  val equal_designatora : designator -> designator -> bool
  val equal_designator : designator equal
  val equal_initializera : initializer -> initializer -> bool
  val equal_initializer : initializer equal
  val equal_literal : string equal
  datatype ocl_multiplicity_single = Mult_nat of Code_Numeral.natural | Mult_star | Mult_infinity
  datatype ocl_collection = Set | Sequence | Ordered0 | Subsets0 | Union0 | Redefines0 | Derived0 | Qualifier0 | Nonunique0
  datatype 'a ocl_multiplicity_ext = Ocl_multiplicity_ext of (ocl_multiplicity_single * ocl_multiplicity_single option) list * abr_string option * ocl_collection list * 'a
  val equal_naturala : Code_Numeral.natural -> Code_Numeral.natural -> bool
  val equal_ocl_multiplicity_singlea : ocl_multiplicity_single -> ocl_multiplicity_single -> bool
  val equal_ocl_multiplicity_single : ocl_multiplicity_single equal
  val equal_ocl_collectiona : ocl_collection -> ocl_collection -> bool
  val equal_ocl_collection : ocl_collection equal
  val equal_ocl_multiplicity_ext : 'a equal -> 'a ocl_multiplicity_ext -> 'a ocl_multiplicity_ext -> bool
  datatype 'a ocl_ty_class_node_ext = Ocl_ty_class_node_ext of Code_Numeral.natural * unit ocl_multiplicity_ext * abr_string * 'a
  val equal_unita : unit -> unit -> bool
  val equal_unit : unit equal
  val equal_ocl_ty_class_node_ext : 'a equal -> 'a ocl_ty_class_node_ext -> 'a ocl_ty_class_node_ext -> bool
  datatype 'a ocl_ty_class_ext = Ocl_ty_class_ext of abr_string * Code_Numeral.natural * Code_Numeral.natural * unit ocl_ty_class_node_ext * unit ocl_ty_class_node_ext * 'a
  val equal_ocl_ty_class_ext : 'a equal -> 'a ocl_ty_class_ext -> 'a ocl_ty_class_ext -> bool
  datatype ocl_ty_obj_core = OclTyCore_pre of abr_string | OclTyCore of unit ocl_ty_class_ext
  val equal_ocl_ty_obj_corea : ocl_ty_obj_core -> ocl_ty_obj_core -> bool
  datatype ocl_ty_obj = OclTyObj of ocl_ty_obj_core * (ocl_ty_obj_core list) list
  val equal_ocl_ty_obj_core : ocl_ty_obj_core equal
  val equal_ocl_ty_obj : ocl_ty_obj -> ocl_ty_obj -> bool
  datatype ocl_ty = OclTy_base_void | OclTy_base_boolean | OclTy_base_integer | OclTy_base_unlimitednatural | OclTy_base_real | OclTy_base_string | OclTy_object of ocl_ty_obj | OclTy_collection of unit ocl_multiplicity_ext * ocl_ty |
    OclTy_pair of ocl_ty * ocl_ty | OclTy_binding of (abr_string option * ocl_ty) | OclTy_arrow of ocl_ty * ocl_ty | OclTy_class_syn of abr_string | OclTy_enum of abr_string | OclTy_raw of abr_string
  val equal_ocl_ty : ocl_ty equal
  val equal_ocl_tya : ocl_ty -> ocl_ty -> bool
  datatype 'a itself = Type
  type 'a len0
  val len_of : 'a len0 -> 'a itself -> nat
  val times_nat : nat -> nat -> nat
  type 'a ord
  val less_eq : 'a ord -> 'a -> 'a -> bool
  val less : 'a ord -> 'a -> 'a -> bool
  val max : 'a ord -> 'a -> 'a -> 'a
  val ord_integer : int ord
  val nat_of_integer : int -> nat
  type 'a finite
  datatype 'a bit0 = Abs_bit0 of inta
  val len_of_bit0 : 'a len0 -> 'a bit0 itself -> nat
  val len0_bit0 : 'a len0 -> 'a bit0 len0
  val one_nat : nat
  datatype num1 = One_num1
  val len_of_num1 : num1 itself -> nat
  val len0_num1 : num1 len0
  datatype ocl_class = OclClass of abr_string * (abr_string * ocl_ty) list * ocl_class list
  val equal_ocl_class : ocl_class equal
  val equal_ocl_classa : ocl_class -> ocl_class -> bool
  datatype opt_ident = OptIdent of Code_Numeral.natural
  val equal_opt_identa : opt_ident -> opt_ident -> bool
  val equal_opt_ident : opt_ident equal
  val one_integera : int
  val one_integer : int one
  type 'a plus
  val plusa : 'a plus -> 'a -> 'a -> 'a
  val plus_integer : int plus
  val zero_integer : int zero
  type 'a zero_neq_one
  val one_zero_neq_one : 'a zero_neq_one -> 'a one
  val zero_zero_neq_one : 'a zero_neq_one -> 'a zero
  val zero_neq_one_integer : int zero_neq_one
  val equal_natural : Code_Numeral.natural equal
  val one_natural : Code_Numeral.natural one
  val plus_natural : Code_Numeral.natural plus
  val zero_natural : Code_Numeral.natural zero
  datatype gcc_attribute = GCC_AttribID of abr_string | GCC_AttribFn of abr_string * expr list | OWNED_BY of abr_string
  val equal_gcc_attributea : gcc_attribute -> gcc_attribute -> bool
  val equal_gcc_attribute : gcc_attribute equal
  datatype opt_attr_type = OptInh | OptOwn
  val equal_opt_attr_typea : opt_attr_type -> opt_attr_type -> bool
  val equal_opt_attr_type : opt_attr_type equal
  datatype internal_oid = Oid of Code_Numeral.natural
  val equal_internal_oida : internal_oid -> internal_oid -> bool
  val equal_internal_oid : internal_oid equal
  datatype generation_lemma_mode = Gen_sorry | Gen_no_dirty
  val equal_generation_lemma_modea : generation_lemma_mode -> generation_lemma_mode -> bool
  val equal_generation_lemma_mode : generation_lemma_mode equal
  datatype 'a word = Word of inta
  datatype ('a, 'b) nsplit = Nsplit_text of 'a | Nsplit_sep of 'b
  datatype ('b, 'a) alist = Alist of ('b * 'a) list
  datatype ('a, 'b) sum = Inl of 'a | Inr of 'b
  datatype thyName = ThyName of abr_string
  datatype name = QName of thyName * abr_string | Name of abr_string
  datatype function_Kind = Definition | Primrec | Fun | Function_Sorry
  datatype typea = Typea of name * typea list | Func of typea * typea | TVar of name | NoType
  datatype typeSign = TypeSign of name * (name * name list) list * typea
  datatype literal = Int of Code_Numeral.natural | Stringa of abr_string
  datatype term = Literal of literal | Const of name | Abs of name * term | App of term * term | If of term * term * term | Let of (term * term) list * term | Case of term * (term * term) list |
    ListCompr of term * listComprFragment list | RecConstr of name * (name * term) list | RecUpdate of term * (name * term) list | DoBlock of abr_string * doBlockFragment list * abr_string | Parenthesized of term
  and doBlockFragment = DoGenerator of term * term | DoQualifier of term | DoLetStmt of (term * term) list
  and listComprFragment = Generator of (term * term) | Guard of term
  datatype function_Stmt = Function_Stmt of function_Kind * typeSign list * ((name * term list) * term) list
  datatype typeSpec = TypeSpec of name list * name
  datatype stmt = Datatype of (typeSpec * (name * typea list) list) list | Record of typeSpec * (name * typea) list | TypeSynonym of (typeSpec * typea) list | Functiona of function_Stmt | Class of name * name list * typeSign list |
    Instance of name * name * (name * name list) list * function_Stmt list | Comment of abr_string | SML of function_Stmt
  datatype typ = Typeb of abr_string * typ list | TFree of abr_string * abr_string list | TVara of (abr_string * Code_Numeral.natural) * abr_string list
  datatype fnspec = Fnspec of abr_string region_Wrap | Relspec of abr_string region_Wrap | Fn_modifies of abr_string list | Didnt_translate | Gcc_attribs of gcc_attribute list
  datatype semi_typ = Typ_apply of semi_typ * semi_typ list | Typ_apply_bin of abr_string * semi_typ * semi_typ | Typ_apply_paren of abr_string * abr_string * semi_typ | Typ_base of abr_string
  datatype terma = Consta of abr_string * typ | Free of abr_string * typ | Var of (abr_string * Code_Numeral.natural) * typ | Bound of Code_Numeral.natural | Absa of abr_string * typ * terma | Appa of terma * terma
  datatype semi_terma = Term_rewrite of semi_terma * abr_string * semi_terma | Term_basic of abr_string list | Term_annot of semi_terma * semi_typ | Term_bind of abr_string * semi_terma * semi_terma |
    Term_fun_case of semi_terma option * (semi_terma * semi_terma) list | Term_apply of semi_terma * semi_terma list | Term_paren of abr_string * abr_string * semi_terma | Term_if_then_else of semi_terma * semi_terma * semi_terma |
    Term_let of (semi_terma * semi_terma) list * semi_terma | Term_term of abr_string list * terma
  datatype 'a semi_locale_ext = Semi_locale_ext of abr_string * ((semi_terma * semi_typ) list * (abr_string * semi_terma) option) list * 'a
  datatype semi_thm_attribute = Thm_thm of abr_string | Thm_thms of abr_string | Thm_THEN of semi_thm_attribute * semi_thm_attribute | Thm_simplified of semi_thm_attribute * semi_thm_attribute | Thm_symmetric of semi_thm_attribute |
    Thm_where of semi_thm_attribute * (abr_string * semi_terma) list | Thm_of of semi_thm_attribute * semi_terma list | Thm_OF of semi_thm_attribute * semi_thm_attribute
  datatype semi_thm = Thms_single of semi_thm_attribute | Thms_mult of semi_thm_attribute
  datatype semi_method_simp = Method_simp_only of semi_thm list | Method_simp_add_del_split of semi_thm list * semi_thm list * semi_thm list
  datatype semi_method = Method_rule of semi_thm_attribute option | Method_drule of semi_thm_attribute | Method_erule of semi_thm_attribute | Method_intro of semi_thm_attribute list | Method_elim of semi_thm_attribute |
    Method_subst of bool * abr_string list * semi_thm_attribute | Method_insert of semi_thm list | Method_plus of semi_method list | Method_option of semi_method list | Method_or of semi_method list | Method_one of semi_method_simp |
    Method_all of semi_method_simp | Method_auto_simp_add_split of semi_thm list * abr_string list | Method_rename_tac of abr_string list | Method_case_tac of semi_terma | Method_blast of Code_Numeral.natural option | Method_clarify |
    Method_metis of abr_string list * semi_thm_attribute list
  datatype semi_command_final = Command_done | Command_by of semi_method list | Command_sorry
  datatype interpretation = Interpretation of abr_string * abr_string * semi_terma list * semi_command_final
  datatype axiomatization = Axiomatization of abr_string * semi_terma
  datatype type_notation = Type_notation of abr_string * abr_string
  datatype instantiation = Instantiation of abr_string * abr_string * semi_terma
  datatype code_reflect = Code_reflect of bool * abr_string * abr_string list
  datatype type_synonym = Type_synonym of (abr_string * abr_string list) * semi_typ
  datatype abbreviation = Abbreviation of semi_terma
  datatype overloading = Overloading of abr_string * semi_terma * abr_string * semi_terma
  datatype hide_const = Hide_const of bool * abr_string list
  datatype definition = Definitiona of semi_terma | Definition_where1 of abr_string * (semi_terma * Code_Numeral.natural) * semi_terma | Definition_where2 of abr_string * semi_terma * semi_terma
  datatype text_raw = Text_raw of abr_string
  datatype semi_datatype_version = Datatype_new | Datatype_old | Datatype_old_atomic | Datatype_old_atomic_sub
  datatype datatypea = Datatypea of semi_datatype_version * ((abr_string * abr_string list) * (abr_string * semi_typ list) list) list
  datatype section = Section of Code_Numeral.natural * abr_string
  datatype lemmas = Lemmas_simp_thm of bool * abr_string * semi_thm_attribute list | Lemmas_simp_thms of abr_string * abr_string list
  datatype consts = Consts of abr_string * semi_typ * abr_string
  datatype semi_val_fun = Sval | Sfun
  datatype semi_term = SML_top of semi_term_1 list
  and semi_term_0 = SML_string of abr_string | SML_rewrite of semi_term_0 * abr_string * semi_term_0 | SML_basic of abr_string list | SML_binop of semi_term_0 * abr_string * semi_term_0 | SML_annot of semi_term_0 * abr_string |
    SML_function of (semi_term_0 * semi_term_0) list | SML_apply of semi_term_0 * semi_term_0 list | SML_paren of abr_string * abr_string * semi_term_0 | SML_let of semi_term * semi_term_0
  and semi_term_1 = SML_open of abr_string | SML_val_fun of semi_val_fun option * semi_term_0
  datatype setup = Setup of semi_term
  datatype semi_command_state = Command_apply_end of semi_method list
  datatype semi_command_proof = Command_apply of semi_method list | Command_using of semi_thm list | Command_unfolding of semi_thm list | Command_let of semi_terma * semi_terma |
    Command_have of abr_string * bool * semi_terma * semi_command_final | Command_fix_let of abr_string list * (semi_terma * semi_terma) list * (semi_terma list * semi_terma list) option * semi_command_state list
  datatype lemma = Lemma of abr_string * semi_terma list * (semi_method list) list * semi_command_final | Lemma_assumes of abr_string * (abr_string * (bool * semi_terma)) list * semi_terma * semi_command_proof list * semi_command_final
  datatype text = Text of abr_string
  datatype thm = Thm of semi_thm_attribute list
  datatype ml = SMLa of semi_term
  datatype semi_theory = Theory_datatype of datatypea | Theory_type_synonym of type_synonym | Theory_type_notation of type_notation | Theory_instantiation of instantiation | Theory_overloading of overloading | Theory_consts of consts |
    Theory_definition of definition | Theory_lemmas of lemmas | Theory_lemma of lemma | Theory_axiomatization of axiomatization | Theory_section of section | Theory_text of text | Theory_text_raw of text_raw | Theory_ML of ml |
    Theory_setup of setup | Theory_thm of thm | Theory_interpretation of interpretation | Theory_hide_const of hide_const | Theory_abbreviation of abbreviation | Theory_code_reflect of code_reflect
  datatype generation_semantics_ocl = Gen_only_design | Gen_only_analysis | Gen_default
  datatype boot_generation_syntax = Boot_generation_syntax of generation_semantics_ocl
  datatype ocl_association_relation = OclAssRel of (ocl_ty_obj * unit ocl_multiplicity_ext) list
  datatype ocl_association_type = OclAssTy_native_attribute | OclAssTy_association | OclAssTy_composition | OclAssTy_aggregation
  datatype 'a ocl_association_ext = Ocl_association_ext of ocl_association_type * ocl_association_relation * 'a
  datatype ocl_ctxt_term = T_pure of terma * abr_string option | T_to_be_parsed of abr_string * abr_string | T_lambda of abr_string * ocl_ctxt_term
  datatype ocl_prop = OclProp_ctxt of abr_string option * ocl_ctxt_term
  datatype ocl_ctxt_term_inv = T_inv of bool * ocl_prop
  datatype ocl_ctxt_prefix = OclCtxtPre | OclCtxtPost
  datatype ocl_ctxt_term_pp = T_pp of ocl_ctxt_prefix * ocl_prop | T_invariant of ocl_ctxt_term_inv
  datatype 'a ocl_ctxt_pre_post_ext = Ocl_ctxt_pre_post_ext of abr_string * ocl_ty * ocl_ctxt_term_pp list * 'a
  datatype ocl_ctxt_clause = Ctxt_pp of unit ocl_ctxt_pre_post_ext | Ctxt_inv of ocl_ctxt_term_inv
  datatype 'a ocl_class_raw_ext = Ocl_class_raw_ext of ocl_ty_obj * (abr_string * ocl_ty) list * ocl_ctxt_clause list * bool * 'a
  datatype ocl_def_base = OclDefInteger of abr_string | OclDefReal of (abr_string * abr_string) | OclDefString of abr_string
  datatype ocl_data_shallow = ShallB_term of ocl_def_base | ShallB_str of abr_string | ShallB_self of internal_oid | ShallB_list of ocl_data_shallow list
  datatype 'a ocl_list_attr = OclAttrNoCast of 'a | OclAttrCast of abr_string * 'a ocl_list_attr * 'a
  datatype 'a ocl_instance_single_ext = Ocl_instance_single_ext of abr_string option * abr_string option * abr_string option * (((abr_string * abr_string) option * (abr_string * ocl_data_shallow)) list) ocl_list_attr * 'a
  datatype 'a ocl_def_state_core = OclDefCoreAdd of unit ocl_instance_single_ext | OclDefCoreBinding of 'a
  datatype ocl_def_pp_core = OclDefPPCoreAdd of abr_string ocl_def_state_core list | OclDefPPCoreBinding of abr_string
  datatype ocl_def_transition = OclDefPP of abr_string option * ocl_def_pp_core * ocl_def_pp_core option
  datatype ocl_def_base_l = OclDefBase of ocl_def_base list
  datatype ocl_class_tree = OclClassTree of Code_Numeral.natural * Code_Numeral.natural
  datatype ocl_def_state = OclDefSt of abr_string * abr_string ocl_def_state_core list
  datatype ocl_instance = OclInstance of unit ocl_instance_single_ext list
  datatype 'a ocl_ctxt_ext = Ocl_ctxt_ext of abr_string list * ocl_ty_obj * ocl_ctxt_clause list * 'a
  datatype ocl_class_synonym = OclClassSynonym of abr_string * ocl_ty
  datatype ocl_flush_all = OclFlushAll
  datatype ocl_ass_class = OclAssClass of unit ocl_association_ext * unit ocl_class_raw_ext
  datatype ocl_generic = OclGeneric of abr_string
  datatype ocl_enum = OclEnum of abr_string * abr_string list
  datatype gen_meta = Gen_apply_hol of abr_string | Gen_apply_sml of abr_string | Gen_apply_sml_cmd of abr_string * abr_string | Gen_no_apply
  datatype module = Module of thyName * thyName list * stmt list * bool
  datatype isaUnit = IsaUnit of (bool * Code_Numeral.natural) * (abr_string * abr_string option) list * gen_meta * abr_string * (module list * bool)
  datatype floor = Floor1 | Floor2 | Floor3
  datatype all_meta_embedding = META_enum of ocl_enum | META_class_raw of floor * unit ocl_class_raw_ext | META_association of unit ocl_association_ext | META_ass_class of floor * ocl_ass_class | META_ctxt of floor * unit ocl_ctxt_ext |
    META_haskell of isaUnit | META_class_synonym of ocl_class_synonym | META_instance of ocl_instance | META_def_base_l of ocl_def_base_l | META_def_state of floor * ocl_def_state | META_def_transition of floor * ocl_def_transition |
    META_class_tree of ocl_class_tree | META_flush_all of ocl_flush_all | META_generic of ocl_generic
  datatype semi_theories = Theories_one of semi_theory | Theories_locale of unit semi_locale_ext * (semi_theory list) list
  datatype internal_oids = Oids of Code_Numeral.natural * Code_Numeral.natural * Code_Numeral.natural
  datatype 'a compiler_env_config_ext =
    Compiler_env_config_ext of
      bool * (abr_string * (abr_string list * abr_string)) option * internal_oids * (Code_Numeral.natural * Code_Numeral.natural) * generation_semantics_ocl * ocl_class option * all_meta_embedding list *
        (string_b_a_s_e * (unit ocl_instance_single_ext * internal_oids)) list * (string_b_a_s_e * (internal_oids * (abr_string * unit ocl_instance_single_ext) ocl_def_state_core) list) list * bool * bool *
        (string_b_a_s_e list * string_b_a_s_e list) * string_b_a_s_e list * string_b_a_s_e list * (generation_lemma_mode option * bool) * 'a
  datatype boot_setup_env = Boot_setup_env of unit compiler_env_config_ext
  datatype all_meta = META_semi_theories of semi_theories | META_boot_generation_syntax of boot_generation_syntax | META_boot_setup_env of boot_setup_env | META_all_meta_embedding of all_meta_embedding
  datatype 'a embedding_fun = Embedding_fun_info of abr_string * 'a | Embedding_fun_simple of 'a
  datatype ('a, 'b) embedding = Embed_theories of ('a -> 'b -> all_meta list * 'b) embedding_fun list |
    Embed_locale of ('a -> 'b -> all_meta list * 'b) embedding_fun list * ('a -> 'b -> unit semi_locale_ext * 'b) * ('a -> 'b -> semi_theory list * 'b) list * ('a -> 'b -> all_meta list * 'b) embedding_fun list
  datatype 'a tree = Tree of 'a * 'a tree list
  datatype asmblock = Asmblock of abr_string * (abr_string option * (abr_string * expr)) list * (abr_string option * (abr_string * expr)) list * abr_string list
  datatype storage_class = SC_EXTERN | SC_STATIC | SC_AUTO | SC_REGISTER | SC_THRD_LOCAL
  datatype declaration = VarDecl of (expr ctype * (abr_string region_Wrap * (storage_class list * (initializer option * gcc_attribute list)))) | StructDecl of abr_string region_Wrap * (expr ctype * abr_string region_Wrap) list |
    TypeDecl of (expr ctype * abr_string region_Wrap) list | ExtFnDecl of expr ctype * abr_string region_Wrap * (expr ctype * abr_string option) list * fnspec list |
    EnumDecl of (abr_string option) region_Wrap * (abr_string region_Wrap * expr option) list
  datatype trappable = BreakT | ContinueT
  datatype block_item = BI_Stmt of statement | BI_Decl of declaration region_Wrap
  and statement_node = Assign of expr * expr | AssignFnCall of expr option * expr * expr list | Chaos of expr | EmbFnCall of expr * expr * expr list | Block of block_item list | While of expr * abr_string region_Wrap option * statement
    | Trap of trappable * statement | Return of expr option | ReturnFnCall of expr * expr list | Break | Continue | IfStmt of expr * statement * statement | Switch of expr * ((expr option) list * block_item list) list | EmptyStmt |
    Auxupd of abr_string | Ghostupd of abr_string | Spec of ((abr_string * abr_string) * (statement list * abr_string)) | AsmStmt of bool * asmblock | LocalInit of expr
  and statement = Stmt of statement_node region_Wrap
  datatype ext_decl = FnDefn of (expr ctype * abr_string region_Wrap) * (expr ctype * abr_string region_Wrap) list * fnspec list * (block_item list) region_Wrap | Decl of declaration region_Wrap
  datatype 'a tmp_inh = Tinh of 'a
  datatype 'a tmp_sub = Tsub of 'a
  datatype namea = Name0 of int
  datatype position = EQ | LT | GT | UN
  datatype 'a tmp_univ = Tuniv of 'a
  datatype cChar = CChar0 of char * bool | CChars0 of char list * bool
  datatype 'a flags = Flags0 of int
  datatype positiona = Position0 of int * abr_string * int * int | NoPosition0 | BuiltinPosition0 | InternalPosition0
  datatype nodeInfo = OnlyPos0 of positiona * (positiona * int) | NodeInfo0 of positiona * (positiona * int) * namea
  datatype ident = Ident0 of abr_string * int * nodeInfo
  datatype cFloat = CFloat0 of abr_string
  datatype sUERef = AnonymousRef0 of namea | NamedRef0 of ident
  datatype ('a, 'b) either = Left of 'a | Right of 'b
  datatype 'a optiona = None | Some of 'a
  datatype ('a, 'b, 'c, 'd) struct_flat = Struct_root of 'a * 'b * (('a * 'c), 'd) sum list | Struct_leaf of (('a * 'b), 'd) sum
  datatype ('a, 'b, 'c, 'd) struct_tree = Struct_tree of 'a option * 'b * ((('a, 'b, 'c, 'd) struct_tree * 'c), 'd) sum list
  datatype reporting = Warning | Error | Writeln
  datatype cString = CString0 of abr_string * bool
  datatype commentFormat = SingleLine | MultiLine
  datatype comment = Commenta of positiona * abr_string * commentFormat
  datatype ('a, 'b, 'c, 'd, 'e, 'f) declaration0 = VarDecl0 of 'a | StructDecl0_root of 'b | StructDecl0_child of 'c | TypeDecl0 of 'd | ExtFnDecl0 of 'e | EnumDecl0 of 'f
  datatype cIntFlag = FlagUnsigned0 | FlagLong0 | FlagLongLong0 | FlagImag0
  datatype cIntRepr = DecRepr0 | HexRepr0 | OctalRepr0
  datatype cInteger = CInteger0 of int * cIntRepr * cIntFlag flags
  datatype cUnaryOp = CPreIncOp0 | CPreDecOp0 | CPostIncOp0 | CPostDecOp0 | CAdrOp0 | CIndOp0 | CPlusOp0 | CMinOp0 | CCompOp0 | CNegOp0
  datatype parsing_style = Style_Haskell | Style_ML
  datatype cAssignOp = CAssignOp0 | CMulAssOp0 | CDivAssOp0 | CRmdAssOp0 | CAddAssOp0 | CSubAssOp0 | CShlAssOp0 | CShrAssOp0 | CAndAssOp0 | CXorAssOp0 | COrAssOp0
  datatype cBinaryOp = CMulOp0 | CDivOp0 | CRmdOp0 | CAddOp0 | CSubOp0 | CShlOp0 | CShrOp0 | CLeOp0 | CGrOp0 | CLeqOp0 | CGeqOp0 | CEqOp0 | CNeqOp0 | CAndOp0 | CXorOp0 | COrOp0 | CLndOp0 | CLorOp0
  datatype 'a cConstant = CIntConst0 of cInteger * 'a | CCharConst0 of cChar * 'a | CFloatConst0 of cFloat * 'a | CStrConst0 of cString * 'a
  datatype 'a class_output = C_out_OclAny | C_out_simple of 'a
  datatype 'a cFunctionSpecifier = CInlineQual0 of 'a | CNoreturnQual0 of 'a
  datatype 'a cStorageSpecifier = CAuto0 of 'a | CRegister0 of 'a | CStatic0 of 'a | CExtern0 of 'a | CTypedef0 of 'a | CThread0 of 'a
  datatype cStructTag = CStructTag0 | CUnionTag0
  datatype 'a cStringLiteral = CStrLit0 of cString * 'a
  datatype 'a cArraySize = CNoArrSize0 of bool | CArrSize0 of bool * 'a cExpression
  and 'a cDerivedDeclarator = CPtrDeclr0 of 'a cTypeQualifier list * 'a | CArrDeclr0 of 'a cTypeQualifier list * 'a cArraySize * 'a | CFunDeclr0 of ((ident list), ('a cDeclaration list * bool)) either * 'a cAttribute list * 'a
  and 'a cDeclarator = CDeclr0 of ident optiona * 'a cDerivedDeclarator list * 'a cStringLiteral optiona * 'a cAttribute list * 'a
  and 'a cFunctionDef = CFunDef0 of 'a cDeclarationSpecifier list * 'a cDeclarator * 'a cDeclaration list * 'a cStatement * 'a
  and 'a cCompoundBlockItem = CBlockStmt0 of 'a cStatement | CBlockDecl0 of 'a cDeclaration | CNestedFunDef0 of 'a cFunctionDef
  and 'a cStatement = CLabel0 of ident * 'a cStatement * 'a cAttribute list * 'a | CCase0 of 'a cExpression * 'a cStatement * 'a | CCases0 of 'a cExpression * 'a cExpression * 'a cStatement * 'a | CDefault0 of 'a cStatement * 'a |
    CExpr0 of 'a cExpression optiona * 'a | CCompound0 of ident list * 'a cCompoundBlockItem list * 'a | CIf0 of 'a cExpression * 'a cStatement * 'a cStatement optiona * 'a | CSwitch0 of 'a cExpression * 'a cStatement * 'a |
    CWhile0 of 'a cExpression * 'a cStatement * bool * 'a | CFor0 of ('a cExpression optiona, 'a cDeclaration) either * 'a cExpression optiona * 'a cExpression optiona * 'a cStatement * 'a | CGoto0 of ident * 'a |
    CGotoPtr0 of 'a cExpression * 'a | CCont0 of 'a | CBreak0 of 'a | CReturn0 of 'a cExpression optiona * 'a | CAsm0 of 'a cAssemblyStatement * 'a
  and 'a cExpression = CComma0 of 'a cExpression list * 'a | CAssign0 of cAssignOp * 'a cExpression * 'a cExpression * 'a | CCond0 of 'a cExpression * 'a cExpression optiona * 'a cExpression * 'a |
    CBinary0 of cBinaryOp * 'a cExpression * 'a cExpression * 'a | CCast0 of 'a cDeclaration * 'a cExpression * 'a | CUnary0 of cUnaryOp * 'a cExpression * 'a | CSizeofExpr0 of 'a cExpression * 'a | CSizeofType0 of 'a cDeclaration * 'a
    | CAlignofExpr0 of 'a cExpression * 'a | CAlignofType0 of 'a cDeclaration * 'a | CComplexReal0 of 'a cExpression * 'a | CComplexImag0 of 'a cExpression * 'a | CIndex0 of 'a cExpression * 'a cExpression * 'a |
    CCall0 of 'a cExpression * 'a cExpression list * 'a | CMember0 of 'a cExpression * ident * bool * 'a | CVar0 of ident * 'a | CConst0 of 'a cConstant |
    CCompoundLit0 of 'a cDeclaration * ('a cPartDesignator list * 'a cInitializer) list * 'a | CGenericSelection0 of 'a cExpression * ('a cDeclaration optiona * 'a cExpression) list * 'a | CStatExpr0 of 'a cStatement * 'a |
    CLabAddrExpr0 of ident * 'a | CBuiltinExpr0 of 'a cBuiltinThing
  and 'a cAttribute = CAttr0 of ident * 'a cExpression list * 'a
  and 'a cTypeQualifier = CConstQual0 of 'a | CVolatQual0 of 'a | CRestrQual0 of 'a | CAtomicQual0 of 'a | CAttrQual0 of 'a cAttribute | CNullableQual0 of 'a | CNonnullQual0 of 'a
  and 'a cEnumeration = CEnum0 of ident optiona * ((ident * 'a cExpression optiona) list) optiona * 'a cAttribute list * 'a
  and 'a cPartDesignator = CArrDesig0 of 'a cExpression * 'a | CMemberDesig0 of ident * 'a | CRangeDesig0 of 'a cExpression * 'a cExpression * 'a
  and 'a cInitializer = CInitExpr0 of 'a cExpression * 'a | CInitList0 of ('a cPartDesignator list * 'a cInitializer) list * 'a
  and 'a cAssemblyOperand = CAsmOperand0 of ident optiona * 'a cStringLiteral * 'a cExpression * 'a
  and 'a cAssemblyStatement = CAsmStmt0 of 'a cTypeQualifier optiona * 'a cStringLiteral * 'a cAssemblyOperand list * 'a cAssemblyOperand list * 'a cStringLiteral list * 'a
  and 'a cAlignmentSpecifier = CAlignAsType0 of 'a cDeclaration * 'a | CAlignAsExpr0 of 'a cExpression * 'a
  and 'a cDeclarationSpecifier = CStorageSpec0 of 'a cStorageSpecifier | CTypeSpec0 of 'a cTypeSpecifier | CTypeQual0 of 'a cTypeQualifier | CFunSpec0 of 'a cFunctionSpecifier | CAlignSpec0 of 'a cAlignmentSpecifier
  and 'a cDeclaration = CDecl0 of 'a cDeclarationSpecifier list * (('a cDeclarator optiona * 'a cInitializer optiona) * 'a cExpression optiona) list * 'a | CStaticAssert0 of 'a cExpression * 'a cStringLiteral * 'a
  and 'a cBuiltinThing = CBuiltinVaArg0 of 'a cExpression * 'a cDeclaration * 'a | CBuiltinOffsetOf0 of 'a cDeclaration * 'a cPartDesignator list * 'a | CBuiltinTypesCompatible0 of 'a cDeclaration * 'a cDeclaration * 'a
  and 'a cStructureUnion = CStruct0 of cStructTag * ident optiona * ('a cDeclaration list) optiona * 'a cAttribute list * 'a
  and 'a cTypeSpecifier = CVoidType0 of 'a | CCharType0 of 'a | CShortType0 of 'a | CIntType0 of 'a | CLongType0 of 'a | CFloatType0 of 'a | CDoubleType0 of 'a | CSignedType0 of 'a | CUnsigType0 of 'a | CBoolType0 of 'a |
    CComplexType0 of 'a | CInt128Type0 of 'a | CSUType0 of 'a cStructureUnion * 'a | CEnumType0 of 'a cEnumeration * 'a | CTypeDef0 of ident * 'a | CTypeOfExpr0 of 'a cExpression * 'a | CTypeOfType0 of 'a cDeclaration * 'a |
    CAtomicType0 of 'a cDeclaration * 'a
  datatype fold_all_input = Fold_meta of all_meta_embedding | Fold_custom of all_meta list
  datatype clangCVersion = ClangCVersion0 of abr_string
  datatype 'a cExternalDeclaration = CDeclExt0 of 'a cDeclaration | CFDefExt0 of 'a cFunctionDef | CAsmExt0 of 'a cStringLiteral * 'a
  datatype 'a cTranslationUnit = CTranslUnit0 of 'a cExternalDeclaration list * 'a
  datatype 'a comment_type = Invariant of char list | Fnspeca of (char list * char list) list | Relspeca of char list | Modifies of ((char list) option) list | Dont_translate | Auxupda of char list | Ghostupda of char list |
    Speca of (char list * char list) | End_spec of char list | Calls of ((char list) option) list | Owned_by of char list | OTHER of 'a
  datatype ('a, 'b) inheritance_ext = Inheritance_ext of 'a * ('a * 'a list) list * 'a list * 'b
  datatype 'a lexical_ext = Lexical_ext of abr_string * abr_string * (abr_string -> semi_terma) * 'a
  datatype print_examp_instance_draw_list_attr = Return_obj of unit ocl_ty_class_ext | Return_exp of semi_terma
  datatype print_examp_instance_draw_list_attr_err = Return_err_ty of (ocl_ty * ocl_data_shallow) | Return_err_ty_auto | Return_ocl_null | Return_ocl_invalid | Return_object_variable of abr_string |
    Return_err_l of print_examp_instance_draw_list_attr_err list
  datatype 'a print_examp_instance_draw_list_attra = Return_val of 'a | Return_err of print_examp_instance_draw_list_attr_err
  datatype ('a, 'b) print_iskindof_up_istypeof_output = M_simp_only of 'a | M_erule of 'b | M_simp_d_e_p_t_h_1 | M_simp_d_e_p_t_h_2 | M_simp_b_r_e_a_d_t_h
  val id : 'a -> 'a
  val plus_nat : nat -> nat -> nat
  val suc : nat -> nat
  val d_output_header_thy : 'a compiler_env_config_ext -> (abr_string * (abr_string list * abr_string)) option
  val d_ocl_semantics : 'a compiler_env_config_ext -> generation_semantics_ocl
  val flattena : abr_string list -> abr_string
  val flattenb : abr_string -> abr_string -> abr_string
  val foldl : ('a -> 'b -> 'a) -> 'a -> 'b list -> 'a
  val fold : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
  val rev : 'a list -> 'a list
  val map : ('a -> 'b) -> 'a list -> 'b list
  val replace_integers : (int -> abr_string) -> abr_string -> string option -> abr_string -> abr_string
  val map_gena : (abr_string -> string option -> abr_string -> abr_string) -> (int -> abr_string) -> string_b_a_s_e -> abr_string
  val mapa : ('a -> 'b) -> 'a list -> 'b list
  val map_gen : (abr_string -> string option -> abr_string -> abr_string) -> (int -> abr_string) -> abr_string -> abr_string
  val replace_integersa : (int -> abr_string) -> abr_string -> abr_string
  val mapM : ('a -> 'b -> 'c * 'b) -> 'a list -> 'b -> 'c list * 'b
  val start_map : ('a -> 'b) -> 'a list -> 'c -> 'b list * 'c
  val start_mapf : ('a -> 'b) -> ((abr_string -> abr_string) -> generation_semantics_ocl -> 'a list) -> 'c compiler_env_config_ext -> 'b list * 'c compiler_env_config_ext
  val i : ('a -> semi_theory) -> 'a -> all_meta
  val text : text -> all_meta
  val txt : ((abr_string -> abr_string) -> generation_semantics_ocl -> abr_string) -> ('a -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun
  val minus_nat : nat -> nat -> nat
  val nth : 'a list -> nat -> 'a
  val less_nat : nat -> nat -> bool
  val upt : nat -> nat -> nat list
  val zip : 'a list -> 'b list -> ('a * 'b) list
  val app_rev : 'a -> ('a -> 'b) -> 'b
  val current_parsing_style : parsing_style
  val function_definition_params0 : ('a cDeclaration -> 'b) -> 'a cDeclaration list -> 'b list
  val ident_struct_type0 : abr_string -> abr_string
  val less_eq_nat : nat -> nat -> bool
  val foldl_one : ('a -> int -> 'a) -> 'a -> string -> 'a
  val foldlb : ('a -> int -> 'a) -> 'a -> string_b_a_s_e -> 'a
  val foldla : ('a -> int -> 'a) -> 'a -> abr_string -> 'a
  val to_list : abr_string -> int list
  val length : abr_string -> nat
  val pref_ident : abr_string -> abr_string
  val ident_struct_type : ident -> abr_string
  val decl_spec_ty_tag : cStructTag -> abr_string -> 'a ctype
  val map_option : ('a -> 'b) -> 'a optiona -> 'b option
  val ident : ident -> abr_string
  val ident_option : ident optiona -> abr_string option
  val map_filter : ('a -> 'b option) -> 'a list -> 'b list
  val identb : ident -> 'a ctype
  val takeWhile : ('a -> bool) -> 'a list -> 'a list
  val dropWhile : ('a -> bool) -> 'a list -> 'a list
  val groupBy : ('a -> 'a -> bool) -> 'a list -> ('a list) list
  val tl : 'a list -> 'a list
  val hd : 'a list -> 'a
  val decl_spec_ty : 'a cDeclarationSpecifier list -> 'b ctype
  val ident_struct_const : ident -> abr_string
  val meta_of_logic : abr_string -> string
  val not_yet_supported : abr_string -> unit
  val map_prod : ('a -> 'b) -> ('c -> 'd) -> 'a * 'c -> 'b * 'd
  val bogus : sourcePos
  val comp2 : ('a -> 'b) -> ('c -> 'd -> 'a) -> 'c -> 'd -> 'b
  val wrap : 'a -> sourcePos -> sourcePos -> 'a region_Wrap
  val bogwrap : 'a -> 'a region_Wrap
  val ebogwrap : expr_node -> expr
  val of_boola : 'a zero_neq_one -> bool -> 'a
  val integer_of_char : char -> int
  val show_intFlag : cIntFlag -> abr_string
  val apsnd : ('a -> 'b) -> 'c * 'a -> 'c * 'b
  val divmod_integer : int -> int -> int * int
  val snd : 'a * 'b -> 'b
  val modulo_integer : int -> int -> int
  val modulo_int : inta -> inta -> inta
  val power : 'a power -> 'a -> nat -> 'a
  val word_of_int : 'a len0 -> inta -> 'a word
  val foldr : ('a -> 'b -> 'b) -> 'a list -> 'b -> 'b
  val concat : ('a list) list -> 'a list
  val fst : 'a * 'b -> 'a
  val divide_integer : int -> int -> int
  val divide_int : inta -> inta -> inta
  val bin_rest : inta -> inta
  val equal_int : inta -> inta -> bool
  val bin_last : inta -> bool
  val bin_to_bl_aux : nat -> inta -> bool list -> bool list
  val bin_to_bl : nat -> inta -> bool list
  val uint : 'a len0 -> 'a word -> inta
  val to_bl : 'a len0 -> 'a word -> bool list
  val constant : 'a cConstant -> literalconstant_node region_Wrap
  val binaryOp : cBinaryOp -> binoptype
  val unaryOp : cUnaryOp -> unoptype
  val deriv_decl_spec : 'a cDerivedDeclarator list -> 'a cDeclarationSpecifier list -> expr ctype
  val expression0 : 'a cExpression -> expr_node
  val expression : 'a cExpression -> expr
  val partDesignator : 'a cPartDesignator -> designator
  val initializerList : ('a cPartDesignator list * 'a cInitializer) list -> (designator list * initializer) list
  val initializer0 : ('a cExpression -> 'a cExpression) -> 'a cInitializer -> initializer
  val initializer : 'a cInitializer -> initializer
  val deriv_decl_spec0 : 'a cDerivedDeclarator list -> expr ctype -> expr ctype
  val function_definition_params : (abr_string -> 'a) -> 'b cDeclaration list -> (expr ctype * 'a) list
  val p_first_of_NodeInfo : nodeInfo -> positiona * int
  val p_last_of_NodeInfo : nodeInfo -> positiona * int
  val pos_of_CFunDef : 'a cFunctionDef -> 'a
  val pos_of_CStat : 'a cStatement -> 'a
  val pos_of_CDecl : 'a cDeclaration -> 'a
  val pos_of_CBlockItem : 'a cCompoundBlockItem -> 'a
  val map_comment_type : ('a -> 'b) -> 'a comment_type -> 'b comment_type
  val catch_error : ('a, 'b) sum -> ('a -> ('c, 'b) sum) -> ('c, 'b) sum
  val or : ('a -> ('b, 'c) sum) -> ('a -> ('d, 'c) sum) -> 'a -> ('d, 'c) sum
  val returna : 'a -> 'b list -> ((char list), ('a * 'b list)) sum
  val bindc : ('a, 'b) sum -> ('b -> ('a, 'c) sum) -> ('a, 'c) sum
  val bindd : ('a list -> ((char list), ('b * 'a list)) sum) -> ('b -> 'a list -> ((char list), ('c * 'a list)) sum) -> 'a list -> ((char list), ('c * 'a list)) sum
  val many_c_a_t_c_h_a_l_l_aux : 'a list -> ('b list -> ((char list), ('a * 'b list)) sum) -> 'b list -> ((char list), ('a list * 'b list)) sum
  val many_c_a_t_c_h_a_l_l : ('a list -> ((char list), ('b * 'a list)) sum) -> 'a list -> ((char list), ('b list * 'a list)) sum
  val map_sum : ('a -> 'b) -> ('c -> 'd) -> ('a, 'c) sum -> ('b, 'd) sum
  val bind2 : ('a, ('b * 'c)) sum -> ('b -> 'd) -> ('a, ('d * 'c)) sum
  val bind3 : ('a -> ('b, ('c * 'd)) sum) -> ('c -> 'e) -> 'a -> ('b, ('e * 'd)) sum
  val bit_cut_integer : int -> int * bool
  val char_of_integer : int -> char
  val explode : string -> char list
  val scan_upto_b_i_n_d : ('a list -> ('b, ('c * 'a list)) sum) -> 'a list -> ((char list), (('a list * 'c) * 'a list)) sum
  val errorb : char list -> 'a list -> ((char list), ('b * 'a list)) sum
  val oneof_b_i_n_d : ('a list -> ((char list), ('b * 'a list)) sum) list -> 'a list -> ((char list), ('b * 'a list)) sum
  val bind_k : ('a -> ('b, ('c * 'd)) sum) -> 'e -> 'a -> ('b, ('e * 'd)) sum
  val shows_prec_list : 'a show -> nat -> 'a list -> char list -> char list
  val shows_quote : (char list -> char list) -> char list -> char list
  val take : nat -> 'a list -> 'a list
  val err_expecting : 'a show -> char list -> 'a list -> ((char list), ('b * 'a list)) sum
  val exactly_aux : 'a equal * 'a show -> char list -> 'a list -> 'a list -> 'a list -> ((char list), (char list * 'a list)) sum
  val exactly : char list -> char list -> ((char list), (char list * char list)) sum
  val many : (char -> bool) -> char list -> ((char list), (char list * char list)) sum
  val many1 : (char -> bool) -> char list -> ((char list), (char list * char list)) sum
  val member : 'a equal -> 'a list -> 'a -> bool
  val manyof1 : char list -> char list -> ((char list), (char list * char list)) sum
  val stars1 : char list -> ((char list), (char list * char list)) sum
  val end_comment : char list -> ((char list), (char list * char list)) sum
  val parse_id_m_a_y_b_e : (char list) list -> char list -> ((char list), ((char list * (char list) option) * char list)) sum
  val parse_id_o_n_e : (char list) list -> char list -> ((char list), (char list * char list)) sum
  val many_m_a_x_aux : 'a list -> ('b list -> ((char list), ('a * 'b list)) sum) -> 'b list -> ((char list), ('a list * 'b list)) sum
  val many_m_a_x : ('a list -> ((char list), ('b * 'a list)) sum) -> 'a list -> ((char list), ('b list * 'a list)) sum
  val parse_id_list : (char list) list -> char list -> ((char list), (((char list) option) list * char list)) sum
  val in_safe_monad : ('a -> ('b, 'c) sum) -> 'a -> 'c
  val parse_str_aux : (char list) list -> char list -> ((char list), (char list * char list)) sum
  val parse_str : char list -> ((char list), (char list * char list)) sum
  val shows_sep : ('a -> char list -> char list) -> (char list -> char list) -> 'a list -> char list -> char list
  val null : 'a list -> bool
  val shows_list_gen : ('a -> char list -> char list) -> char list -> char list -> char list -> char list -> 'a list -> char list -> char list
  val showsp_list : (nat -> 'a -> char list -> char list) -> nat -> 'a list -> char list -> char list
  val shows_list_list : 'a show -> ('a list) list -> char list -> char list
  val gen_length : nat -> 'a list -> nat
  val size_list : 'a list -> nat
  val trim : char list -> char list
  val drop : nat -> 'a list -> 'a list
  val oneof_aux : (char list) list -> (char list) list -> char list -> ((char list), (char list * char list)) sum
  val oneof : (char list) list -> char list -> ((char list), (char list * char list)) sum
  val eoi : 'a show -> 'a list -> ((char list), (unit * 'a list)) sum
  val parse_commenta : char list -> ((char list), ((char list) comment_type list * char list)) sum
  val string_implode : char list -> abr_string
  val errora : abr_string -> 'a
  val parse_comment : comment -> abr_string comment_type list
  val sbogwrap : statement_node -> statement
  val filter_statement : comment list -> (block_item, ((abr_string * abr_string), abr_string) sum) sum list
  val impl_of : ('b, 'a) alist -> ('b * 'a) list
  val map_of : 'a equal -> ('a * 'b) list -> 'a -> 'b option
  val lookup : 'a equal -> ('a, 'b) alist -> 'a -> 'b option
  val lookupa : 'a equal -> ('a, 'b) alist -> 'a -> 'b option
  val get_column : 'a equal -> 'b plus * 'b ord -> ('a, (('b * 'b) list)) alist -> 'a -> 'b -> 'b
  val pos_in_interval_haskell : ((abr_string * int), ((int * int) list)) alist -> (positiona * int) * (positiona * int) -> positiona -> bool
  val pos_in_interval_ml : 'a -> (positiona * int) * (positiona * int) -> positiona -> bool
  val pos_in_interval : ((abr_string * int), ((int * int) list)) alist -> (positiona * int) * (positiona * int) -> positiona -> bool
  val partition : ('a -> bool) -> 'a list -> 'a list * 'a list
  val comment_interval : comment list * ((abr_string * int), ((int * int) list)) alist -> (positiona * int) * (positiona * int) -> comment list
  val return : 'a -> 'b -> 'b * 'a
  val bindb : ('a -> 'b * 'c) -> ('c -> 'b -> 'd) -> 'a -> 'd
  val foldM_o : ('a -> 'b -> 'b * 'c) -> 'a optiona -> 'b -> 'b * 'c optiona
  val unsupported : abr_string -> 'a -> 'a * nodeInfo cExpression
  val foldM : ('a -> 'b -> 'b * 'c) -> 'a list -> 'b -> 'b * 'c list
  val stmt_out_of_expr : nodeInfo cExpression -> 'a -> 'a * nodeInfo cExpression
  val stmt_out_of_expra : nodeInfo cExpression -> nodeInfo cExpression
  val map_optiona : ('a -> 'b) -> 'a option -> 'b option
  val maps : ('a -> 'b list) -> 'a list -> 'b list
  val filter_gen : (abr_string comment_type -> (char list) option) -> (abr_string -> 'a) -> comment list -> 'a option
  val filter_owned_by : comment list -> gcc_attribute option
  val tree_of_decl_spec :
    'a cStructureUnion ->
      (abr_string, (cStructTag * ('a cDeclaration list * ('a cAttribute list * 'a))), (cStructTag * (('a cDeclarator optiona * 'a cInitializer optiona) * 'a cExpression optiona) list),
        ('a cDeclarationSpecifier list * (('a cDeclarator optiona * 'a cInitializer optiona) * 'a cExpression optiona) list))
        struct_tree
  val fresh_ident : unit -> abr_string
  val concat_map : ('a -> 'b list) -> 'a list -> 'b list
  val struct_conv : (abr_string, 'a, 'b, 'c) struct_tree -> abr_string * (abr_string, 'a, 'b, 'c) struct_flat list
  val list_ex : ('a -> bool) -> 'a list -> bool
  val extract : ('a -> bool) -> 'a list -> ('a list * ('a * 'a list)) option
  val decl_spec0 :
    'a cDeclarationSpecifier list ->
      ((nodeInfo cDeclarator optiona * 'b) * 'c) list * (positiona * int) ->
        ((ident optiona * ('d ctype option * (nodeInfo cDerivedDeclarator list * ('b * ((positiona * int) * ((positiona * int) * nodeInfo cAttribute list)))))),
          (abr_string *
            ((cStructTag * ('a cDeclaration list * ('a cAttribute list * 'a))) *
              ((abr_string * (cStructTag * (('a cDeclarator optiona * 'a cInitializer optiona) * 'a cExpression optiona) list)),
                ('a cDeclarationSpecifier list * (('a cDeclarator optiona * 'a cInitializer optiona) * 'a cExpression optiona) list))
                sum list)),
          (abr_string * (cStructTag * ('a cDeclaration list * ('a cAttribute list * 'a)))), (ident optiona * ('d ctype option * nodeInfo cDerivedDeclarator list)),
          (ident optiona * (nodeInfo cDerivedDeclarator list * ((((ident list), (nodeInfo cDeclaration list * bool)) either * (nodeInfo cAttribute list * nodeInfo)) * (nodeInfo cDerivedDeclarator list * nodeInfo cAttribute list)))),
          ((abr_string option) region_Wrap * (abr_string * expr option) list))
          declaration0 list
  val identa : ident -> abr_string
  val attrs0 : nodeInfo cAttribute -> gcc_attribute
  val empty : ('a, 'b) alist
  val emptya : ('a, 'b) alist
  val update : 'a equal -> 'a -> 'b -> ('a * 'b) list -> ('a * 'b) list
  val updatea : 'a equal -> 'a -> 'b -> ('a, 'b) alist -> ('a, 'b) alist
  val insert : 'a equal -> 'a -> 'b -> ('a, 'b) alist -> ('a, 'b) alist
  val union_loada : 'a equal -> 'a list -> bool * ('a list * ('a, unit) alist) -> bool * ('a list * ('a, unit) alist)
  val entries : ('a, 'b) alist -> ('a * 'b) list
  val is_emptya : ('a, 'b) alist -> bool
  val keys_emptya : ('a list -> 'b) -> bool * ('a list * ('c, 'd) alist) -> 'b list
  val bulkload : 'a equal -> ('a * 'b) list -> ('a, 'b) alist
  val folda : ('a -> 'b -> 'c -> 'c) -> ('a, 'b) alist -> 'c -> 'c
  val union : 'a equal -> ('a, 'b) alist -> ('a, 'b) alist -> ('a, 'b) alist
  val union_load : 'a equal -> 'a list -> 'b * ('a, unit) alist -> bool * ('a, unit) alist
  val keys : ('a, 'b) alist -> 'a list
  val keys_empty : ('a list -> 'b) -> bool * ('a, 'c) alist -> 'b list
  val collapse_mod_attribs : fnspec list -> fnspec list
  val filter_fnspec : comment list -> fnspec list
  val attrs : nodeInfo cDeclarationSpecifier list ->
                nodeInfo cDerivedDeclarator list -> nodeInfo cAttribute list -> ((comment list * ((abr_string * int), ((int * int) list)) alist) * (positiona * int) option) * (positiona * int) -> fnspec list
  val decl_spec :
    nodeInfo cDeclarationSpecifier list ->
      ((nodeInfo cDeclarator optiona * nodeInfo cInitializer optiona) * 'a) list * (positiona * int) -> ((comment list * ((abr_string * int), ((int * int) list)) alist) * (positiona * int) option) * (positiona * int) -> declaration list
  val declaration : (comment list * ((abr_string * int), ((int * int) list)) alist) * (positiona * int) option -> (declaration region_Wrap -> 'a) -> nodeInfo cDeclaration -> 'a list
  val equal_CAssignOp : cAssignOp -> cAssignOp -> bool
  val statement_of_expression_CAssign_fun : 'a cExpression -> bool
  val binoptype_of_CAssignOp : cAssignOp -> binoptype option
  val statement_of_expression_CAssign : cAssignOp -> nodeInfo cExpression -> nodeInfo cExpression -> statement_node
  val list_all : ('a -> bool) -> 'a list -> bool
  val expr_int : int -> expr
  val statement_node_of_expression : nodeInfo cExpression -> statement_node
  val filter_auxupd : comment list -> statement_node option
  val pos_of_CBuiltin : 'a cBuiltinThing -> 'a
  val pos_of_CConst : 'a cConstant -> 'a
  val pos_of_CExpr : 'a cExpression -> 'a
  val statement_node_of_expressiona : nodeInfo cExpression optiona -> (nodeInfo * (comment list * ((abr_string * int), ((int * int) list)) alist)) option -> statement_node
  val remove_last_break : 'a cStatement -> 'a cStatement option
  val statement0_case : 'a cExpression list -> 'a cStatement -> bool * ('a cExpression list * 'a cStatement)
  val statement_Switch : 'a -> (nodeInfo cCompoundBlockItem list -> (positiona * int) * (positiona * int) -> block_item list) -> 'b cExpression -> nodeInfo cCompoundBlockItem list -> nodeInfo -> statement_node
  val filter_invariant : comment list -> abr_string region_Wrap option
  val statement_While : nodeInfo cExpression -> statement * nodeInfo -> bool -> nodeInfo * (comment list * ((abr_string * int), ((int * int) list)) alist) -> statement_node
  val stringLiteral : 'a cStringLiteral -> abr_string
  val assemblyOperand : 'a cAssemblyOperand list -> (abr_string option * (abr_string * expr)) list
  val statement_For :
    (nodeInfo cExpression optiona, nodeInfo cDeclaration) either ->
      nodeInfo cExpression optiona -> nodeInfo cExpression optiona -> statement * nodeInfo -> nodeInfo * (comment list * ((abr_string * int), ((int * int) list)) alist) -> statement_node
  val statement_If : ('a -> statement) -> 'b cExpression -> 'a -> 'a optiona -> statement_node
  val group_spec_aux1 : (block_item list) list -> ((block_item list), (((abr_string * abr_string), abr_string) sum list)) sum list -> block_item list
  val group_spec_aux2 : (block_item list) list -> abr_string * abr_string -> block_item list -> abr_string -> ((block_item list), (((abr_string * abr_string), abr_string) sum list)) sum list -> block_item list
  val group_spec : (block_item, ((abr_string * abr_string), abr_string) sum) sum list -> block_item list
  val block_item_list0a : comment list * ((abr_string * int), ((int * int) list)) alist -> nodeInfo cCompoundBlockItem list -> nodeInfo -> block_item list
  val statement0 : comment list * ((abr_string * int), ((int * int) list)) alist -> nodeInfo cStatement -> statement
  val block_item_list0 : comment list * ((abr_string * int), ((int * int) list)) alist -> nodeInfo cCompoundBlockItem list -> (positiona * int) * (positiona * int) -> block_item list
  val comp3 : ('a -> 'b) -> ('c -> 'd -> 'e -> 'a) -> 'c -> 'd -> 'e -> 'b
  val block_item_list : comment list * ((abr_string * int), ((int * int) list)) alist -> nodeInfo cCompoundBlockItem list -> nodeInfo -> (block_item list) region_Wrap
  val function_definition : (comment list * ((abr_string * int), ((int * int) list)) alist) * (positiona * int) option -> nodeInfo cFunctionDef -> ext_decl
  val external_declaration : (comment list * ((abr_string * int), ((int * int) list)) alist) * (positiona * int) option -> nodeInfo cExternalDeclaration -> ext_decl list
  val pos_of_CExtDecl : 'a cExternalDeclaration -> 'a
  val mapc : 'a equal -> ('a -> 'b -> 'c) -> ('a, 'b) alist -> ('a, 'c) alist
  val translation_unit : nodeInfo cTranslationUnit * (comment list * int list) -> ext_decl list
  val main : nodeInfo cTranslationUnit * (comment list * int list) -> ext_decl list
  val txta : abr_string -> ('a -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun
  val succ : 'a one * 'a plus -> 'a -> 'a
  val flip : 'a * 'b -> 'b * 'a
  val find : ('a -> bool) -> 'a list -> 'a option
  val last : 'a list -> 'a
  val minus_int : inta -> inta -> inta
  val less_int : inta -> inta -> bool
  val upto_aux : inta -> inta -> inta list -> inta list
  val uptoa : inta -> inta -> inta list
  val txtb : abr_string list -> ('a -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun
  val modulo_nat : nat -> nat -> nat
  val divide_nat : nat -> nat -> nat
  val nat_to_digit10_aux : nat list -> nat -> nat list
  val nat_to_digit10 : nat -> abr_string
  val add_0 : int -> abr_string
  val l_fold : (('a -> 'b -> all_meta list * 'b) embedding_fun -> 'c -> 'c) -> ('a, 'b) embedding -> 'c -> 'c
  val txt_a : abr_string list -> ('a -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun
  val fun_upd : 'a equal -> ('a -> 'b) -> 'a -> 'b -> 'a -> 'b
  val bind : ('a -> 'b option) -> ('b list -> 'c) -> 'a list -> 'c option
  val mapi : (Code_Numeral.natural -> 'a -> 'b) -> 'a list -> 'b list
  val flatten : ('a list) list -> 'a list
  val mapsa : ('a -> 'b list) -> 'a list -> 'b list
  val enumerate : nat -> 'a list -> (nat * 'a) list
  val split : ('a * 'b) list -> 'a list * 'b list
  val takea : ('a list -> 'a list) -> nat -> 'a list -> 'a list
  val uptob : Code_Numeral.natural -> Code_Numeral.natural -> Code_Numeral.natural list
  val mk_dot : abr_string -> abr_string -> abr_string
  val filter : ('a -> bool) -> 'a list -> 'a list
  val binda : 'a option -> ('a -> 'b option) -> 'b option
  val start_mapa : ('a -> 'b) -> 'a -> 'c -> 'b * 'c
  val sectionb : section -> all_meta
  val section_aux : Code_Numeral.natural -> abr_string -> 'a -> 'b -> all_meta list * 'b
  val section : abr_string -> 'a -> 'b -> all_meta list * 'b
  val txt_aa : ((abr_string -> abr_string) -> abr_string list) -> ('a -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun
  val txt_d : ((abr_string -> abr_string) -> abr_string list) -> ('a -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun
  val text_raw : text_raw -> all_meta
  val txt_raw : ((abr_string -> abr_string) -> generation_semantics_ocl -> abr_string) -> ('a -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun
  val assoc : 'a equal -> 'a -> ('a * 'b) list -> 'b option
  val n_lists : nat -> 'a list -> ('a list) list
  val sectiona : abr_string -> ('a -> 'b -> all_meta list * 'b) embedding_fun
  val equal_ocl_ctxt_prefix : ocl_ctxt_prefix -> ocl_ctxt_prefix -> bool
  val d_output_sorry_dirty : 'a compiler_env_config_ext -> generation_lemma_mode option * bool
  val d_input_class : 'a compiler_env_config_ext -> ocl_class option
  val ctxt_fun_name : 'a ocl_ctxt_pre_post_ext -> abr_string
  val split_at : ('a -> bool) -> 'a list -> 'a list * ('a option * 'a list)
  val print_ctxt_to_ocl_gen_split : abr_string -> (int list) option
  val term_parenthesis : semi_terma -> semi_terma
  val term_warning_parenthesis : semi_terma -> semi_terma
  val ctxt_fun_ty : 'a ocl_ctxt_pre_post_ext -> ocl_ty
  val fold_pair_var : (abr_string * ocl_ty -> 'a -> 'a) -> ocl_ty -> 'a -> 'a option
  val ctxt_fun_ty_arg : 'a ocl_ctxt_pre_post_ext -> (abr_string * ocl_ty) list
  val var_result : abr_string
  val var_self : abr_string
  val make_ctxt_free_var : ocl_ctxt_prefix -> 'a ocl_ctxt_pre_post_ext -> abr_string list
  val interpretation : interpretation -> all_meta
  val term_lambdas : abr_string list -> semi_terma -> semi_terma
  val term_lambda : abr_string -> semi_terma -> semi_terma
  val term_applys0 : semi_terma -> semi_terma list -> semi_terma
  val term_app : abr_string -> semi_terma list -> semi_terma
  val sorry : semi_command_final
  val is_none : 'a option -> bool
  val print_ctxt_pre_post_interp : generation_lemma_mode option * bool -> abr_string -> 'a ocl_ctxt_pre_post_ext -> semi_terma -> ocl_ctxt_prefix * semi_terma -> ocl_ctxt_prefix * semi_terma -> all_meta option
  val isup : abr_string -> abr_string
  val print_ctxt_const_name : abr_string -> abr_string -> abr_string option -> abr_string
  val hol_definition : abr_string -> abr_string
  val print_ctxt_pre_post_name : abr_string -> abr_string -> abr_string option -> abr_string
  val d_ocl_accessor : 'a compiler_env_config_ext -> string_b_a_s_e list * string_b_a_s_e list
  val take_first : nat -> 'a list -> 'a list
  val take_last : nat -> 'a list -> 'a list
  val print_ctxt_is_name_at_gen : abr_string -> abr_string -> abr_string option
  val var_at_when_hol_pre : abr_string
  val print_ctxt_is_name_at_pre : abr_string -> abr_string option
  val var_at_when_hol_post : abr_string
  val print_ctxt_is_name_at_post : abr_string -> abr_string option
  val to_lista : string_b_a_s_e -> int list
  val fold_Const : ('a -> abr_string -> 'a) -> 'a -> terma -> 'a
  val map_Const : (abr_string -> typ -> abr_string) -> terma -> terma
  val print_ctxt_to_ocl_gen : string_b_a_s_e list -> (abr_string -> abr_string option) -> abr_string -> ocl_ctxt_term -> ocl_ctxt_term
  val print_ctxt_to_ocl_pre : 'a compiler_env_config_ext -> ocl_ctxt_term -> ocl_ctxt_term
  val nat_of_natural : Code_Numeral.natural -> nat
  val natural_to_digit10 : Code_Numeral.natural -> abr_string
  val var_at_when_ocl_post : abr_string
  val term_postunary : semi_terma -> semi_terma -> semi_terma
  val fold_Free : ('a -> abr_string -> 'a) -> 'a -> terma -> 'a
  val stringa : abr_string -> semi_term_0
  val binop : semi_term_0 -> abr_string -> semi_term_0 -> semi_term_0
  val binop_l : abr_string -> semi_term_0 list -> semi_term_0
  val paren : abr_string -> abr_string -> semi_term_0 -> semi_term_0
  val basic : abr_string list -> semi_term_0
  val lista : semi_term_0 list -> semi_term_0
  val listb : ('a -> semi_term_0) -> 'a list -> semi_term_0
  val parenthesis : semi_term_0 -> semi_term_0
  val pair : semi_term_0 -> semi_term_0 -> semi_term_0
  val apply : semi_term_0 -> semi_term_0 list -> semi_term_0
  val app : abr_string -> semi_term_0 list -> semi_term_0
  val app0 : abr_string -> semi_term_0 list -> semi_term
  val raise_ml : (reporting * abr_string) list -> abr_string -> ml
  val ml : ml -> all_meta
  val raise_ml_unbound : (Code_Numeral.natural -> 'a -> abr_string) -> ('a * ocl_ctxt_term) list -> ('b -> all_meta list) list
  val term_lambdas0 : semi_terma -> semi_terma -> semi_terma
  val axiomatization : axiomatization -> all_meta
  val overloadinga : abr_string -> semi_typ -> abr_string -> semi_terma -> overloading
  val ty_obj_to_string : ocl_ty_obj -> abr_string
  val ctxt_ty : 'a ocl_ctxt_ext -> ocl_ty_obj
  val term_binop : semi_terma -> abr_string -> semi_terma -> semi_terma
  val term_binopa : abr_string -> semi_terma list -> semi_terma
  val term_annot : semi_terma -> abr_string -> semi_terma
  val wrap_oclty : abr_string -> abr_string
  val term_annot_ocl : semi_terma -> abr_string -> semi_terma
  val overloading : overloading -> all_meta
  val cross_abs_aux : (abr_string -> semi_terma -> semi_terma) -> abr_string list -> nat * terma -> semi_terma
  val cross_abs : (abr_string -> semi_terma -> semi_terma) -> nat -> terma -> semi_terma
  val ty_arrow : semi_typ -> semi_typ -> semi_typ
  val ty_arrowb : semi_typ -> semi_typ
  val ctxt_expr : 'a ocl_ctxt_pre_post_ext -> ocl_ctxt_term_pp list
  val ctxt_clause : 'a ocl_ctxt_ext -> ocl_ctxt_clause list
  val fold_pre_post : ((ocl_ctxt_prefix * (abr_string option * ocl_ctxt_term)) list -> unit ocl_ctxt_pre_post_ext -> 'a -> 'a) -> 'b ocl_ctxt_ext -> 'a -> 'a
  val ty_paren : semi_typ -> semi_typ
  val dot_oclastype : abr_string
  val mk_dot_par_gen : abr_string -> abr_string list -> abr_string
  val mk_dot_par : abr_string -> abr_string -> abr_string
  val dot_astype : abr_string -> abr_string
  val get_class_hierarchy_strict_aux : ocl_class list -> ocl_class list -> ocl_class list
  val get_class_hierarchy_strict : ocl_class list -> ocl_class list
  val get_class_hierarchy_aux : ocl_class list -> ocl_class -> ocl_class list
  val get_class_hierarchya : ocl_class -> ocl_class list
  val ascii_of_literal : string -> int
  val is_letter : int -> bool
  val is_digit : int -> bool
  val isub : abr_string -> abr_string
  val fold_class_gen_aux :
    (ocl_class, unit) inheritance_ext list ->
      ((abr_string -> abr_string) -> abr_string -> (abr_string * ocl_ty) list -> ((ocl_class, unit) inheritance_ext list) tmp_inh -> (ocl_class list) tmp_sub -> ocl_class list -> 'a -> 'a) -> 'a -> ocl_class -> 'a
  val fold_class_gen :
    ((abr_string -> abr_string) -> abr_string -> (abr_string * ocl_ty) list -> ((ocl_class, unit) inheritance_ext list) tmp_inh -> (ocl_class list) tmp_sub -> ocl_class list -> 'a -> 'b list * 'a) -> 'a -> ocl_class -> 'b list * 'a
  val inh : ('a, 'b) inheritance_ext -> 'a
  val of_linh : ('a, 'b) inheritance_ext list -> 'a list
  val map_inh : ('a -> 'b) -> 'a tmp_inh -> 'b tmp_inh
  val of_sub : 'a tmp_sub -> 'a
  val fold_class : ((abr_string -> abr_string) -> abr_string -> (abr_string * ocl_ty) list -> (ocl_class list) tmp_inh -> (abr_string list) tmp_sub -> ocl_class list -> 'a -> 'b * 'a) -> 'a -> ocl_class -> 'b list * 'a
  val thma : abr_string -> semi_thm_attribute
  val equal : abr_string -> abr_string -> bool
  val thm : thm -> all_meta
  val print_ctxt_pre_post : 'a ocl_ctxt_ext -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext
  val floor2_PRINT_ctxt_pre_post : ('a ocl_ctxt_ext -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun
  val print_ctxt_inv_name : abr_string -> abr_string -> abr_string -> abr_string
  val fold_invariant : (ocl_ctxt_term_inv -> 'a -> 'a) -> 'b ocl_ctxt_ext -> 'a -> 'a
  val fold_invarianta : 'a ocl_ctxt_ext -> (abr_string * ocl_ctxt_term) list
  val print_ctxt_thm : 'a ocl_ctxt_ext -> 'b -> all_meta list * 'b
  val floor2_PRINT_ctxt_thm : ('a ocl_ctxt_ext -> 'b -> all_meta list * 'b) embedding_fun
  val print_ctxt_to_ocl_post : 'a compiler_env_config_ext -> ocl_ctxt_term -> ocl_ctxt_term
  val ctxt_param : 'a ocl_ctxt_ext -> abr_string list
  val var_OclForall_set : abr_string
  val definition : definition -> all_meta
  val term_lam : abr_string -> (abr_string -> semi_terma) -> semi_terma
  val append : 'a list -> 'a list -> 'a list
  val print_ctxt_inv : 'a ocl_ctxt_ext -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext
  val floor2_PRINT_ctxt_inv : ('a ocl_ctxt_ext -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun
  val to_String_b_a_s_e : abr_string -> string_b_a_s_e
  val d_ocl_accessor_update : (string_b_a_s_e list * string_b_a_s_e list -> string_b_a_s_e list * string_b_a_s_e list) -> 'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val d_ocl_HO_type_update : (string_b_a_s_e list -> string_b_a_s_e list) -> 'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val var_Sequence_base : abr_string
  val var_Pair_base : abr_string
  val datatype_name : abr_string
  val var_Set_base : abr_string
  val tyCollect : 'a ocl_multiplicity_ext -> ocl_collection list
  val is_sequence : 'a ocl_multiplicity_ext -> bool
  val str_of_ty : ocl_ty -> abr_string
  val print_infra_type_synonym_class_rec_aux0 : ocl_ty -> abr_string * semi_typ
  val print_infra_type_synonym_class_rec_aux : ocl_ty -> abr_string * semi_typ
  val d_ocl_HO_type : 'a compiler_env_config_ext -> string_b_a_s_e list
  val d_input_meta : 'a compiler_env_config_ext -> all_meta_embedding list
  val update_D_ocl_accessor_post : ('a -> 'b) -> 'c * 'a -> 'c * 'b
  val print_infra_type_synonym_class_sequence_name : abr_string -> abr_string
  val print_infra_type_synonym_class_set_name : abr_string -> abr_string
  val tyObjN_role_multip : 'a ocl_ty_class_node_ext -> unit ocl_multiplicity_ext
  val tyObjN_role_ty : 'a ocl_ty_class_node_ext -> abr_string
  val tyObj_to : 'a ocl_ty_class_ext -> unit ocl_ty_class_node_ext
  val tyObj_name : 'a ocl_ty_class_ext -> abr_string
  val pref_ty_enum : abr_string -> abr_string
  val var_ty_prod : abr_string
  val var_ty_list : abr_string
  val pref_ty_syn : abr_string -> abr_string
  val const_oid : abr_string
  val str_hol_of_ty_all : ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_ty -> 'a
  val less_eq_natural : Code_Numeral.natural -> Code_Numeral.natural -> bool
  val tyMult : 'a ocl_multiplicity_ext -> (ocl_multiplicity_single * ocl_multiplicity_single option) list
  val single_multip : 'a ocl_multiplicity_ext -> bool
  val raw : abr_string -> semi_typ
  val print_access_dot_consts_ty : ocl_ty -> semi_typ
  val update_D_ocl_accessor_pre : ('a -> 'b) -> 'a * 'c -> 'b * 'c
  val natural_of_nat : nat -> Code_Numeral.natural
  val var_at_when_ocl_pre : abr_string
  val type_synonyma : abr_string -> semi_typ -> type_synonym
  val consts_value : abr_string
  val consts_raw0 : abr_string -> semi_typ -> abr_string -> Code_Numeral.natural option -> consts
  val is_higher_order : ocl_ty -> bool
  val ctxt_fun_ty_out : 'a ocl_ctxt_pre_post_ext -> ocl_ty option
  val type_synonym : type_synonym -> all_meta
  val ty_arrowa : semi_typ list -> semi_typ
  val map_enum_syn : ocl_enum list -> ocl_class_synonym list -> ocl_ty -> ocl_ty
  val consts : consts -> all_meta
  val membera : string_b_a_s_e list -> abr_string -> bool
  val print_ctxt_const : 'a ocl_ctxt_ext -> 'b compiler_env_config_ext -> ('b compiler_env_config_ext * all_meta list) * all_meta list
  val d_output_auto_bootstrap_update : (bool -> bool) -> 'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val d_output_disable_thy_update : (bool -> bool) -> 'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val d_output_header_thy_update : ((abr_string * (abr_string list * abr_string)) option -> (abr_string * (abr_string list * abr_string)) option) -> 'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val d_output_auto_bootstrap : 'a compiler_env_config_ext -> bool
  val d_input_meta_update : (all_meta_embedding list -> all_meta_embedding list) -> 'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val d_output_disable_thy : 'a compiler_env_config_ext -> bool
  val d_ocl_oid_start : 'a compiler_env_config_ext -> internal_oids
  val co15 : ('a -> 'b) -> ('c -> 'd -> 'e -> 'f -> 'g -> 'h -> 'i -> 'j -> 'k -> 'l -> 'm -> 'n -> 'o -> 'p -> 'q -> 'a) -> 'c -> 'd -> 'e -> 'f -> 'g -> 'h -> 'i -> 'j -> 'k -> 'l -> 'm -> 'n -> 'o -> 'p -> 'q -> 'b
  val makea : bool -> (abr_string * (abr_string list * abr_string)) option ->
                        internal_oids ->
                          Code_Numeral.natural * Code_Numeral.natural ->
                            generation_semantics_ocl ->
                              ocl_class option ->
                                all_meta_embedding list ->
                                  (string_b_a_s_e * (unit ocl_instance_single_ext * internal_oids)) list ->
                                    (string_b_a_s_e * (internal_oids * (abr_string * unit ocl_instance_single_ext) ocl_def_state_core) list) list ->
                                      bool -> bool -> string_b_a_s_e list * string_b_a_s_e list -> string_b_a_s_e list -> string_b_a_s_e list -> generation_lemma_mode option * bool -> unit compiler_env_config_ext
  val compiler_env_config_empty : bool -> (abr_string * (abr_string list * abr_string)) option -> internal_oids -> generation_semantics_ocl -> generation_lemma_mode option * bool -> unit compiler_env_config_ext
  val oidReinitAll : internal_oids -> internal_oids
  val compiler_env_config_reset_no_env : 'a compiler_env_config_ext -> unit compiler_env_config_ext
  val ignore_meta_header : all_meta_embedding -> bool
  val prev_was_stop : all_meta_embedding list -> bool
  val collect_meta_embed : all_meta_embedding list -> bool * all_meta_embedding list -> all_meta_embedding list
  val bootstrap_floor : all_meta list -> unit compiler_env_config_ext -> all_meta list * unit compiler_env_config_ext
  val ctxt_expr_update : (ocl_ctxt_term_pp list -> ocl_ctxt_term_pp list) -> 'a ocl_ctxt_pre_post_ext -> 'a ocl_ctxt_pre_post_ext
  val ctxt_clause_update : (ocl_ctxt_clause list -> ocl_ctxt_clause list) -> 'a ocl_ctxt_ext -> 'a ocl_ctxt_ext
  val map_invariant : (ocl_ctxt_term_inv -> ocl_ctxt_term_inv) -> 'a ocl_ctxt_ext -> 'a ocl_ctxt_ext
  val map_pre_post : (ocl_ctxt_prefix -> unit ocl_ctxt_pre_post_ext -> ocl_ctxt_term -> ocl_ctxt_term) -> 'a ocl_ctxt_ext -> 'a ocl_ctxt_ext
  val t_lambdas : abr_string list -> ocl_ctxt_term -> ocl_ctxt_term
  val print_ctxt : unit ocl_ctxt_ext -> unit compiler_env_config_ext -> all_meta list * unit compiler_env_config_ext
  val floor1_PRINT_ctxt : (unit ocl_ctxt_ext -> unit compiler_env_config_ext -> all_meta list * unit compiler_env_config_ext) embedding_fun
  val thy_ctxt : floor -> (unit ocl_ctxt_ext, unit compiler_env_config_ext) embedding
  val type_synonymb : abr_string -> abr_string list -> (abr_string list -> semi_typ) -> type_synonym
  val pref_generic_enum : abr_string -> abr_string
  val pref_constr_enum : abr_string -> abr_string
  val term_applys : semi_terma -> semi_terma list -> semi_terma
  val term_some : semi_terma -> semi_terma
  val datatypeb : abr_string -> (abr_string * semi_typ list) list -> datatypea
  val datatypea : datatypea -> all_meta
  val print_enum : ocl_enum -> 'a -> all_meta list * 'a
  val pRINT_enum : (ocl_enum -> 'a -> all_meta list * 'a) embedding_fun
  val thy_enum : (ocl_enum, unit compiler_env_config_ext) embedding
  val filtera : ('a -> bool) -> 'a list -> 'a list
  val mk_quote : abr_string -> abr_string
  val wildcard : abr_string
  val k : 'a -> 'b -> 'a
  val print : ((abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> 'a) -> 'a
  val comp_env_input_class_bind : ('a -> 'b -> 'b) list -> 'a -> 'b -> 'b
  val d_input_class_update : (ocl_class option -> ocl_class option) -> 'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val comp_env_input_class_rm : ('a -> 'b -> 'c compiler_env_config_ext * 'd) -> 'a -> 'b -> 'c compiler_env_config_ext * 'd
  val equal_generation_semantics_ocl : generation_semantics_ocl -> generation_semantics_ocl -> bool
  val classRaw_clause_update : (ocl_ctxt_clause list -> ocl_ctxt_clause list) -> 'a ocl_class_raw_ext -> 'a ocl_class_raw_ext
  val classRaw_clause : 'a ocl_class_raw_ext -> ocl_ctxt_clause list
  val classRaw_name : 'a ocl_class_raw_ext -> ocl_ty_obj
  val co4 : ('a -> 'b) -> ('c -> 'd -> 'e -> 'f -> 'a) -> 'c -> 'd -> 'e -> 'f -> 'b
  val make : ocl_ty_obj -> (abr_string * ocl_ty) list -> ocl_ctxt_clause list -> bool -> unit ocl_class_raw_ext
  val nat_to_digit26_aux : nat list -> nat -> nat list
  val mapb : (int -> int) -> abr_string -> abr_string
  val uppercase : abr_string -> abr_string
  val nat_to_digit26 : nat -> abr_string
  val ident_current : 'a * 'b -> 'b
  val ident_fresh : 'a equal -> 'a -> ('a, nat) alist * nat -> nat * (('a, nat) alist * nat)
  val ident_empty : 'c zero -> ('a, 'b) alist * 'c
  val make_tree : nat list -> nat -> nat -> (nat list) tree
  val make_treea : nat list -> nat -> nat -> nat -> (nat list) tree list -> (nat list) tree list
  val fold_tree : ('a -> 'a -> 'b -> 'b) -> 'a tree -> 'b -> 'b
  val mk_tree : nat -> nat -> nat -> (abr_string class_output * abr_string) list * nat
  val find_class_ass : 'a compiler_env_config_ext -> all_meta_embedding list * all_meta_embedding list
  val print_examp_def_st_locale_name : abr_string -> abr_string
  val definitiona : definition -> semi_theory
  val d_input_state : 'a compiler_env_config_ext -> (string_b_a_s_e * (internal_oids * (abr_string * unit ocl_instance_single_ext) ocl_def_state_core) list) list
  val assoca : abr_string -> (string_b_a_s_e * 'a) list -> 'a option
  val get_state :
    (abr_string * (internal_oids * (abr_string * unit ocl_instance_single_ext) ocl_def_state_core) list ->
      abr_string * (internal_oids * (abr_string * unit ocl_instance_single_ext) ocl_def_state_core) list ->
        (abr_string * (internal_oids * (abr_string * unit ocl_instance_single_ext) ocl_def_state_core) list) list -> 'a compiler_env_config_ext -> 'b) ->
      ocl_def_transition -> 'a compiler_env_config_ext -> 'b
  val print_transition_def_state : ocl_def_transition -> 'a compiler_env_config_ext -> semi_theory list * 'a compiler_env_config_ext
  val print_examp_instance_name : 'a -> 'a
  val oidGetInh : internal_oids -> internal_oid
  val lemmas_nosimp : abr_string -> semi_thm_attribute list -> lemmas
  val merge_unique_gen : 'b equal -> ('a -> ('b * 'c) option) -> ('a list) list -> ('b, 'c) alist
  val merge_unique : 'b equal -> ('a -> ('b * 'c) option) -> ('a list) list -> ('b * 'c) list
  val merge_uniquea : 'b equal -> ('a -> 'b) -> ((internal_oids * 'a) list) list -> ((internal_oids * 'a) list) list
  val merge_uniqueb : ((internal_oids * (abr_string * 'a) ocl_def_state_core) list) list -> ((internal_oids * 'a) list) list
  val inst_attr : 'a ocl_instance_single_ext -> (((abr_string * abr_string) option * (abr_string * ocl_data_shallow)) list) ocl_list_attr
  val inst_tya : 'a ocl_instance_single_ext -> abr_string option
  val inst_ty0 : 'a ocl_instance_single_ext -> abr_string option
  val inst_ty : 'a ocl_instance_single_ext -> abr_string
  val inst_namea : 'a ocl_instance_single_ext -> abr_string option
  val inst_name : 'a ocl_instance_single_ext -> abr_string
  val var_oid_uniq : abr_string
  val lemmas : lemmas -> all_meta
  val print_transition_lemmas_oid : ocl_def_transition -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val floor2_PRINT_transition_lemmas_oid : (ocl_def_transition -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_transition_locale_name : abr_string -> abr_string -> abr_string
  val term_oid : abr_string -> internal_oid -> semi_terma
  val map_tail : ('a -> 'b list) -> ((internal_oids * 'a) list) list -> (semi_terma * 'b list) list
  val filter_locale_interp : ((internal_oids * 'a ocl_instance_single_ext) list) list -> semi_terma list * (semi_terma list) list
  val print_transition_def_interp : ocl_def_transition -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val floor2_PRINT_transition_def_interp : (ocl_def_transition -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_examp_def_st_locale_distinct : abr_string
  val print_examp_def_st_locale_aux : ((internal_oids * 'a ocl_instance_single_ext) list) list -> semi_terma list * ((semi_terma * semi_typ) list * (abr_string * semi_terma) option) list
  val term_list : semi_terma list -> semi_terma
  val print_examp_def_st_locale_make : abr_string -> ((semi_terma * semi_typ) list * (abr_string * semi_terma) option) list -> ((internal_oids * 'a ocl_instance_single_ext) list) list -> unit semi_locale_ext
  val print_transition_locale_aux : (internal_oids * (abr_string * 'a ocl_instance_single_ext) ocl_def_state_core) list -> semi_terma list
  val print_transition_locale : ocl_def_transition -> 'a compiler_env_config_ext -> unit semi_locale_ext * 'a compiler_env_config_ext
  val interpretationa : interpretation -> semi_theory
  val rule : semi_thm_attribute -> semi_method
  val by : semi_method list -> semi_command_final
  val print_transition_interp : ocl_def_transition -> 'a compiler_env_config_ext -> semi_theory list * 'a compiler_env_config_ext
  val metis : semi_thm_attribute list -> semi_method
  val print_examp_def_st_locale_metis : semi_method
  val method_simp_add_del : semi_thm list -> semi_thm list -> semi_method_simp
  val meth_gen_simp_add2 : semi_thm_attribute list -> abr_string list -> semi_method_simp
  val simp_add2 : semi_thm_attribute list -> abr_string list -> semi_method
  val simp_add : abr_string list -> semi_method
  val term_pair : semi_terma -> semi_terma -> semi_terma
  val optiona : semi_method list -> semi_method
  val const_oid_of : abr_string -> abr_string
  val applya : semi_method list -> semi_command_proof
  val lemmaa : lemma -> semi_theory
  val print_transition_where : ocl_def_transition -> 'a compiler_env_config_ext -> semi_theory list * 'a compiler_env_config_ext
  val auto_simp_add2 : semi_thm_attribute list -> abr_string list -> semi_method
  val auto_simp_add : abr_string list -> semi_method
  val have0 : abr_string -> bool -> semi_terma -> semi_command_final -> semi_command_proof
  val datatype_in : abr_string
  val print_transition_wff : ocl_def_transition -> 'a compiler_env_config_ext -> semi_theory list * 'a compiler_env_config_ext
  val print_examp_instance_app_constr2_notmpa : 'a ocl_list_attr -> semi_terma -> semi_terma
  val to_bold_number : abr_string -> abr_string
  val var_OclInteger : abr_string
  val var_OclString : abr_string
  val var_OclReal : abr_string
  val is_emptyb : string_b_a_s_e -> bool
  val is_empty : abr_string -> bool
  val base255 : abr_string -> abr_string
  val text2_of_str : abr_string -> abr_string
  val text_of_str : abr_string -> abr_string
  val all : (int -> bool) -> abr_string -> bool
  val print_examp_oclbase_gen : ocl_def_base -> semi_terma * definition
  val filter_ocl_exn : abr_string -> 'a print_examp_instance_draw_list_attra -> 'a print_examp_instance_draw_list_attra
  val print_examp_instance_draw_list_attr_aux_base : ocl_ty * ocl_data_shallow -> semi_terma print_examp_instance_draw_list_attra
  val list_bind_e_r_r : ('a -> 'b print_examp_instance_draw_list_attra) -> ('b list -> 'c) -> 'a list -> 'c print_examp_instance_draw_list_attra
  val print_examp_instance_draw_list_attr_aux : (ocl_ty * ocl_data_shallow -> semi_terma print_examp_instance_draw_list_attra) -> ocl_ty * ocl_data_shallow -> semi_terma print_examp_instance_draw_list_attra
  val bind_e_r_r : 'a print_examp_instance_draw_list_attra -> ('a -> 'b print_examp_instance_draw_list_attra) -> 'b print_examp_instance_draw_list_attra
  val map_e_r_r : ('a -> 'b) -> 'a print_examp_instance_draw_list_attra -> 'b print_examp_instance_draw_list_attra
  val has_invalid : print_examp_instance_draw_list_attr_err -> bool
  val has_err_ty : print_examp_instance_draw_list_attr_err -> bool
  val print_examp_instance_draw_list_attr :
    (unit ocl_ty_class_ext -> semi_terma print_examp_instance_draw_list_attra) * (ocl_ty * ocl_data_shallow -> semi_terma print_examp_instance_draw_list_attra) ->
      (unit ocl_ty_class_ext option * (ocl_ty * ((abr_string * abr_string) option * ocl_data_shallow)) option) list -> (semi_terma list) print_examp_instance_draw_list_attra
  val datatype_constr_name : abr_string
  val print_examp_instance_app_constr_notmp :
    (unit ocl_ty_class_ext -> semi_terma print_examp_instance_draw_list_attra) * (ocl_ty * ocl_data_shallow -> semi_terma print_examp_instance_draw_list_attra) ->
      (abr_string -> abr_string) -> semi_terma -> (unit ocl_ty_class_ext option * (ocl_ty * ((abr_string * abr_string) option * ocl_data_shallow)) option) list -> semi_terma print_examp_instance_draw_list_attra
  val datatype_ext_constr_name : abr_string
  val print_examp_instance_app_constr2_notmp :
    ((opt_attr_type * (unit ocl_ty_class_ext option * (ocl_ty * ((abr_string * abr_string) option * ocl_data_shallow)) option) list) list) ocl_list_attr ->
      (abr_string -> abr_string) ->
        internal_oids ->
          ((abr_string -> abr_string) -> internal_oids -> (unit ocl_ty_class_ext -> semi_terma print_examp_instance_draw_list_attra) * (ocl_ty * ocl_data_shallow -> semi_terma print_examp_instance_draw_list_attra)) ->
            semi_terma print_examp_instance_draw_list_attra
  val tyObjN_ass_switch : 'a ocl_ty_class_node_ext -> Code_Numeral.natural
  val tyObj_ass_arity : 'a ocl_ty_class_ext -> Code_Numeral.natural
  val print_access_oid_uniq_namea : Code_Numeral.natural -> (abr_string -> abr_string) -> abr_string -> abr_string
  val print_access_oid_uniq_name : Code_Numeral.natural -> (abr_string -> abr_string) -> abr_string -> abr_string
  val var_switch : abr_string
  val print_access_choose_name : Code_Numeral.natural -> Code_Numeral.natural -> Code_Numeral.natural -> abr_string
  val tyObj_from : 'a ocl_ty_class_ext -> unit ocl_ty_class_node_ext
  val fill_blank : ('a -> (('b -> Code_Numeral.natural -> ('b * ('c * 'd) option) list -> ('b * ('c * 'd) option) list) -> 'e list -> 'f list) option) -> ('a * (('c * ('g * opt_ident)) * 'd) list) list -> ('a * 'f list) list
  val split_inh_own :
    (abr_string -> ('a -> ('b * (opt_attr_type * opt_ident)) option) * (opt_attr_type -> (('c -> Code_Numeral.natural -> ('c * ('b * ('d * 'e)) option) list -> ('c * ('b * ('d * 'e)) option) list) -> 'f list -> 'g list) option)) ->
      abr_string -> (('d * ('a * 'e)) list) ocl_list_attr -> ((opt_attr_type * 'g list) list) ocl_list_attr
  val tyRole : 'a ocl_multiplicity_ext -> abr_string option
  val tyObjN_role_name : 'a ocl_ty_class_node_ext -> abr_string option
  val print_examp_instance_app_constr2_notmp_norec :
    (abr_string ->
      (abr_string -> ('a * (opt_attr_type * opt_ident)) option) *
        (opt_attr_type ->
          (('b -> Code_Numeral.natural -> ('b * ('a * ((abr_string * abr_string) option * ocl_data_shallow)) option) list -> ('b * ('a * ((abr_string * abr_string) option * ocl_data_shallow)) option) list) ->
            'c list -> (unit ocl_ty_class_ext option * (ocl_ty * ((abr_string * abr_string) option * ocl_data_shallow)) option) list) option)) *
      ((internal_oid -> internal_oids option) * (abr_string -> internal_oids option)) ->
      semi_terma -> 'd ocl_instance_single_ext -> (abr_string -> abr_string) -> internal_oids -> semi_terma print_examp_instance_draw_list_attra * (semi_terma -> semi_terma)
  val d_input_instance_update :
    ((string_b_a_s_e * (unit ocl_instance_single_ext * internal_oids)) list -> (string_b_a_s_e * (unit ocl_instance_single_ext * internal_oids)) list) -> 'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val d_ocl_oid_start_update : (internal_oids -> internal_oids) -> 'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val d_input_instance : 'a compiler_env_config_ext -> (string_b_a_s_e * (unit ocl_instance_single_ext * internal_oids)) list
  val map_data_shallow_self : (internal_oid -> ocl_data_shallow) -> ocl_data_shallow -> ocl_data_shallow
  val inst_attr_update :
    ((((abr_string * abr_string) option * (abr_string * ocl_data_shallow)) list) ocl_list_attr -> (((abr_string * abr_string) option * (abr_string * ocl_data_shallow)) list) ocl_list_attr) ->
      'a ocl_instance_single_ext -> 'a ocl_instance_single_ext
  val map_list_attr : ('a -> 'b) -> 'a ocl_list_attr -> 'b ocl_list_attr
  val map_instance_single : ((abr_string * abr_string) option * (abr_string * ocl_data_shallow) -> (abr_string * abr_string) option * (abr_string * ocl_data_shallow)) -> 'a ocl_instance_single_ext -> 'a ocl_instance_single_ext
  val map_inst_single_self : (internal_oid -> ocl_data_shallow) -> 'a ocl_instance_single_ext -> 'a ocl_instance_single_ext
  val inst_attr_with : 'a ocl_instance_single_ext -> abr_string option
  val oidSucInh : internal_oids -> internal_oids
  val mk_instance_single_cpt0 : (abr_string -> internal_oids option) -> 'a ocl_instance_single_ext list -> 'b compiler_env_config_ext -> ('a ocl_instance_single_ext * internal_oids) list * internal_oids
  val map_entry : 'a equal -> 'a -> ('b -> 'b) -> ('a * 'b) list -> ('a * 'b) list
  val map_entrya : 'a equal -> 'a -> ('b -> 'b) -> ('a, 'b) alist -> ('a, 'b) alist
  val modify_def : 'b equal -> 'a -> 'b -> ('a -> 'a) -> ('b, 'a) alist -> ('b, 'a) alist
  val modify_defa : 'a -> abr_string -> ('a -> 'a) -> ((int list), 'a) alist -> ((int list), 'a) alist
  val of_inh : 'a tmp_inh -> 'a
  val map_class_inh : ((ocl_class, 'a) inheritance_ext list) tmp_inh -> ((abr_string * ocl_ty) list) list
  val lookupb : ((int list), 'a) alist -> abr_string -> 'a option
  val inserta : abr_string -> 'a -> ((int list), 'a) alist -> ((int list), 'a) alist
  val rbt_of_class :
    'b one * 'b plus * 'b zero ->
      'a compiler_env_config_ext -> abr_string -> bool * ((abr_string -> (ocl_ty * (opt_attr_type * opt_ident)) option) * (opt_attr_type -> ((unit ocl_ty_class_ext option -> 'b -> 'c -> 'c) -> 'c -> 'c) option))
  val init_map_class :
    'c one * 'c plus * 'c zero ->
      'a compiler_env_config_ext ->
        'b ocl_instance_single_ext list ->
          (abr_string -> bool * ((abr_string -> (ocl_ty * (opt_attr_type * opt_ident)) option) * (opt_attr_type -> ((unit ocl_ty_class_ext option -> 'c -> 'd -> 'd) -> 'd -> 'd) option))) *
            ((internal_oid -> internal_oids option) * (abr_string -> internal_oids option))
  val var_inst_assoc : abr_string
  val print_examp_instance : ocl_instance -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val print_examp_increase_oid : unit ocl_instance_single_ext list -> 'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val inst_name_update : (abr_string option -> abr_string option) -> 'a ocl_instance_single_ext -> 'a ocl_instance_single_ext
  val print_examp_def_st0 : abr_string -> abr_string ocl_def_state_core list -> unit ocl_instance_single_ext list * abr_string ocl_def_state_core list
  val bootstrap_floora :
    ('a -> unit compiler_env_config_ext -> all_meta list * (unit compiler_env_config_ext -> 'b)) -> 'a -> unit compiler_env_config_ext -> (all_meta list * unit compiler_env_config_ext) * (unit compiler_env_config_ext -> 'b)
  val print_transition_gen : ocl_def_transition -> unit compiler_env_config_ext -> (all_meta list * unit compiler_env_config_ext) * (unit compiler_env_config_ext -> unit compiler_env_config_ext)
  val print_transition : ocl_def_transition -> unit compiler_env_config_ext -> all_meta list * unit compiler_env_config_ext
  val floor1_PRINT_transition : (ocl_def_transition -> unit compiler_env_config_ext -> all_meta list * unit compiler_env_config_ext) embedding_fun
  val thy_def_transition : floor -> (ocl_def_transition, unit compiler_env_config_ext) embedding
  val const_oclany : abr_string
  val classRaw_name_update : (ocl_ty_obj -> ocl_ty_obj) -> 'a ocl_class_raw_ext -> 'a ocl_class_raw_ext
  val classRaw_own_update : ((abr_string * ocl_ty) list -> (abr_string * ocl_ty) list) -> 'a ocl_class_raw_ext -> 'a ocl_class_raw_ext
  val classRaw_own : 'a ocl_class_raw_ext -> (abr_string * ocl_ty) list
  val cl_name_to_string : 'a ocl_class_raw_ext -> abr_string
  val class_unflat_aux : ((int list), ((abr_string * ocl_ty) list)) alist -> ((int list), (abr_string list)) alist -> ((int list), unit) alist -> abr_string -> ocl_class option
  val oclAss_relationa : 'a ocl_association_ext -> ocl_association_relation
  val oclAss_relation : 'a ocl_association_ext -> (ocl_ty_obj * unit ocl_multiplicity_ext) list
  val remove_binding : ocl_ty -> ocl_ty
  val map_entryb : 'a equal -> 'a -> ('b -> 'b) -> ('a, 'b) alist -> ('a, 'b) alist
  val map_entryc : abr_string -> ('a -> 'a) -> ((int list), 'a) alist -> ((int list), 'a) alist
  val entriesa : ((int list), 'a) alist -> (abr_string * 'a) list
  val oclTy_class : unit ocl_ty_class_ext -> ocl_ty
  val normalize0 : 'b equal -> ('a -> 'b) -> 'a list -> 'a list
  val fold_max_aux : ('a -> 'a list -> 'b -> 'b) -> 'a list -> 'a list -> 'b -> 'b
  val fold_max : (Code_Numeral.natural * 'a -> (Code_Numeral.natural * 'a) list -> 'b -> 'b) -> 'a list -> 'b -> 'b
  val class_unflat : unit ocl_class_raw_ext list * 'a ocl_association_ext list -> ocl_class option
  val class_unflata : unit ocl_class_raw_ext list * 'a ocl_association_ext list -> ocl_class
  val equal_ocl_association_type : ocl_association_type -> ocl_association_type -> bool
  val tyRole_update : (abr_string option -> abr_string option) -> 'a ocl_multiplicity_ext -> 'a ocl_multiplicity_ext
  val oclAss_type : 'a ocl_association_ext -> ocl_association_type
  val map_find_aux : 'a list -> ('a -> 'a option) -> 'a list -> 'a list
  val map_find : ('a -> 'a option) -> 'a list -> 'a list
  val arrange_ass : bool -> bool -> all_meta_embedding list -> ocl_enum list -> unit ocl_class_raw_ext list * unit ocl_association_ext list
  val print_examp_oclbase : ocl_def_base_l -> 'a -> all_meta list * 'a
  val pRINT_examp_oclbase : (ocl_def_base_l -> 'a -> all_meta list * 'a) embedding_fun
  val thy_def_base_l : (ocl_def_base_l, unit compiler_env_config_ext) embedding
  val thy_flush_all : ('a, 'b) embedding
  val d_output_header_force_update : (bool -> bool) -> 'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val rev_map : ('a -> 'b) -> 'a list -> 'b list
  val print_examp_def_st_defassoc_typecheck_gen : abr_string ocl_def_state_core list -> 'a compiler_env_config_ext -> ml list
  val mla : ml -> semi_theory
  val print_examp_def_st_defassoc_typecheck : ocl_def_state -> 'a compiler_env_config_ext -> semi_theory list * 'a compiler_env_config_ext
  val fold_list_attr : abr_string option -> (abr_string option -> 'a -> 'b -> 'b) -> 'a ocl_list_attr -> 'b -> 'b
  val fold_instance_singlea : (abr_string option -> ((abr_string * abr_string) option * (abr_string * ocl_data_shallow)) list -> 'a -> 'a) -> 'b ocl_instance_single_ext -> 'a -> 'a
  val fold_data_shallow : (abr_string -> 'a) -> (internal_oid -> 'a) -> ('a -> 'b -> 'b) -> ocl_data_shallow -> 'b -> 'b
  val fold_instance_single_name : 'a ocl_instance_single_ext -> semi_terma list -> semi_terma list
  val term_paira : semi_terma list -> semi_terma
  val print_examp_def_st_typecheck_var : ocl_def_state -> 'a -> all_meta list * 'a
  val floor1_PRINT_examp_def_st_typecheck_var : (ocl_def_state -> 'a -> all_meta list * 'a) embedding_fun
  val to_String : string_b_a_s_e -> abr_string
  val print_examp_def_st_dom_name : abr_string -> abr_string
  val lemmas_simp : abr_string -> semi_thm_attribute list -> lemmas
  val lemmasa : lemmas -> semi_theory
  val print_examp_def_st_dom_lemmas : 'a -> 'b compiler_env_config_ext -> semi_theory list * 'b compiler_env_config_ext
  val print_examp_def_st_locale_sort : 'a compiler_env_config_ext -> abr_string ocl_def_state_core list -> ((internal_oids * unit ocl_instance_single_ext) list) list
  val print_examp_def_st_def_interp : ocl_def_state -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val floor2_PRINT_examp_def_st_def_interp : (ocl_def_state -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_examp_def_st_mapsto_gen :
    ('a * (abr_string * 'b ocl_instance_single_ext) ocl_def_state_core -> 'b ocl_instance_single_ext -> semi_terma option -> 'c) -> ('a * (abr_string * 'b ocl_instance_single_ext) ocl_def_state_core) list -> 'c list
  val print_examp_def_st_perm_name : abr_string -> abr_string
  val meth_gen_simp_onlya : semi_thm_attribute list -> semi_method_simp
  val simp_all_only : semi_thm_attribute list -> semi_method
  val add_hierarchyb : ('a -> 'b -> 'c -> 'd -> 'e -> 'f) -> 'a -> 'b -> 'c -> 'd tmp_inh -> 'e tmp_sub -> 'f
  val map_class_gen : ((abr_string -> abr_string) -> abr_string -> (abr_string * ocl_ty) list -> ((ocl_class, unit) inheritance_ext list) tmp_inh -> (ocl_class list) tmp_sub -> ocl_class list -> 'a list) -> ocl_class -> 'a list
  val map_class_gen_hb : ((abr_string -> abr_string) -> abr_string -> (abr_string * ocl_ty) list -> (ocl_class, unit) inheritance_ext list -> ocl_class list -> ocl_class list -> 'a list) -> ocl_class -> 'a list
  val map_class_gen_h_inh : ((abr_string -> abr_string) -> abr_string -> (abr_string -> position) -> 'a list) -> ocl_class -> 'a list
  val simp_all_add : abr_string list -> semi_method
  val meth_gen_simp_add_del : abr_string list -> abr_string list -> semi_method_simp
  val simp_add_del : abr_string list -> abr_string list -> semi_method
  val simp_onlya : semi_thm_attribute list -> semi_method
  val symmetric : semi_thm_attribute -> semi_thm_attribute
  val meth_gen_simp_only : semi_thm_attribute list -> semi_method_simp
  val simp_only : semi_thm_attribute list -> semi_method
  val const_oclastype : abr_string
  val meth_gen_simp : semi_method_simp
  val simp_all : semi_method
  val unfolding : semi_thm_attribute list -> semi_command_proof
  val gen_pre_post0 :
    (abr_string -> abr_string) ->
      (abr_string * (bool * semi_terma)) list ->
        ((semi_terma list -> semi_terma) -> (semi_terma -> semi_terma) -> abr_string -> semi_terma) ->
          (abr_string -> (abr_string * (bool * semi_terma)) list -> semi_terma -> abr_string -> abr_string -> abr_string -> lemma) -> semi_method list -> lemma list
  val term_And : abr_string -> (abr_string -> semi_terma) -> semi_terma
  val method_subst_l : abr_string list -> semi_thm_attribute -> semi_method
  val subst_l : abr_string list -> semi_thm_attribute -> semi_method
  val subst : semi_thm_attribute -> semi_method
  val blast : Code_Numeral.natural option -> semi_method
  val term_oclset : semi_terma list -> semi_terma
  val thms : abr_string -> semi_thm_attribute
  val simp : semi_method
  val print_examp_def_st_allinst : 'a -> 'b compiler_env_config_ext -> semi_theory list * 'b compiler_env_config_ext
  val print_examp_def_st_locale : ocl_def_state -> 'a compiler_env_config_ext -> unit semi_locale_ext * 'a compiler_env_config_ext
  val print_examp_def_st_mapsto : (internal_oids * (abr_string * 'a ocl_instance_single_ext) ocl_def_state_core) list -> (semi_terma list) option
  val var_assocs : abr_string
  val print_examp_def_st_perm : 'a -> 'b compiler_env_config_ext -> semi_theory list * 'b compiler_env_config_ext
  val term_set : semi_terma list -> semi_terma
  val print_examp_def_st_dom : 'a -> 'b compiler_env_config_ext -> semi_theory list * 'b compiler_env_config_ext
  val d_input_state_update :
    ((string_b_a_s_e * (internal_oids * (abr_string * unit ocl_instance_single_ext) ocl_def_state_core) list) list -> (string_b_a_s_e * (internal_oids * (abr_string * unit ocl_instance_single_ext) ocl_def_state_core) list) list) ->
      'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val ocl_instance_single_empty : unit ocl_instance_single_ext
  val fold_instance_single : (abr_string -> ((abr_string * abr_string) option * (abr_string * ocl_data_shallow)) list -> 'a -> 'a) -> 'b ocl_instance_single_ext -> 'a -> 'a
  val print_examp_def_st_assoc_build_rbt_gen :
    (abr_string -> (((int list), (((internal_oid list) list) list * unit ocl_ty_class_ext)) alist -> ((int list), (((internal_oid list) list) list * unit ocl_ty_class_ext)) alist) -> ('a, 'b) alist -> ('a, 'b) alist) ->
      (abr_string -> (abr_string -> (ocl_ty * ('c * 'd)) option) * 'e) -> (internal_oid -> internal_oids option) -> (abr_string -> internal_oids option) -> ('f ocl_instance_single_ext * internal_oids) list -> ('a, 'b) alist
  val print_examp_def_st_assoc_build_rbt :
    (abr_string -> (abr_string -> (ocl_ty * ('a * 'b)) option) * 'c) ->
      (internal_oid -> internal_oids option) ->
        (abr_string -> internal_oids option) -> ('d ocl_instance_single_ext * internal_oids) list -> ((int list), ((int list), (((internal_oid list) list) list * unit ocl_ty_class_ext)) alist) alist
  val var_map_of_list : abr_string
  val term_lista : ('a -> semi_terma) -> 'a list -> semi_terma
  val foldb : (abr_string -> 'a -> 'b -> 'b) -> ((int list), 'a) alist -> 'b -> 'b
  val print_examp_def_st_assoc :
    (abr_string -> (abr_string -> (ocl_ty * ('a * 'b)) option) * 'c) -> (internal_oid -> internal_oids option) -> (abr_string -> internal_oids option) -> ('d ocl_instance_single_ext * internal_oids) list -> semi_terma
  val init_map_class2 :
    'c one * 'c plus * 'c zero ->
      'a compiler_env_config_ext ->
        'b ocl_instance_single_ext list ->
          (abr_string -> bool * ((abr_string -> (ocl_ty * (opt_attr_type * opt_ident)) option) * (opt_attr_type -> ((unit ocl_ty_class_ext option -> 'c -> 'd -> 'd) -> 'd -> 'd) option))) *
            ((internal_oid -> internal_oids option) * (abr_string -> internal_oids option))
  val unique : 'b equal -> ('a -> 'b) -> ('a * 'c) list -> ('a * 'c) list
  val print_examp_def_st2 : ocl_def_state -> 'a compiler_env_config_ext -> semi_theory list * 'a compiler_env_config_ext
  val print_examp_def_st1_gen : ocl_def_state -> unit compiler_env_config_ext -> (all_meta list * unit compiler_env_config_ext) * (unit compiler_env_config_ext -> unit compiler_env_config_ext)
  val print_examp_def_st1 : ocl_def_state -> unit compiler_env_config_ext -> all_meta list * unit compiler_env_config_ext
  val floor1_PRINT_examp_def_st1 : (ocl_def_state -> unit compiler_env_config_ext -> all_meta list * unit compiler_env_config_ext) embedding_fun
  val thy_def_state : floor -> (ocl_def_state, unit compiler_env_config_ext) embedding
  val comp_env_save : all_meta_embedding -> ('a -> 'b -> 'c compiler_env_config_ext * 'd) -> 'a -> 'b -> 'c compiler_env_config_ext * 'd
  val print_examp_instance_defassoc_typecheck_var : ocl_instance -> 'a -> all_meta list * 'a
  val pRINT_examp_instance_defassoc_typecheck_var : (ocl_instance -> 'a -> all_meta list * 'a) embedding_fun
  val fold_e_r_r : (print_examp_instance_draw_list_attr_err -> 'a -> 'a) -> print_examp_instance_draw_list_attr_err -> 'a -> 'a
  val str_of_def_base : ocl_def_base -> abr_string
  val str_of_data_shallow : ocl_data_shallow -> abr_string
  val print_examp_def_st_assoc_build_rbt_gen_typecheck :
    ('a ocl_instance_single_ext -> 'b -> 'c print_examp_instance_draw_list_attra) ->
      (abr_string -> bool) ->
        (abr_string -> abr_string -> 'd option) -> (internal_oid -> 'e option) -> (abr_string -> 'e option) -> ocl_enum list -> ('a ocl_instance_single_ext * 'b) list -> (reporting * abr_string) list -> (reporting * abr_string) list
  val print_examp_def_st_assoc_build_rbt2 :
    (abr_string -> (abr_string -> (ocl_ty * ('a * 'b)) option) * 'c) ->
      (internal_oid -> internal_oids option) -> (abr_string -> internal_oids option) -> ('d ocl_instance_single_ext * internal_oids) list -> ((int list), (((internal_oid list) list) list * unit ocl_ty_class_ext)) alist
  val less_natural : Code_Numeral.natural -> Code_Numeral.natural -> bool
  val mk_instance_single_cpt : (abr_string -> internal_oids option) -> 'a ocl_instance_single_ext list -> 'b compiler_env_config_ext -> ('a ocl_instance_single_ext * internal_oids) list
  val tyObj_ass_id : 'a ocl_ty_class_ext -> Code_Numeral.natural
  val check_single : abr_string option * (internal_oid * (internal_oid * abr_string) list) -> (ocl_multiplicity_single * ocl_multiplicity_single option) list -> internal_oid list -> (reporting * abr_string) list
  val choose_1 : 'a * 'b -> 'b
  val choose_0 : 'a * 'b -> 'a
  val deref_assocs_list : 'b equal -> ('a -> 'b list * 'c list) -> 'b -> 'a list -> 'c list
  val check_single_ty :
    ('a -> (abr_string -> (ocl_ty * ('b * 'c)) option) * 'd) ->
      ((int list), ('e * unit ocl_ty_class_ext)) alist ->
        (Code_Numeral.natural -> (((internal_oid list) list) list) option) ->
          (internal_oid * abr_string) list -> internal_oid -> 'a * unit ocl_multiplicity_ext -> 'a * unit ocl_multiplicity_ext -> (reporting * abr_string) list -> (reporting * abr_string) list
  val map_of_list : 'a equal -> ('a * 'b list) list -> 'a -> ('b list) option
  val nb_class : ocl_class -> nat
  val find_inh : abr_string -> ocl_class -> abr_string list
  val print_examp_instance_defassoc_typecheck_gen : (unit ocl_instance_single_ext option) list -> 'a compiler_env_config_ext -> ml list
  val print_examp_instance_defassoc_typecheck : ocl_instance -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_examp_instance_defassoc_typecheck : (ocl_instance -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val var_deref_assocs_list : abr_string
  val term_case : semi_terma -> (semi_terma * semi_terma) list -> semi_terma
  val ty_times : semi_typ -> semi_typ -> semi_typ
  val print_examp_instance_defassoc_gen :
    semi_terma ->
      ('a ocl_instance_single_ext * internal_oids) list ->
        'b compiler_env_config_ext -> (abr_string -> 'c * ((abr_string -> (ocl_ty * ('d * 'e)) option) * 'f)) * ((internal_oid -> internal_oids option) * (abr_string -> internal_oids option)) -> definition list
  val print_examp_instance_oid : (definition -> 'a) -> ('b ocl_instance_single_ext * internal_oids) list -> 'c compiler_env_config_ext -> 'a list
  val print_examp_instance_defassoc : ocl_instance -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_examp_instance_defassoc : (ocl_instance -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val pRINT_examp_instance : (ocl_instance -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val thy_instance : (ocl_instance, unit compiler_env_config_ext) embedding
  val d_hsk_constr_update : (string_b_a_s_e list -> string_b_a_s_e list) -> 'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val hsk_name0 : (abr_string -> abr_string -> abr_string) -> (abr_string * abr_string option) list -> name -> abr_string
  val hsk_name : (abr_string * abr_string option) list -> name -> abr_string
  val hsk_namea : (abr_string * abr_string option) list -> name -> abr_string
  val hsk_typespec : (abr_string * abr_string option) list -> typeSpec -> abr_string * abr_string list
  val hsk_nameb : (abr_string * abr_string option) list -> name -> abr_string
  val term_stringa : abr_string -> semi_terma
  val term_stringb : semi_terma -> abr_string -> semi_terma
  val hsk_type : (abr_string * abr_string option) list -> typea -> semi_typ
  val lex_bool_false : 'a lexical_ext -> abr_string
  val lex_list_cons : 'a lexical_ext -> abr_string
  val lex_string : 'a lexical_ext -> abr_string -> semi_terma
  val hsk_literal : (abr_string -> semi_terma) -> literal -> semi_terma
  val hsk_term : 'a lexical_ext -> (abr_string * abr_string option) list -> term -> semi_terma
  val hsk_term_app : 'a lexical_ext -> (abr_string * abr_string option) list -> semi_terma list -> term -> semi_terma
  val gen_zero : abr_string -> abr_string
  val pair0 : semi_term_0 list -> semi_term_0
  val app_pair : semi_term_0 -> semi_term_0 list -> semi_term_0
  val rewrite : semi_term_0 -> abr_string -> semi_term_0 -> semi_term_0
  val hol_to_sml : semi_terma -> semi_term_0
  val hsk_stmt : semi_datatype_version -> (abr_string * abr_string option) list -> gen_meta -> stmt list -> all_meta list * abr_string list
  val print_haskell : isaUnit -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_haskell : (isaUnit -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val thy_haskell : (isaUnit, unit compiler_env_config_ext) embedding
  val map_class : ((abr_string -> abr_string) -> abr_string -> (abr_string * ocl_ty) list -> ((ocl_class, unit) inheritance_ext list) tmp_inh -> (abr_string list) tmp_sub -> ocl_class list -> 'a) -> ocl_class -> 'a list
  val print_infra_type_synonym_class_higher : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_infra_type_synonym_class_higher : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_instantia_def_strictrefeq_name : (abr_string list -> 'a) -> abr_string -> 'a
  val activate_simp_optimization : bool
  val print_instantia_lemmas_strictrefeq : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_instantia_lemmas_strictrefeq : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val oclTy_class_pre : abr_string -> ocl_ty
  val print_infra_type_synonym_class_rec : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_infra_type_synonym_class_rec : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val term_function : (semi_terma * semi_terma) list -> semi_terma
  val instantiation : instantiation -> all_meta
  val print_infra_instantiation_universe : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_infra_instantiation_universe : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val const_oclistypeof : abr_string
  val const_ocliskindof : abr_string
  val print_iskindof_up_istypeof_unfold_name : abr_string -> abr_string -> abr_string
  val print_iskindof_defined_namea : (abr_string -> abr_string) -> abr_string -> abr_string
  val print_istypeof_defined_namea : (abr_string -> abr_string) -> abr_string -> abr_string
  val erule : semi_thm_attribute -> semi_method
  val oF_l : semi_thm_attribute -> semi_thm_attribute list -> semi_thm_attribute
  val ofa : semi_thm_attribute -> semi_thm_attribute -> semi_thm_attribute
  val print_iskindof_up_istypeof_erule : abr_string -> ocl_class list -> abr_string -> abr_string -> semi_method
  val equal_position : position -> position -> bool
  val term_binopb : abr_string -> semi_terma list -> semi_terma
  val m_class_default : 'a -> 'b -> 'c -> 'd -> 'd
  val dot_oclistypeof : abr_string
  val dot_istypeof : abr_string -> abr_string
  val dot_ocliskindof : abr_string
  val dot_iskindof : abr_string -> abr_string
  val drule : semi_thm_attribute -> semi_method
  val using : semi_thm_attribute list -> semi_command_proof
  val inh_sib : ('a, 'b) inheritance_ext -> ('a * 'a list) list
  val of_linh_sib : ('a, 'b) inheritance_ext list -> 'a list
  val inh_sib_unflat : ('a, 'b) inheritance_ext -> 'a list
  val map_linh : ('a -> 'b) -> ('a, 'c) inheritance_ext -> ('b, unit) inheritance_ext
  val m_class_gen2 :
    ((abr_string * ocl_ty) list -> (abr_string * ocl_ty) list) ->
      (abr_string -> (ocl_class, unit) inheritance_ext list -> ocl_class list -> 'a list -> 'b list) ->
        ((ocl_class, unit) inheritance_ext list -> ocl_class list -> ocl_class list -> position -> (abr_string -> abr_string) * (abr_string * (abr_string * ocl_ty) list) -> ocl_class -> 'a list) -> ocl_class -> 'b list
  val start_mapc :
    ('a -> 'b) ->
      (generation_semantics_ocl ->
        (('c * ocl_ty) list -> ('c * ocl_ty) list) ->
          (('c * ocl_ty) list * (('c * ocl_ty) list) list -> ('c * ocl_ty) list * (('c * ocl_ty) list) list) -> (('c * ocl_ty) list * ('c * ocl_ty) list -> ('c * ocl_ty) list * ('c * ocl_ty) list) -> 'a list) ->
        'd compiler_env_config_ext -> 'b list * 'd compiler_env_config_ext
  val start_mapb :
    ('a -> 'b) ->
      ((('c * ocl_ty) list -> ('c * ocl_ty) list) ->
        (('c * ocl_ty) list * (('c * ocl_ty) list) list -> ('c * ocl_ty) list * (('c * ocl_ty) list) list) -> (('c * ocl_ty) list * ('c * ocl_ty) list -> ('c * ocl_ty) list * ('c * ocl_ty) list) -> 'a list) ->
        'd compiler_env_config_ext -> 'b list * 'd compiler_env_config_ext
  val start_m_gen :
    ('a -> 'b) ->
      (abr_string -> (ocl_class, unit) inheritance_ext list -> ocl_class list -> 'c list -> 'a list) ->
        ((ocl_class, unit) inheritance_ext list -> ocl_class list -> ocl_class list -> position -> (abr_string -> abr_string) * (abr_string * (abr_string * ocl_ty) list) -> ocl_class -> 'c list) ->
          ocl_class -> 'd compiler_env_config_ext -> 'b list * 'd compiler_env_config_ext
  val done : semi_command_final
  val lemma : lemma -> all_meta
  val print_iskindof_up_istypeof_unfold : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_iskindof_up_istypeof_unfold : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_instantia_def_strictrefeq : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_instantia_def_strictrefeq : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val get_class_hierarchy : ocl_class -> (abr_string * (abr_string * ocl_ty) list) list
  val add_hierarchya :
    ('a -> 'b -> ((abr_string * (abr_string * ocl_ty) list) list) tmp_univ -> 'c -> (((abr_string * ocl_ty) list) list) tmp_inh -> 'd -> 'e) ->
      ocl_class -> 'a -> 'b -> 'c -> ((ocl_class, 'f) inheritance_ext list) tmp_inh -> 'd -> 'g -> 'e
  val map_class_gen_ha :
    ((abr_string -> abr_string) -> abr_string -> ((abr_string * (abr_string * ocl_ty) list) list) tmp_univ -> (abr_string * ocl_ty) list -> (((abr_string * ocl_ty) list) list) tmp_inh -> (abr_string list) tmp_sub -> 'a list) ->
      ocl_class -> 'a list
  val mk_constr_name : abr_string -> abr_string -> abr_string
  val print_infra_instantiation_class : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_infra_instantiation_class : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_infra_datatype_equiv_2of1_name : abr_string
  val print_infra_datatype_equiv_2of1_name_aux : abr_string
  val datatype_ext_constr_namea : abr_string
  val datatype_constr_namea : abr_string
  val add_hierarchy :
    ('a -> 'b -> ((abr_string * (abr_string * ocl_ty) list) list) tmp_univ -> 'c -> (((abr_string * ocl_ty) list) list) tmp_inh -> 'd -> 'e) ->
      ocl_class -> 'a -> 'b -> 'c -> ((ocl_class, 'f) inheritance_ext list) tmp_inh -> 'g -> 'd -> 'e
  val map_class_gen_h :
    ((abr_string -> abr_string) -> abr_string -> ((abr_string * (abr_string * ocl_ty) list) list) tmp_univ -> (abr_string * ocl_ty) list -> (((abr_string * ocl_ty) list) list) tmp_inh -> ocl_class list -> 'a list) ->
      ocl_class -> 'a list
  val print_infra_datatype_equiv_2of1 : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_infra_datatype_equiv_2of1 : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_infra_datatype_equiv_1of2_name : abr_string
  val print_infra_datatype_equiv_1of2_name_get_oid_inh : abr_string
  val print_infra_datatype_equiv_1of2_name_aux : abr_string
  val term_pairs : ('a -> semi_terma) -> 'a list -> semi_terma
  val print_infra_datatype_equiv_1of2 : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_infra_datatype_equiv_1of2 : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val type_notation : type_notation -> all_meta
  val ty_integer : abr_string
  val ty_boolean : abr_string
  val ty_string : abr_string
  val var_val : abr_string
  val ty_void : abr_string
  val ty_real : abr_string
  val print_infra_type_synonym_class : 'a -> 'b -> all_meta list * 'b
  val pRINT_infra_type_synonym_class : ('a -> 'b -> all_meta list * 'b) embedding_fun
  val print_infra_datatype_universe : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_infra_datatype_universe : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_allinst_istypeof_pre_name2 : abr_string
  val print_allinst_istypeof_pre_name1 : abr_string
  val print_iskindof_up_eq_asty_name : abr_string -> abr_string
  val print_iskindof_up_larger_name : abr_string -> abr_string -> abr_string
  val var_Abs_Set : abr_string
  val var_Abs_Set_inverse : abr_string
  val simplified_l : semi_thm_attribute -> semi_thm_attribute list -> semi_thm_attribute
  val simplified : semi_thm_attribute -> semi_thm_attribute -> semi_thm_attribute
  val gen_pre_post :
    (abr_string -> abr_string) ->
      ((semi_terma list -> semi_terma) -> (semi_terma -> semi_terma) -> abr_string -> semi_terma) -> (abr_string -> semi_terma -> abr_string -> abr_string -> abr_string -> lemma) -> semi_method list -> lemma list
  val wherea : semi_thm_attribute -> (abr_string * semi_terma) list -> semi_thm_attribute
  val intro : semi_thm_attribute list -> semi_method
  val print_allinst_istypeof_single :
    (abr_string -> abr_string) -> abr_string -> ('a -> abr_string) -> abr_string -> 'a -> (abr_string -> abr_string) -> (abr_string list -> abr_string list) -> (abr_string list -> abr_string list) -> lemma list
  val m_class :
    ((abr_string * ocl_ty) list -> (abr_string * ocl_ty) list) ->
      (abr_string -> (ocl_class, unit) inheritance_ext list -> ocl_class list -> 'a list -> 'b list) -> (position -> (abr_string -> abr_string) * (abr_string * (abr_string * ocl_ty) list) -> ocl_class -> 'a list) -> ocl_class -> 'b list
  val m_classa : ((abr_string * ocl_ty) list -> (abr_string * ocl_ty) list) -> (position -> (abr_string -> abr_string) * (abr_string * (abr_string * ocl_ty) list) -> ocl_class -> 'a) -> ocl_class -> 'a list
  val map_class_nupl2_inh : (abr_string -> abr_string -> 'a) -> ocl_class -> 'a list
  val print_allinst_iskindof_larger : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_allinst_iskindof_larger : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val get_hierarchy_map : ('a -> 'b -> 'c -> 'd) -> (abr_string list -> 'a list * ('b list * 'c list)) -> ocl_class -> 'd list
  val print_istypeof_lemmas_strict_set : ocl_class -> (abr_string * (abr_string * abr_string)) list
  val print_istypeof_lemmas_strict : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_istypeof_lemmas_strict : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val term_basety : semi_terma
  val start_m :
    ('a -> 'b) ->
      (abr_string -> (ocl_class, unit) inheritance_ext list -> ocl_class list -> 'c list -> 'a list) ->
        (position -> (abr_string -> abr_string) * (abr_string * (abr_string * ocl_ty) list) -> ocl_class -> 'c list) -> ocl_class -> 'd compiler_env_config_ext -> 'b list * 'd compiler_env_config_ext
  val print_istypeof_from_universe : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_istypeof_from_universe : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_iskindof_lemmas_strict : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_iskindof_lemmas_strict : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_iskindof_from_universe : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_iskindof_from_universe : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val datatype_ext_namea : abr_string
  val datatype_ext_nameb : abr_string
  val datatype_namea : abr_string
  val opt : abr_string -> semi_typ
  val print_infra_datatype_class_2 : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_infra_datatype_class_2 : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val datatype_ext_name : abr_string
  val print_infra_datatype_class_1 : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_infra_datatype_class_1 : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_istypeof_lemma_cp_set : ocl_class -> (((abr_string -> abr_string) * abr_string) * abr_string) list
  val print_istypeof_lemma_strict : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_istypeof_lemma_strict : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_iskindof_lemma_strict : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_iskindof_lemma_strict : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val aux_d_e_p_t_h : ('a * ('b * bool) list) list -> ('a, ('a * 'b list)) print_iskindof_up_istypeof_output list
  val aux_b_r_e_a_d_t_h : 'a -> ('a, ('a * 'b list)) print_iskindof_up_istypeof_output list -> ('a * ('b * bool) list) list -> ('b * bool) list -> ('a, ('a * 'b list)) print_iskindof_up_istypeof_output list
  val print_iskindof_up_istypeof_name : abr_string -> abr_string -> abr_string
  val print_iskindof_class_name : (abr_string -> abr_string) -> abr_string -> abr_string
  val map_class_nupl2l_inh_gen : (ocl_class list -> abr_string -> ((ocl_class, unit) inheritance_ext * (ocl_class * bool) list) list -> 'a) -> ocl_class -> 'a list
  val map_class_nupl2l_inh : (abr_string -> ((ocl_class, unit) inheritance_ext * (ocl_class * bool) list) list -> 'a) -> ocl_class -> 'a list
  val term_preunary : semi_terma -> semi_terma -> semi_terma
  val print_iskindof_up_istypeof : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_iskindof_up_istypeof : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_astype_lemmas_strict : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_astype_lemmas_strict : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_astype_from_universe_name : abr_string -> abr_string
  val print_astype_from_universe : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_astype_from_universe : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_allinst_istypeof_pre : 'a -> 'b -> all_meta list * 'b
  val pRINT_allinst_istypeof_pre : ('a -> 'b -> all_meta list * 'b) embedding_fun
  val print_access_dot_lemmas_id_name : abr_string
  val print_access_dot_name : (abr_string -> abr_string) -> abr_string -> ocl_ty -> (abr_string -> abr_string) -> abr_string
  val apply_optim_ass_arity : 'a ocl_ty_class_ext -> 'b -> 'b option
  val var_in_post_state : abr_string
  val var_in_pre_state : abr_string
  val mk_dot_comment : abr_string -> abr_string -> abr_string -> abr_string
  val map_class_arg_only_var0 :
    ('a -> abr_string list -> 'b) -> ('c -> 'd -> abr_string * abr_string -> ocl_ty -> (abr_string -> abr_string) -> ('a -> 'b) -> 'e list) -> ('f -> ((abr_string * ocl_ty) list) list) -> 'c -> 'd -> 'f -> 'e list
  val map_class_arg_onlya : ((abr_string -> abr_string) -> abr_string -> (abr_string * ocl_ty) list * ((ocl_class list) tmp_inh * (ocl_class list) tmp_sub) -> 'a list) -> ocl_class -> 'a list
  val map_class_arg_only : ((abr_string -> abr_string) -> abr_string -> (abr_string * ocl_ty) list -> 'a list) -> ocl_class -> 'a list
  val map_class_arg_only0 :
    ((abr_string -> abr_string) -> abr_string -> (abr_string * ocl_ty) list -> 'a list) ->
      ((abr_string -> abr_string) -> abr_string -> (abr_string * ocl_ty) list * ((ocl_class list) tmp_inh * (ocl_class list) tmp_sub) -> 'a list) -> ocl_class -> 'a list
  val map_class_arg_only_var_gena : ('a -> abr_string list -> 'b) -> ((abr_string -> abr_string) -> abr_string -> abr_string * abr_string -> ocl_ty -> (abr_string -> abr_string) -> ('a -> 'b) -> 'c list) -> ocl_class -> 'c list
  val map_class_arg_only_vara : ((abr_string -> abr_string) -> abr_string -> abr_string * abr_string -> ocl_ty -> (abr_string -> abr_string) -> (semi_terma -> semi_terma) -> 'a list) -> ocl_class -> 'a list
  val print_access_dot_lemmas_id_set : ocl_class -> abr_string list
  val print_access_dot_lemmas_id : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_access_dot_lemmas_id : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_access_dot_lemma_cp_name : (abr_string -> abr_string) -> abr_string -> ocl_ty -> (abr_string -> abr_string) -> abr_string
  val print_access_dot_lemmas_cp : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_access_dot_lemmas_cp : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val var_eval_extract : abr_string
  val print_access_dot_cp_lemmas_set : abr_string list
  val print_access_dot_cp_lemmas : 'a -> 'b -> all_meta list * 'b
  val pRINT_access_dot_cp_lemmas : ('a -> 'b -> all_meta list * 'b) embedding_fun
  val auto_simp_add_split : semi_thm_attribute list -> abr_string list -> semi_method
  val insertb : semi_thm_attribute list -> semi_method
  val hol_split : abr_string -> abr_string
  val split_ty : abr_string -> abr_string list
  val print_iskindof_up_eq_asty : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_iskindof_up_eq_asty : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_astype_lemmas_const : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_astype_lemmas_const : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_astype_lemma_cp_set : ocl_class -> (((abr_string -> abr_string) * abr_string) * abr_string) list
  val print_astype_lemma_strict : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_astype_lemma_strict : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_allinst_iskindof_eq : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_allinst_iskindof_eq : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val start_mape : ('a -> 'b) -> (generation_lemma_mode option * bool -> generation_semantics_ocl -> 'a list) -> 'c compiler_env_config_ext -> 'b list * 'c compiler_env_config_ext
  val print_access_repr_allinst : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_access_repr_allinst : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_access_lemma_strict_name : (abr_string -> abr_string) -> abr_string -> ocl_ty -> (abr_string -> abr_string) -> abr_string -> abr_string
  val print_access_lemma_strict : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_access_lemma_strict : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val var_reconst_basetype_void : abr_string
  val var_reconst_basetype : abr_string
  val var_Abs_Void : abr_string
  val print_access_eval_extract : 'a -> 'b -> all_meta list * 'b
  val pRINT_access_eval_extract : ('a -> 'b -> all_meta list * 'b) embedding_fun
  val map_class_arg_only_var_gen :
    ('a -> abr_string list -> 'b) ->
      ((abr_string -> abr_string) -> abr_string -> abr_string * abr_string -> ocl_ty -> (abr_string -> abr_string) -> ('a -> 'b) -> 'c list) ->
        ((abr_string -> abr_string) -> abr_string -> abr_string * abr_string -> ocl_ty -> (abr_string -> abr_string) -> ('a -> 'b) -> 'c list) -> ocl_class -> 'c list
  val map_class_arg_only_var :
    ((abr_string -> abr_string) -> abr_string -> abr_string * abr_string -> ocl_ty -> (abr_string -> abr_string) -> (semi_terma -> semi_terma) -> 'a list) ->
      ((abr_string -> abr_string) -> abr_string -> abr_string * abr_string -> ocl_ty -> (abr_string -> abr_string) -> (semi_terma -> semi_terma) -> 'a list) -> ocl_class -> 'a list
  val print_access_dot_lemma_cp : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_access_dot_lemma_cp : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val var_deref : abr_string
  val print_access_deref_assocs_namea : Code_Numeral.natural -> (abr_string -> abr_string) -> (abr_string -> abr_string) -> abr_string
  val print_access_deref_assocs_name : Code_Numeral.natural -> (abr_string -> abr_string) -> abr_string -> abr_string
  val var_deref_assocs : abr_string
  val start_mapd : ('a -> 'b) -> (generation_semantics_ocl -> 'a list) -> 'c compiler_env_config_ext -> 'b list * 'c compiler_env_config_ext
  val print_access_deref_assocs : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_access_deref_assocs : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_istypeof_up_larger_name : abr_string -> abr_string -> abr_string
  val map_class_nupl2_inh_large : (abr_string -> abr_string -> 'a) -> ocl_class -> 'a list
  val print_istypeof_up_larger : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_istypeof_up_larger : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_istypeof_up_d_cast_name : abr_string -> abr_string -> abr_string -> abr_string
  val fold_less_gen : ('a -> 'b list -> 'c -> 'd) -> ('d -> 'c) -> ('b -> 'a) -> 'b list -> 'd -> 'd
  val fold_less2 : ('a -> 'a) -> ('b -> 'b -> 'a -> 'a) -> 'b list -> 'a -> 'a
  val f_less2 : 'a list -> ('a * 'a) list
  val m_class_gen3_GE :
    ((abr_string * ocl_ty) list -> (abr_string * ocl_ty) list) ->
      ('a list -> 'b list) -> ((ocl_class, unit) inheritance_ext list -> ocl_class list -> ocl_class list -> abr_string -> abr_string -> abr_string -> 'a) -> ocl_class -> 'b list
  val m_class3_GE : ((abr_string * ocl_ty) list -> (abr_string * ocl_ty) list) -> ('a list -> 'b list) -> (abr_string -> abr_string -> abr_string -> 'a) -> ocl_class -> 'b list
  val map_class_nupl3_GE_inh : (abr_string -> abr_string -> abr_string -> 'a) -> ocl_class -> 'a list
  val print_istypeof_up_d_cast : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_istypeof_up_d_cast : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_istypeof_lemmas_id : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_istypeof_lemmas_id : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_istypeof_lemmas_cp : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_istypeof_lemmas_cp : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val map_class_nupl2_inha : (abr_string -> abr_string -> (ocl_class * bool) list -> 'a) -> ocl_class -> 'a list
  val print_iskindof_up_larger : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_iskindof_up_larger : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val map_class_nupl3_LE_inh : (abr_string -> abr_string -> ((ocl_class, unit) inheritance_ext * (ocl_class * bool) list) list -> 'a) -> ocl_class -> 'a list
  val elim : semi_thm_attribute -> semi_method
  val print_iskindof_up_d_cast : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_iskindof_up_d_cast : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_iskindof_lemma_cp_set : ocl_class -> (((abr_string -> abr_string) * abr_string) * abr_string) list
  val print_iskindof_lemmas_id : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_iskindof_lemmas_id : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_iskindof_lemmas_cp : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_iskindof_lemmas_cp : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_infra_enum_synonym : 'a -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext
  val pRINT_infra_enum_synonym : ('a -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun
  val metis0 : abr_string list -> semi_thm_attribute list -> semi_method
  val print_astype_lemma_const : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_astype_lemma_const : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val oidSucAssoc : internal_oids -> internal_oids
  val oidGetAssoc : internal_oids -> internal_oid
  val print_access_oid_uniq_gen :
    ('a -> 'b) -> ('c compiler_env_config_ext -> internal_oids -> 'd) -> (Code_Numeral.natural -> abr_string -> (abr_string -> abr_string) -> abr_string -> internal_oid -> 'a) -> ocl_class -> 'c compiler_env_config_ext -> 'b list * 'd
  val print_access_oid_uniq_mlname : Code_Numeral.natural -> abr_string -> abr_string -> abr_string
  val rewrite_val : semi_term_0 -> abr_string -> semi_term_0 -> semi_term
  val oid : abr_string -> internal_oid -> semi_term_0
  val print_access_oid_uniq_ml : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_access_oid_uniq_ml : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_istypeof_lemma_cp : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_istypeof_lemma_cp : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_istypeof_defined_name : (abr_string -> abr_string) -> abr_string -> abr_string
  val thena : semi_thm_attribute -> semi_thm_attribute -> semi_thm_attribute
  val print_istypeof_defineda : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_istypeof_defineda : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val m_class_gen3 :
    ((abr_string * ocl_ty) list -> (abr_string * ocl_ty) list) ->
      ('a list -> 'b list) -> ((ocl_class, unit) inheritance_ext list -> ocl_class list -> ocl_class list -> abr_string -> abr_string -> abr_string -> 'a) -> ocl_class -> 'b list
  val start_m_3_gen :
    ('a -> 'b) -> ((ocl_class, unit) inheritance_ext list -> ocl_class list -> ocl_class list -> abr_string -> abr_string -> abr_string -> 'a) -> ocl_class -> 'c compiler_env_config_ext -> 'b list * 'c compiler_env_config_ext
  val plus : semi_method list -> semi_method
  val print_iskindof_lemma_cp : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_iskindof_lemma_cp : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_iskindof_defined_name : (abr_string -> abr_string) -> abr_string -> abr_string
  val print_iskindof_defineda : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_iskindof_defineda : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_examp_def_st_defs : 'a -> 'b -> all_meta list * 'b
  val pRINT_examp_def_st_defs : ('a -> 'b -> all_meta list * 'b) embedding_fun
  val print_astype_up_d_cast0_name : abr_string -> abr_string -> abr_string
  val print_astype_up_d_cast0 : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_astype_up_d_cast0 : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_astype_lemma_cp_set2 : ocl_class -> ((abr_string * ocl_ty) list -> (abr_string * ocl_ty) list) -> (((abr_string -> abr_string) * abr_string) * ((abr_string -> abr_string) * abr_string)) list
  val print_astype_lemmas_id2 : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_astype_lemmas_id2 : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_allinst_lemmas_id : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_allinst_lemmas_id : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val var_select_object_sequence_any : abr_string
  val var_select_object_sequence : abr_string
  val var_select_object_set_any : abr_string
  val var_select_object_set : abr_string
  val lookup2 : 'a equal -> 'b equal -> ('a, ('b, 'c) alist) alist -> 'a * 'b -> 'c option
  val lookup2a : ((int list), ((int list), 'a) alist) alist -> abr_string * abr_string -> 'a option
  val insert2 : 'a equal -> 'b equal -> 'a * 'b -> 'c -> ('a, ('b, 'c) alist) alist -> ('a, ('b, 'c) alist) alist
  val insert2a : abr_string * abr_string -> 'a -> ((int list), ((int list), 'a) alist) alist -> ((int list), ((int list), 'a) alist) alist
  val var_select : abr_string
  val print_access_select_obj : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_access_select_obj : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_access_dot_consts : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_access_dot_consts : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_istypeof_defined : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_istypeof_defined : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_iskindof_defined : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_iskindof_defined : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val rename_tac : abr_string list -> semi_method
  val case_tac : semi_terma -> semi_method
  val print_astype_up_d_cast : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_astype_up_d_cast : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_astype_lemmas_id : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_astype_lemmas_id : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_astype_lemmas_cp : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_astype_lemmas_cp : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_astype_up_d_cast_name : abr_string -> abr_string -> abr_string
  val print_astype_d_up_cast : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_astype_d_up_cast : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val term_exists : abr_string -> (abr_string -> semi_terma) -> semi_terma
  val term_pat : abr_string -> semi_terma
  val letb : semi_terma -> semi_terma -> semi_command_proof
  val fix : abr_string list -> semi_command_proof
  val print_allinst_istypeof : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_allinst_istypeof : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val var_deref_oid : abr_string
  val print_access_deref_oid_name : (abr_string -> 'a) -> 'a
  val print_access_deref_oid : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_access_deref_oid : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val class_arity : ocl_class -> Code_Numeral.natural list
  val print_access_choose_switch :
    ('a -> 'b -> 'c) -> (Code_Numeral.natural -> 'd) -> ocl_class -> (Code_Numeral.natural -> Code_Numeral.natural -> Code_Numeral.natural -> 'a) -> ('d list -> 'e) -> (('e * 'f) list -> 'b) -> ('d -> 'd -> 'f) -> 'c list
  val print_access_choose_mlname : Code_Numeral.natural -> Code_Numeral.natural -> Code_Numeral.natural -> abr_string
  val function : (semi_term_0 * semi_term_0) list -> semi_term_0
  val print_access_choose_ml : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_access_choose_ml : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val const_mixfix : abr_string -> abr_string -> abr_string
  val constsa : abr_string -> semi_typ -> abr_string -> consts
  val print_istypeof_consts : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_istypeof_consts : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_iskindof_consts : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_iskindof_consts : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_astype_lemma_cp : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_astype_lemma_cp : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_access_oid_uniq : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_access_oid_uniq : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_access_def_mono_name : (abr_string -> abr_string) -> abr_string -> ocl_ty -> (abr_string -> abr_string) -> abr_string
  val print_access_def_mono : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_access_def_mono : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_istypeof_class : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_istypeof_class : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_iskindof_class : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_iskindof_class : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_infra_enum_syn : 'a -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext
  val pRINT_infra_enum_syn : ('a -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun
  val print_astype_defined : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_astype_defined : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_allinst_def_id : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_allinst_def_id : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val print_allinst_astype_name : (abr_string -> abr_string) -> abr_string
  val map_class_one :
    (((abr_string -> abr_string) * (abr_string * ((abr_string * ocl_ty) list * ((ocl_class list) tmp_inh * ((abr_string list) tmp_sub * ocl_class list))))) list -> ('a * ('b * ('c * ('d * ('e * 'f))))) list) ->
      ('a -> 'b -> 'c -> 'd -> 'e -> 'f -> 'g) -> ocl_class -> 'g
  val map_class_top : ((abr_string -> abr_string) -> abr_string -> (abr_string * ocl_ty) list -> (ocl_class list) tmp_inh -> (abr_string list) tmp_sub -> ocl_class list -> 'a) -> ocl_class -> 'a
  val print_allinst_astype : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_allinst_astype : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val var_select_object_sequence_any_exec : abr_string
  val print_access_select_obj_name : (abr_string -> abr_string) -> abr_string -> abr_string
  val var_select_object_set_any_exec : abr_string
  val print_access_is_repr_name : (abr_string -> abr_string) -> abr_string -> ocl_ty -> (abr_string -> abr_string) -> abr_string
  val print_access_select_name : ('a -> 'b) -> (abr_string -> 'a) -> 'b
  val map_class_arg_only_var_genb : ('a -> abr_string list -> 'b) -> ((abr_string -> abr_string) -> abr_string -> abr_string * abr_string -> ocl_ty -> (abr_string -> abr_string) -> ('a -> 'b) -> 'c list) -> ocl_class -> 'c list
  val map_class_arg_only_varb : ((abr_string -> abr_string) -> abr_string -> abr_string * abr_string -> ocl_ty -> (abr_string -> abr_string) -> (semi_terma -> semi_terma) -> 'a list) -> ocl_class -> 'a list
  val meth_gen_simp_add_split : semi_thm_attribute list -> semi_thm_attribute list -> semi_method_simp
  val simp_add_split : semi_thm_attribute list -> semi_thm_attribute list -> semi_method
  val apply_end : semi_method list -> semi_command_state
  val clarify : semi_method
  val fix_let : abr_string list -> (semi_terma * semi_terma) list -> (semi_terma list * semi_terma list) option -> semi_command_state list -> semi_command_proof
  val rulea : semi_method
  val print_access_is_repr : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_access_is_repr : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_astype_consts : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_astype_consts : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val lowercase : abr_string -> abr_string
  val print_access_select : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_access_select : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val print_access_choose : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_access_choose : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val start_ma : ('a -> 'b) -> (position -> (abr_string -> abr_string) * (abr_string * (abr_string * ocl_ty) list) -> ocl_class -> 'a) -> ocl_class -> 'c compiler_env_config_ext -> 'b list * 'c compiler_env_config_ext
  val print_astype_class : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_astype_class : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val auto : semi_method
  val have : abr_string -> semi_terma -> semi_command_final -> semi_command_proof
  val print_allinst_exec : ocl_class -> 'a -> all_meta list * 'a
  val pRINT_allinst_exec : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun
  val var_select_object_pair : abr_string
  val print_access_dot_aux : (abr_string option -> semi_terma list -> semi_terma) -> ocl_ty -> semi_terma
  val print_access_dot : ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext
  val pRINT_access_dot : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun
  val txt_raw_d : ((abr_string -> abr_string) -> abr_string list) -> ('a -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun
  val txt_raw_a : ((abr_string -> abr_string) -> abr_string list) -> ('a -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun
  val subsection : abr_string -> 'a -> 'b -> all_meta list * 'b
  val subsectiona : abr_string -> ('a -> 'b -> all_meta list * 'b) embedding_fun
  val thy_class : (ocl_class, unit compiler_env_config_ext) embedding
  val map_semi_theory : (semi_theory -> semi_theory) -> all_meta -> all_meta
  val map_lemma : (lemma -> lemma) -> semi_theory -> semi_theory
  val fold_thy0 :
    'a -> ('a, 'b compiler_env_config_ext) embedding -> (abr_string option -> all_meta list -> 'b compiler_env_config_ext -> 'c -> 'b compiler_env_config_ext * 'c) -> 'b compiler_env_config_ext * 'c -> 'b compiler_env_config_ext * 'c
  val comp_env_input_class_mk :
    ((unit -> unit compiler_env_config_ext * 'a) -> 'b compiler_env_config_ext * 'c) ->
      (unit compiler_env_config_ext -> 'c -> 'a) ->
        ((abr_string option -> all_meta list -> unit compiler_env_config_ext -> 'a -> unit compiler_env_config_ext * 'a) -> 'b compiler_env_config_ext * 'c -> 'd) ->
          (abr_string option -> all_meta list -> unit compiler_env_config_ext -> 'a -> unit compiler_env_config_ext * 'a) -> 'b compiler_env_config_ext * 'c -> 'd
  val thy_class_synonym : ('a, 'b) embedding
  val thy_association : ('a, 'b) embedding
  val thy_class_tree : ('a, 'b) embedding
  val thy_class_flat : ('a, 'b) embedding
  val thy_enum_flat : ('a, 'b) embedding
  val thy_generic : ('a, 'b) embedding
  val fold_thy :
    (all_meta_embedding ->
      ((abr_string option -> all_meta list -> unit compiler_env_config_ext -> 'a -> unit compiler_env_config_ext * 'a) -> unit compiler_env_config_ext * 'a -> unit compiler_env_config_ext * 'a) ->
        (abr_string option -> all_meta list -> 'b compiler_env_config_ext -> 'c -> 'b compiler_env_config_ext * 'c) -> 'b compiler_env_config_ext * 'c -> 'b compiler_env_config_ext * 'c) ->
      ((unit -> unit compiler_env_config_ext * 'a) -> unit compiler_env_config_ext * 'a) ->
        (unit compiler_env_config_ext -> 'a -> 'a) ->
          (abr_string option -> all_meta list -> 'b compiler_env_config_ext -> 'c -> 'b compiler_env_config_ext * 'c) -> fold_all_input -> 'b compiler_env_config_ext * 'c -> 'b compiler_env_config_ext * 'c
  val fold_thya :
    (all_meta_embedding ->
      ((abr_string option -> all_meta list -> unit compiler_env_config_ext -> 'a -> unit compiler_env_config_ext * 'a) -> unit compiler_env_config_ext * 'a -> unit compiler_env_config_ext * 'a) ->
        (abr_string option -> all_meta list -> 'b compiler_env_config_ext -> 'c -> 'b compiler_env_config_ext * 'c) -> 'b compiler_env_config_ext * 'c -> 'b compiler_env_config_ext * 'c) ->
      ((unit -> unit compiler_env_config_ext * 'a) -> unit compiler_env_config_ext * 'a) ->
        (unit compiler_env_config_ext -> 'a -> 'a) ->
          (abr_string option -> all_meta list -> 'b compiler_env_config_ext -> 'c -> 'b compiler_env_config_ext * 'c) -> all_meta_embedding list -> 'b compiler_env_config_ext * 'c -> 'b compiler_env_config_ext * 'c
  val replace_gen : ((('a list), 'a) nsplit list -> 'b) -> 'a list -> ('a -> bool) -> 'a list -> 'b
  val nsplit_f : 'a list -> ('a -> bool) -> (('a list), 'a) nsplit list
  val escape_sml : abr_string -> abr_string
  val is_special : int -> bool
  val ap1 : ('a -> 'b list -> 'c) -> 'a -> ('d -> 'b) -> 'd -> 'c
  val ap2 : ('a -> 'b list -> 'c) -> 'a -> ('d -> 'b) -> ('e -> 'b) -> 'd -> 'e -> 'c
  val ap3 : ('a -> 'b list -> 'c) -> 'a -> ('d -> 'b) -> ('e -> 'b) -> ('f -> 'b) -> 'd -> 'e -> 'f -> 'c
  val ap4 : ('a -> 'b list -> 'c) -> 'a -> ('d -> 'b) -> ('e -> 'b) -> ('f -> 'b) -> ('g -> 'b) -> 'd -> 'e -> 'f -> 'g -> 'c
  val ap5 : ('a -> 'b list -> 'c) -> 'a -> ('d -> 'b) -> ('e -> 'b) -> ('f -> 'b) -> ('g -> 'b) -> ('h -> 'b) -> 'd -> 'e -> 'f -> 'g -> 'h -> 'c
  val ap6 : ('a -> 'b list -> 'c) -> 'a -> ('d -> 'b) -> ('e -> 'b) -> ('f -> 'b) -> ('g -> 'b) -> ('h -> 'b) -> ('i -> 'b) -> 'd -> 'e -> 'f -> 'g -> 'h -> 'i -> 'c
  val ar1 : ('a -> 'b list -> 'c) -> 'a -> 'b -> 'c
  val ar2 : ('a -> 'b list -> 'c) -> 'a -> ('d -> 'b) -> 'd -> 'b -> 'c
  val ar3 : ('a -> 'b list -> 'c) -> 'a -> ('d -> 'b) -> ('e -> 'b) -> 'd -> 'e -> 'b -> 'c
  val co1 : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b
  val co2 : ('a -> 'b) -> ('c -> 'd -> 'a) -> 'c -> 'd -> 'b
  val cIf : 'a cExpression -> 'a cStatement -> 'a cStatement optiona -> 'a -> 'a cStatement
  val ap16 : ('a -> 'b list -> 'c) ->
               'a -> ('d -> 'b) ->
                       ('e -> 'b) ->
                         ('f -> 'b) ->
                           ('g -> 'b) ->
                             ('h -> 'b) ->
                               ('i -> 'b) ->
                                 ('j -> 'b) ->
                                   ('k -> 'b) ->
                                     ('l -> 'b) ->
                                       ('m -> 'b) -> ('n -> 'b) -> ('o -> 'b) -> ('p -> 'b) -> ('q -> 'b) -> ('r -> 'b) -> ('s -> 'b) -> 'd -> 'e -> 'f -> 'g -> 'h -> 'i -> 'j -> 'k -> 'l -> 'm -> 'n -> 'o -> 'p -> 'q -> 'r -> 's -> 'c
  val cAsm : 'a cAssemblyStatement -> 'a -> 'a cStatement
  val cFor : ('a cExpression optiona, 'a cDeclaration) either -> 'a cExpression optiona -> 'a cExpression optiona -> 'a cStatement -> 'a -> 'a cStatement
  val cVar : ident -> 'a -> 'a cExpression
  val name : int -> namea
  val cAttr : ident -> 'a cExpression list -> 'a -> 'a cAttribute
  val cAuto : 'a -> 'a cStorageSpecifier
  val cCall : 'a cExpression -> 'a cExpression list -> 'a -> 'a cExpression
  val cCase : 'a cExpression -> 'a cStatement -> 'a -> 'a cStatement
  val cCast : 'a cDeclaration -> 'a cExpression -> 'a -> 'a cExpression
  val cChar : char -> bool -> cChar
  val cCond : 'a cExpression -> 'a cExpression optiona -> 'a cExpression -> 'a -> 'a cExpression
  val cCont : 'a -> 'a cStatement
  val cDecl : 'a cDeclarationSpecifier list -> (('a cDeclarator optiona * 'a cInitializer optiona) * 'a cExpression optiona) list -> 'a -> 'a cDeclaration
  val cEnum : ident optiona -> ((ident * 'a cExpression optiona) list) optiona -> 'a cAttribute list -> 'a -> 'a cEnumeration
  val cEqOp : cBinaryOp
  val cExpr : 'a cExpression optiona -> 'a -> 'a cStatement
  val cGoto : ident -> 'a -> 'a cStatement
  val cGrOp : cBinaryOp
  val cLeOp : cBinaryOp
  val cOrOp : cBinaryOp
  val flags : int -> 'a flags
  val identc : abr_string -> int -> nodeInfo -> ident
  val d_output_position_update : (Code_Numeral.natural * Code_Numeral.natural -> Code_Numeral.natural * Code_Numeral.natural) -> 'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val d_output_position : 'a compiler_env_config_ext -> Code_Numeral.natural * Code_Numeral.natural
  val print_meta_setup_def_transition : ocl_def_transition -> unit compiler_env_config_ext -> unit compiler_env_config_ext
  val print_meta_setup_def_state : ocl_def_state -> unit compiler_env_config_ext -> unit compiler_env_config_ext
  val comp_env_save_deep : all_meta_embedding -> ('a -> 'b -> unit compiler_env_config_ext * 'c) -> 'a -> 'b -> unit compiler_env_config_ext * 'c
  val fold_thy_deep : fold_all_input -> unit compiler_env_config_ext -> unit compiler_env_config_ext
  val rec_list : 'a -> ('b -> 'b list -> 'a -> 'a) -> 'b list -> 'a
  val list_iterM : ('a -> unit CodeType.mlMonad) -> 'a list -> unit CodeType.mlMonad
  val d_output_header_force : 'a compiler_env_config_ext -> bool
  val d_hsk_constr : 'a compiler_env_config_ext -> string_b_a_s_e list
  val compiler_env_config_rec0 :
    (bool -> (abr_string * (abr_string list * abr_string)) option ->
               internal_oids ->
                 Code_Numeral.natural * Code_Numeral.natural ->
                   generation_semantics_ocl ->
                     ocl_class option ->
                       all_meta_embedding list ->
                         (string_b_a_s_e * (unit ocl_instance_single_ext * internal_oids)) list ->
                           (string_b_a_s_e * (internal_oids * (abr_string * unit ocl_instance_single_ext) ocl_def_state_core) list) list ->
                             bool -> bool -> string_b_a_s_e list * string_b_a_s_e list -> string_b_a_s_e list -> string_b_a_s_e list -> generation_lemma_mode option * bool -> 'a) ->
      'b compiler_env_config_ext -> 'a
  val moreg : 'a compiler_env_config_ext -> 'a
  val compiler_env_config_rec :
    (bool -> (abr_string * (abr_string list * abr_string)) option ->
               internal_oids ->
                 Code_Numeral.natural * Code_Numeral.natural ->
                   generation_semantics_ocl ->
                     ocl_class option ->
                       all_meta_embedding list ->
                         (string_b_a_s_e * (unit ocl_instance_single_ext * internal_oids)) list ->
                           (string_b_a_s_e * (internal_oids * (abr_string * unit ocl_instance_single_ext) ocl_def_state_core) list) list ->
                             bool -> bool -> string_b_a_s_e list * string_b_a_s_e list -> string_b_a_s_e list -> string_b_a_s_e list -> generation_lemma_mode option * bool -> 'a -> 'b) ->
      'a compiler_env_config_ext -> 'b
  val truncate : 'a compiler_env_config_ext -> unit compiler_env_config_ext
  val extend : unit compiler_env_config_ext -> 'a -> 'a compiler_env_config_ext
  val compiler_env_config_more_map : ('a -> 'b) -> 'a compiler_env_config_ext -> 'b compiler_env_config_ext
  val of_semi_typ : (abr_string -> string) -> semi_typ -> string
  val of_pure_typa : (abr_string -> string) -> typ -> string
  val pure_typ0 : (abr_string -> string) -> bool -> abr_string -> typ -> string
  val of_pure_terma : (abr_string -> string) -> bool -> string list -> terma -> string
  val of_semi_terma : (abr_string -> string) -> semi_terma -> string
  val of_section : (abr_string -> string) -> 'a -> section -> string
  val of_e_n_v_section : (abr_string -> string) -> 'a compiler_env_config_ext -> section -> string
  val of_semi_thm_attribute_aux_gen_where : (abr_string -> string) -> (abr_string * semi_terma) list -> string * string
  val of_semi_thm_attribute_aux_gen_of : (abr_string -> string) -> semi_terma list -> string * string
  val of_semi_thm_attribute_aux_gen : (abr_string -> string) -> string * string -> (string * string) list -> abr_string -> string
  val of_semi_thm_attribute_aux : (abr_string -> string) -> (string * string) list -> semi_thm_attribute -> string
  val of_semi_thm_attribute : (abr_string -> string) -> semi_thm_attribute -> string
  val of_semi_thm_attribute_l1 : (abr_string -> string) -> semi_thm_attribute list -> string
  val of_semi_attrib_genA : (semi_thm list -> string) -> string -> semi_thm list -> string
  val of_semi_thm : (abr_string -> string) -> semi_thm -> string
  val of_semi_thm_l : (abr_string -> string) -> semi_thm list -> string
  val of_semi_attrib : (abr_string -> string) -> string -> semi_thm list -> string
  val of_semi_method_simp : (abr_string -> string) -> string -> semi_method_simp -> string
  val of_semi_attrib_genB : (abr_string list -> string) -> string -> abr_string list -> string
  val of_semi_attrib1 : (abr_string -> string) -> string -> abr_string list -> string
  val of_semi_method : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> semi_method -> string
  val of_semi_command_final : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> semi_command_final -> string
  val of_interpretation : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> 'a -> interpretation -> string
  val of_axiomatization : (abr_string -> string) -> 'a -> axiomatization -> string
  val of_type_notation : (abr_string -> string) -> 'a -> type_notation -> string
  val of_instantiation : (abr_string -> string) -> 'a -> instantiation -> string
  val of_code_reflect : (abr_string -> string) -> 'a -> code_reflect -> string
  val of_semi_typa : (abr_string -> string) -> abr_string * abr_string list -> string
  val of_type_synonym : (abr_string -> string) -> 'a -> type_synonym -> string
  val of_abbreviation : (abr_string -> string) -> 'a -> abbreviation -> string
  val of_overloading : (abr_string -> string) -> 'a -> overloading -> string
  val of_hide_const : (abr_string -> string) -> 'a -> hide_const -> string
  val of_definition : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> 'a -> definition -> string
  val of_text_raw : (abr_string -> string) -> 'a -> text_raw -> string
  val of_datatype : (abr_string -> string) -> 'a -> datatypea -> string
  val of_semi_thm_attribute_l : (abr_string -> string) -> semi_thm_attribute list -> string
  val of_lemmas : (abr_string -> string) -> 'a -> lemmas -> string
  val of_consts : (abr_string -> string) -> 'a -> consts -> string
  val of_semi_val_fun : semi_val_fun -> string
  val of_semi_term : (abr_string -> string) -> semi_term -> string
  val of_semi_term_0 : (abr_string -> string) -> semi_term_0 -> string
  val of_semi_term_1 : (abr_string -> string) -> semi_term_1 -> string
  val of_setup : (abr_string -> string) -> 'a -> setup -> string
  val of_semi_command_state : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> semi_command_state -> string
  val of_semi_command_proof : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> semi_command_proof -> string
  val of_lemma : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> 'a -> lemma -> string
  val of_text : (abr_string -> string) -> 'a -> text -> string
  val of_thm : (abr_string -> string) -> 'a -> thm -> string
  val of_ML : (abr_string -> string) -> 'a -> ml -> string
  val of_semi_theory : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> 'a -> semi_theory -> string
  val of_e_n_v_semi_theory : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> 'a compiler_env_config_ext -> semi_theory -> string
  val holThyLocale_header : 'a semi_locale_ext -> ((semi_terma * semi_typ) list * (abr_string * semi_terma) option) list
  val holThyLocale_name : 'a semi_locale_ext -> abr_string
  val string_concat_map : string -> ('a -> string) -> 'a list -> string
  val of_semi_theories0 : (abr_string -> string) -> ('a -> semi_theory -> string) -> 'a -> semi_theories -> string
  val of_e_n_v_semi_theories : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> 'a compiler_env_config_ext -> semi_theories -> string
  val of_boot_generation_syntax : 'a -> boot_generation_syntax -> string
  val of_ocl_def_basea : (abr_string -> string) -> ocl_def_base -> string
  val to_oid : (Code_Numeral.natural -> CodeType.mlInt) -> internal_oid -> CodeType.mlInt
  val of_ocl_data_shallowa : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> ocl_data_shallow -> string
  val of_ocl_list_attra : (abr_string -> string) -> ('a -> string) -> 'a ocl_list_attr -> string
  val of_ocl_instance_singlea : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> 'a ocl_instance_single_ext -> string
  val of_ocl_def_state_corea : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> abr_string ocl_def_state_core list -> string
  val of_ocl_def_pp_corea : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> ocl_def_pp_core -> string
  val of_ocl_def_transitiona : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> 'a -> string -> ocl_def_transition -> string
  val of_ocl_def_statea : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> 'a -> string -> ocl_def_state -> string
  val of_ocl_instancea : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> 'a -> ocl_instance -> string
  val of_ocl_generica : (abr_string -> string) -> 'a -> ocl_generic -> string
  val concatWith : (abr_string -> string) -> abr_string list -> string -> string
  val of_ctxt2_term_aux : (abr_string -> string) -> abr_string list -> ocl_ctxt_term -> string
  val of_ctxt2_term : (abr_string -> string) -> ocl_ctxt_term -> string
  val of_ocl_ctxta : (abr_string -> string) -> 'a -> string -> 'b ocl_ctxt_ext -> string
  val of_floora : floor -> string
  val of_all_meta_embeddinga : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> 'a -> all_meta_embedding -> string
  val sml_escape : abr_string -> abr_string
  val of_string_b_a_s_e : 'a -> (abr_string -> 'b) -> string_b_a_s_e -> 'b
  val rec_ocl_data_shallow : (ocl_def_base -> 'a) -> (abr_string -> 'a) -> (internal_oid -> 'a) -> ((ocl_data_shallow * 'a) list -> 'a) -> ocl_data_shallow -> 'a
  val rec_ocl_def_base : (abr_string -> 'a) -> (abr_string * abr_string -> 'a) -> (abr_string -> 'a) -> ocl_def_base -> 'a
  val of_pair : abr_string -> ('a -> 'b list -> 'c) -> (abr_string -> 'a) -> ('d -> 'b) -> ('e -> 'b) -> 'd * 'e -> 'c
  val of_ocl_def_base : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_def_base -> 'a
  val rec_internal_oid : (Code_Numeral.natural -> 'a) -> internal_oid -> 'a
  val of_internal_oid : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> internal_oid -> 'a
  val of_list : abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ('b -> 'a) -> 'b list -> 'a
  val of_ocl_data_shallow :
    (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_data_shallow -> 'a
  val ocl_instance_single_rec0 : (abr_string option -> abr_string option -> abr_string option -> (((abr_string * abr_string) option * (abr_string * ocl_data_shallow)) list) ocl_list_attr -> 'a) -> 'b ocl_instance_single_ext -> 'a
  val moreh : 'a ocl_instance_single_ext -> 'a
  val ocl_instance_single_rec : (abr_string option -> abr_string option -> abr_string option -> (((abr_string * abr_string) option * (abr_string * ocl_data_shallow)) list) ocl_list_attr -> 'a -> 'b) -> 'a ocl_instance_single_ext -> 'b
  val rec_ocl_list_attr : ('a -> 'b) -> (abr_string -> 'a ocl_list_attr -> 'a -> 'b -> 'b) -> 'a ocl_list_attr -> 'b
  val of_ocl_list_attr : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ('b -> 'a) -> 'b ocl_list_attr -> 'a
  val rec_option : 'a -> ('b -> 'a) -> 'b option -> 'a
  val of_option : abr_string -> abr_string -> ('a -> 'b list -> 'a) -> (abr_string -> 'a) -> ('c -> 'b) -> 'c option -> 'a
  val of_ocl_instance_single :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> 'b -> 'a) -> 'b ocl_instance_single_ext -> 'a
  val rec_ocl_def_state_core : (unit ocl_instance_single_ext -> 'a) -> ('b -> 'a) -> 'b ocl_def_state_core -> 'a
  val of_ocl_def_state_core :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ('b -> 'a) -> 'b ocl_def_state_core -> 'a
  val rec_generation_semantics_ocl : 'a -> 'a -> 'a -> generation_semantics_ocl -> 'a
  val of_generation_semantics_ocl : 'a -> (abr_string -> 'b) -> generation_semantics_ocl -> 'b
  val rec_internal_oids : (Code_Numeral.natural -> Code_Numeral.natural -> Code_Numeral.natural -> 'a) -> internal_oids -> 'a
  val of_internal_oids : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> internal_oids -> 'a
  val rec_generation_lemma_mode : 'a -> 'a -> generation_lemma_mode -> 'a
  val of_generation_lemma_mode : 'a -> (abr_string -> 'b) -> generation_lemma_mode -> 'b
  val rec_all_meta_embedding :
    (ocl_enum -> 'a) ->
      (floor -> unit ocl_class_raw_ext -> 'a) ->
        (unit ocl_association_ext -> 'a) ->
          (floor -> ocl_ass_class -> 'a) ->
            (floor -> unit ocl_ctxt_ext -> 'a) ->
              (isaUnit -> 'a) ->
                (ocl_class_synonym -> 'a) ->
                  (ocl_instance -> 'a) ->
                    (ocl_def_base_l -> 'a) -> (floor -> ocl_def_state -> 'a) -> (floor -> ocl_def_transition -> 'a) -> (ocl_class_tree -> 'a) -> (ocl_flush_all -> 'a) -> (ocl_generic -> 'a) -> all_meta_embedding -> 'a
  val rec_ocl_def_transition : (abr_string option -> ocl_def_pp_core -> ocl_def_pp_core option -> 'a) -> ocl_def_transition -> 'a
  val rec_ocl_def_pp_core : (abr_string ocl_def_state_core list -> 'a) -> (abr_string -> 'a) -> ocl_def_pp_core -> 'a
  val of_ocl_def_pp_core :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_def_pp_core -> 'a
  val of_ocl_def_transition :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_def_transition -> 'a
  val rec_ocl_def_base_l : (ocl_def_base list -> 'a) -> ocl_def_base_l -> 'a
  val of_ocl_def_base_l : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_def_base_l -> 'a
  val rec_ocl_class_tree : (Code_Numeral.natural -> Code_Numeral.natural -> 'a) -> ocl_class_tree -> 'a
  val of_ocl_class_tree : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_class_tree -> 'a
  val rec_ocl_def_state : (abr_string -> abr_string ocl_def_state_core list -> 'a) -> ocl_def_state -> 'a
  val of_ocl_def_state :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_def_state -> 'a
  val rec_ocl_instance : (unit ocl_instance_single_ext list -> 'a) -> ocl_instance -> 'a
  val of_ocl_instance :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_instance -> 'a
  val rec_ocl_class_synonym : (abr_string -> ocl_ty -> 'a) -> ocl_class_synonym -> 'a
  val rec_ocl_multiplicity_single : (Code_Numeral.natural -> 'a) -> 'a -> 'a -> ocl_multiplicity_single -> 'a
  val of_ocl_multiplicity_single : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_multiplicity_single -> 'a
  val rec_ocl_collection : 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> ocl_collection -> 'a
  val of_ocl_collection : (abr_string -> 'a) -> ocl_collection -> 'a
  val ocl_multiplicity_rec0 : ((ocl_multiplicity_single * ocl_multiplicity_single option) list -> abr_string option -> ocl_collection list -> 'a) -> 'b ocl_multiplicity_ext -> 'a
  val mored : 'a ocl_multiplicity_ext -> 'a
  val ocl_multiplicity_rec : ((ocl_multiplicity_single * ocl_multiplicity_single option) list -> abr_string option -> ocl_collection list -> 'a -> 'b) -> 'a ocl_multiplicity_ext -> 'b
  val of_ocl_multiplicity :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> 'b -> 'a) -> 'b ocl_multiplicity_ext -> 'a
  val rec_ocl_ty_obj_core : (abr_string -> 'a) -> (unit ocl_ty_class_ext -> 'a) -> ocl_ty_obj_core -> 'a
  val ocl_ty_class_node_rec0 : (Code_Numeral.natural -> unit ocl_multiplicity_ext -> abr_string -> 'a) -> 'b ocl_ty_class_node_ext -> 'a
  val moref : 'a ocl_ty_class_node_ext -> 'a
  val ocl_ty_class_node_rec : (Code_Numeral.natural -> unit ocl_multiplicity_ext -> abr_string -> 'a -> 'b) -> 'a ocl_ty_class_node_ext -> 'b
  val of_ocl_ty_class_node :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) ->
            abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> 'b -> 'a) -> 'b ocl_ty_class_node_ext -> 'a
  val ocl_ty_class_rec0 : (abr_string -> Code_Numeral.natural -> Code_Numeral.natural -> unit ocl_ty_class_node_ext -> unit ocl_ty_class_node_ext -> 'a) -> 'b ocl_ty_class_ext -> 'a
  val morea : 'a ocl_ty_class_ext -> 'a
  val ocl_ty_class_rec : (abr_string -> Code_Numeral.natural -> Code_Numeral.natural -> unit ocl_ty_class_node_ext -> unit ocl_ty_class_node_ext -> 'a -> 'b) -> 'a ocl_ty_class_ext -> 'b
  val of_ocl_ty_class :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) ->
            abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> 'b -> 'a) -> 'b ocl_ty_class_ext -> 'a
  val of_ocl_ty_obj_core :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_ty_obj_core -> 'a
  val rec_ocl_ty_obj : (ocl_ty_obj_core -> (ocl_ty_obj_core list) list -> 'a) -> ocl_ty_obj -> 'a
  val of_ocl_ty_obj :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_ty_obj -> 'a
  val rec_ocl_ty :
    'a -> 'a -> 'a -> 'a -> 'a -> 'a -> (ocl_ty_obj -> 'a) ->
                                          (unit ocl_multiplicity_ext -> ocl_ty -> 'a -> 'a) ->
                                            (ocl_ty -> ocl_ty -> 'a -> 'a -> 'a) ->
                                              (abr_string option * (ocl_ty * 'a) -> 'a) -> (ocl_ty -> ocl_ty -> 'a -> 'a -> 'a) -> (abr_string -> 'a) -> (abr_string -> 'a) -> (abr_string -> 'a) -> ocl_ty -> 'a
  val of_ocl_ty :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_ty -> 'a
  val of_ocl_class_synonym :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_class_synonym -> 'a
  val rec_ocl_association_relation : ((ocl_ty_obj * unit ocl_multiplicity_ext) list -> 'a) -> ocl_association_relation -> 'a
  val of_ocl_association_relation :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_association_relation -> 'a
  val rec_ocl_association_type : 'a -> 'a -> 'a -> 'a -> ocl_association_type -> 'a
  val of_ocl_association_type : 'a -> (abr_string -> 'b) -> ocl_association_type -> 'b
  val ocl_association_rec0 : (ocl_association_type -> ocl_association_relation -> 'a) -> 'b ocl_association_ext -> 'a
  val morec : 'a ocl_association_ext -> 'a
  val ocl_association_rec : (ocl_association_type -> ocl_association_relation -> 'a -> 'b) -> 'a ocl_association_ext -> 'b
  val of_ocl_association :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) ->
            abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> 'b -> 'a) -> 'b ocl_association_ext -> 'a
  val rec_ocl_flush_all : 'a -> ocl_flush_all -> 'a
  val of_ocl_flush_all : 'a -> (abr_string -> 'b) -> ocl_flush_all -> 'b
  val rec_ocl_ctxt_clause : (unit ocl_ctxt_pre_post_ext -> 'a) -> (ocl_ctxt_term_inv -> 'a) -> ocl_ctxt_clause -> 'a
  val rec_ocl_ctxt_term_inv : (bool -> ocl_prop -> 'a) -> ocl_ctxt_term_inv -> 'a
  val rec_ocl_ctxt_term : (terma -> abr_string option -> 'a) -> (abr_string -> abr_string -> 'a) -> (abr_string -> ocl_ctxt_term -> 'a -> 'a) -> ocl_ctxt_term -> 'a
  val of_pure_indexname :
    (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string * Code_Numeral.natural -> 'a
  val of_pure_class : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a
  val of_pure_sort : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string list -> 'a
  val rec_typ : (abr_string -> (typ * 'a) list -> 'a) -> (abr_string -> abr_string list -> 'a) -> (abr_string * Code_Numeral.natural -> abr_string list -> 'a) -> typ -> 'a
  val of_pure_typ :
    (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> typ -> 'a
  val rec_term :
    (abr_string -> typ -> 'a) ->
      (abr_string -> typ -> 'a) -> (abr_string * Code_Numeral.natural -> typ -> 'a) -> (Code_Numeral.natural -> 'a) -> (abr_string -> typ -> terma -> 'a -> 'a) -> (terma -> terma -> 'a -> 'a -> 'a) -> terma -> 'a
  val of_pure_term :
    (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> terma -> 'a
  val of_ocl_ctxt_term :
    (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_ctxt_term -> 'a
  val rec_ocl_prop : (abr_string option -> ocl_ctxt_term -> 'a) -> ocl_prop -> 'a
  val of_ocl_prop :
    (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_prop -> 'a
  val of_ocl_ctxt_term_inv :
    (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
        ((abr_string -> 'a) -> bool -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_ctxt_term_inv -> 'a
  val rec_ocl_ctxt_term_pp : (ocl_ctxt_prefix -> ocl_prop -> 'a) -> (ocl_ctxt_term_inv -> 'a) -> ocl_ctxt_term_pp -> 'a
  val rec_ocl_ctxt_prefix : 'a -> 'a -> ocl_ctxt_prefix -> 'a
  val of_ocl_ctxt_prefix : 'a -> (abr_string -> 'b) -> ocl_ctxt_prefix -> 'b
  val of_ocl_ctxt_term_pp :
    (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
        ((abr_string -> 'a) -> bool -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_ctxt_term_pp -> 'a
  val ocl_ctxt_pre_post_rec0 : (abr_string -> ocl_ty -> ocl_ctxt_term_pp list -> 'a) -> 'b ocl_ctxt_pre_post_ext -> 'a
  val moree : 'a ocl_ctxt_pre_post_ext -> 'a
  val ocl_ctxt_pre_post_rec : (abr_string -> ocl_ty -> ocl_ctxt_term_pp list -> 'a -> 'b) -> 'a ocl_ctxt_pre_post_ext -> 'b
  val of_ocl_ctxt_pre_post :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) ->
            ((abr_string -> 'a) -> bool -> 'a) ->
              abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> 'b -> 'a) -> 'b ocl_ctxt_pre_post_ext -> 'a
  val of_ocl_ctxt_clause :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) -> ((abr_string -> 'a) -> bool -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_ctxt_clause -> 'a
  val classRaw_abstract : 'a ocl_class_raw_ext -> bool
  val ocl_class_raw_rec0 : (ocl_ty_obj -> (abr_string * ocl_ty) list -> ocl_ctxt_clause list -> bool -> 'a) -> 'b ocl_class_raw_ext -> 'a
  val moreb : 'a ocl_class_raw_ext -> 'a
  val ocl_class_raw_rec : (ocl_ty_obj -> (abr_string * ocl_ty) list -> ocl_ctxt_clause list -> bool -> 'a -> 'b) -> 'a ocl_class_raw_ext -> 'b
  val of_ocl_class_raw :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) ->
            ((abr_string -> 'a) -> bool -> 'a) ->
              abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> 'b -> 'a) -> 'b ocl_class_raw_ext -> 'a
  val rec_ocl_ass_class : (unit ocl_association_ext -> unit ocl_class_raw_ext -> 'a) -> ocl_ass_class -> 'a
  val of_ocl_ass_class :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) -> ((abr_string -> 'a) -> bool -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_ass_class -> 'a
  val rec_ocl_generic : (abr_string -> 'a) -> ocl_generic -> 'a
  val of_ocl_generic : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_generic -> 'a
  val rec_ocl_enum : (abr_string -> abr_string list -> 'a) -> ocl_enum -> 'a
  val of_ocl_enum : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_enum -> 'a
  val ocl_ctxt_rec0 : (abr_string list -> ocl_ty_obj -> ocl_ctxt_clause list -> 'a) -> 'b ocl_ctxt_ext -> 'a
  val more : 'a ocl_ctxt_ext -> 'a
  val ocl_ctxt_rec : (abr_string list -> ocl_ty_obj -> ocl_ctxt_clause list -> 'a -> 'b) -> 'a ocl_ctxt_ext -> 'b
  val of_ocl_ctxt :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) ->
            ((abr_string -> 'a) -> bool -> 'a) ->
              abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> 'b -> 'a) -> 'b ocl_ctxt_ext -> 'a
  val rec_gen_meta : (abr_string -> 'a) -> (abr_string -> 'a) -> (abr_string -> abr_string -> 'a) -> 'a -> gen_meta -> 'a
  val of_gen_meta : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> gen_meta -> 'a
  val rec_IsaUnit : (bool * Code_Numeral.natural -> (abr_string * abr_string option) list -> gen_meta -> abr_string -> module list * bool -> 'a) -> isaUnit -> 'a
  val rec_ThyName : (abr_string -> 'a) -> thyName -> 'a
  val of_ThyName : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> thyName -> 'a
  val rec_Module : (thyName -> thyName list -> stmt list -> bool -> 'a) -> module -> 'a
  val rec_Function_Stmt : (function_Kind -> typeSign list -> ((name * term list) * term) list -> 'a) -> function_Stmt -> 'a
  val rec_Function_Kind : 'a -> 'a -> 'a -> 'a -> function_Kind -> 'a
  val of_Function_Kind : (abr_string -> 'a) -> function_Kind -> 'a
  val rec_TypeSign : (name -> (name * name list) list -> typea -> 'a) -> typeSign -> 'a
  val rec_Name : (thyName -> abr_string -> 'a) -> (abr_string -> 'a) -> name -> 'a
  val of_Name : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> name -> 'a
  val rec_Type : (name -> (typea * 'a) list -> 'a) -> (typea -> typea -> 'a -> 'a -> 'a) -> (name -> 'a) -> 'a -> typea -> 'a
  val of_Type : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> typea -> 'a
  val of_Sort : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> name list -> 'a
  val of_TypeSign : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> typeSign -> 'a
  val rec_Literal : (Code_Numeral.natural -> 'a) -> (abr_string -> 'a) -> literal -> 'a
  val of_Literal : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) -> (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> literal -> 'a
  val of_TLD_aux :
    (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
        abr_string ->
          abr_string ->
            abr_string ->
              ((literal -> 'a) ->
                (name -> 'a) ->
                  (name -> 'b -> 'a -> 'a) ->
                    ('c -> 'd -> 'a -> 'a -> 'a) ->
                      ('e -> 'f -> 'g -> 'a -> 'a -> 'a -> 'a) ->
                        ((('h * 'a) * ('i * 'a)) list -> 'j -> 'a -> 'a) ->
                          ('k -> (('l * 'a) * ('m * 'a)) list -> 'a -> 'a) ->
                            ('n -> ('o * 'a) list -> 'a -> 'a) ->
                              (name -> (name * ('p * 'a)) list -> 'a) ->
                                ('q -> (name * ('r * 'a)) list -> 'a -> 'a) ->
                                  (abr_string -> ('s * 'a) list -> abr_string -> 'a) ->
                                    ('t -> 'a -> 'a) -> (('u * 'a) * ('v * 'a) -> 'a) -> ('w -> 'a -> 'a) -> ('x -> 'y -> 'a -> 'a -> 'a) -> ('z -> 'a -> 'a) -> ((('aa * 'a) * ('ab * 'a)) list -> 'a) -> 'ac) ->
                ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> 'ac
  val rec_Term :
    (literal -> 'a) ->
      (name -> 'a) ->
        (name -> term -> 'a -> 'a) ->
          (term -> term -> 'a -> 'a -> 'a) ->
            (term -> term -> term -> 'a -> 'a -> 'a -> 'a) ->
              (((term * 'a) * (term * 'a)) list -> term -> 'a -> 'a) ->
                (term -> ((term * 'a) * (term * 'a)) list -> 'a -> 'a) ->
                  (term -> (listComprFragment * 'b) list -> 'a -> 'a) ->
                    (name -> (name * (term * 'a)) list -> 'a) ->
                      (term -> (name * (term * 'a)) list -> 'a -> 'a) ->
                        (abr_string -> (doBlockFragment * 'c) list -> abr_string -> 'a) ->
                          (term -> 'a -> 'a) -> ((term * 'a) * (term * 'a) -> 'b) -> (term -> 'a -> 'b) -> (term -> term -> 'a -> 'a -> 'c) -> (term -> 'a -> 'c) -> (((term * 'a) * (term * 'a)) list -> 'c) -> term -> 'a
  val rec_DoBlockFragment :
    (literal -> 'a) ->
      (name -> 'a) ->
        (name -> term -> 'a -> 'a) ->
          (term -> term -> 'a -> 'a -> 'a) ->
            (term -> term -> term -> 'a -> 'a -> 'a -> 'a) ->
              (((term * 'a) * (term * 'a)) list -> term -> 'a -> 'a) ->
                (term -> ((term * 'a) * (term * 'a)) list -> 'a -> 'a) ->
                  (term -> (listComprFragment * 'b) list -> 'a -> 'a) ->
                    (name -> (name * (term * 'a)) list -> 'a) ->
                      (term -> (name * (term * 'a)) list -> 'a -> 'a) ->
                        (abr_string -> (doBlockFragment * 'c) list -> abr_string -> 'a) ->
                          (term -> 'a -> 'a) -> ((term * 'a) * (term * 'a) -> 'b) -> (term -> 'a -> 'b) -> (term -> term -> 'a -> 'a -> 'c) -> (term -> 'a -> 'c) -> (((term * 'a) * (term * 'a)) list -> 'c) -> doBlockFragment -> 'c
  val rec_ListComprFragment :
    (literal -> 'a) ->
      (name -> 'a) ->
        (name -> term -> 'a -> 'a) ->
          (term -> term -> 'a -> 'a -> 'a) ->
            (term -> term -> term -> 'a -> 'a -> 'a -> 'a) ->
              (((term * 'a) * (term * 'a)) list -> term -> 'a -> 'a) ->
                (term -> ((term * 'a) * (term * 'a)) list -> 'a -> 'a) ->
                  (term -> (listComprFragment * 'b) list -> 'a -> 'a) ->
                    (name -> (name * (term * 'a)) list -> 'a) ->
                      (term -> (name * (term * 'a)) list -> 'a -> 'a) ->
                        (abr_string -> (doBlockFragment * 'c) list -> abr_string -> 'a) ->
                          (term -> 'a -> 'a) -> ((term * 'a) * (term * 'a) -> 'b) -> (term -> 'a -> 'b) -> (term -> term -> 'a -> 'a -> 'c) -> (term -> 'a -> 'c) -> (((term * 'a) * (term * 'a)) list -> 'c) -> listComprFragment -> 'b
  val of_Term :
    (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> term -> 'a
  val of_Pat : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
                 (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> term -> 'a
  val of_Function_Stmt :
    (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> function_Stmt -> 'a
  val rec_TypeSpec : (name list -> name -> 'a) -> typeSpec -> 'a
  val of_TypeSpec : (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> typeSpec -> 'a
  val rec_Stmt :
    ((typeSpec * (name * typea list) list) list -> 'a) ->
      (typeSpec -> (name * typea) list -> 'a) ->
        ((typeSpec * typea) list -> 'a) ->
          (function_Stmt -> 'a) -> (name -> name list -> typeSign list -> 'a) -> (name -> name -> (name * name list) list -> function_Stmt list -> 'a) -> (abr_string -> 'a) -> (function_Stmt -> 'a) -> stmt -> 'a
  val of_Stmt :
    (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> stmt -> 'a
  val of_Module :
    (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) -> ((abr_string -> 'a) -> bool -> 'a) -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> module -> 'a
  val of_IsaUnit :
    (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
        ((abr_string -> 'a) -> bool -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> isaUnit -> 'a
  val rec_floor : 'a -> 'a -> 'a -> floor -> 'a
  val of_floor : 'a -> (abr_string -> 'b) -> floor -> 'b
  val of_all_meta_embedding :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) -> ((abr_string -> 'a) -> bool -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> all_meta_embedding -> 'a
  val rec_ocl_class : (abr_string -> (abr_string * ocl_ty) list -> (ocl_class * 'a) list -> 'a) -> ocl_class -> 'a
  val of_ocl_class :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
          ((abr_string -> 'a) -> unit -> 'a) -> abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ocl_class -> 'a
  val of_compiler_env_config :
    (abr_string -> abr_string) ->
      (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> abr_string -> 'a) ->
        (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> string_b_a_s_e -> 'a) ->
          (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> Code_Numeral.natural -> 'a) ->
            ((abr_string -> 'a) -> unit -> 'a) ->
              ((abr_string -> 'a) -> bool -> 'a) ->
                abr_string -> abr_string -> abr_string -> abr_string -> abr_string -> ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> (('a -> 'a list -> 'a) -> (abr_string -> 'a) -> 'b -> 'a) -> 'b compiler_env_config_ext -> 'a
  val of_string : 'a -> (abr_string -> 'b) -> abr_string -> 'b
  val of_unit : (abr_string -> 'a) -> unit -> 'a
  val of_bool : (abr_string -> 'a) -> bool -> 'a
  val of_Some : abr_string
  val of_Pair : abr_string
  val of_None : abr_string
  val of_Cons : abr_string
  val of_nat : 'a -> (abr_string -> 'b) -> Code_Numeral.natural -> 'b
  val of_Nil : abr_string
  val compiler_env_config : ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> unit compiler_env_config_ext -> 'a
  val sml_of_compiler_env_config : ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> unit compiler_env_config_ext -> 'a
  val sml_apply : abr_string -> abr_string list -> abr_string
  val let_open : abr_string -> semi_term_0 -> semi_term_0
  val of_boot_setup_env : (abr_string -> string) -> 'a -> boot_setup_env -> string
  val of_all_meta : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> 'a compiler_env_config_ext -> all_meta -> string
  val term_string : abr_string -> semi_terma
  val integer_escape : int
  val of_all_meta_lists : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> bool compiler_env_config_ext -> (abr_string option * all_meta list) list -> string list
  val write_file0a :
    (abr_string -> string) ->
      (Code_Numeral.natural -> CodeType.mlInt) -> (all_meta_embedding list * abr_string option) compiler_env_config_ext -> (((string -> string -> unit CodeType.mlMonad) -> unit CodeType.mlMonad) -> unit CodeType.mlMonad) * string list
  val write_filea : (abr_string -> string) -> (Code_Numeral.natural -> CodeType.mlInt) -> (all_meta_embedding list * abr_string option) compiler_env_config_ext -> unit CodeType.mlMonad
  val write_file : (all_meta_embedding list * abr_string option) compiler_env_config_ext -> unit CodeType.mlMonad
  val cAddOp : cBinaryOp
  val cAdrOp : cUnaryOp
  val cAndOp : cBinaryOp
  val cBreak : 'a -> 'a cStatement
  val cCases : 'a cExpression -> 'a cExpression -> 'a cStatement -> 'a -> 'a cStatement
  val cChars : char list -> bool -> cChar
  val cComma : 'a cExpression list -> 'a -> 'a cExpression
  val cConst : 'a cConstant -> 'a cExpression
  val cDeclr : ident optiona -> 'a cDerivedDeclarator list -> 'a cStringLiteral optiona -> 'a cAttribute list -> 'a -> 'a cDeclarator
  val cDivOp : cBinaryOp
  val cFloat : abr_string -> cFloat
  val cGeqOp : cBinaryOp
  val cIndOp : cUnaryOp
  val cIndex : 'a cExpression -> 'a cExpression -> 'a -> 'a cExpression
  val cLabel : ident -> 'a cStatement -> 'a cAttribute list -> 'a -> 'a cStatement
  val cLeqOp : cBinaryOp
  val cLndOp : cBinaryOp
  val cLorOp : cBinaryOp
  val cMinOp : cUnaryOp
  val cMulOp : cBinaryOp
  val cNegOp : cUnaryOp
  val cNeqOp : cBinaryOp
  val cRmdOp : cBinaryOp
  val cShlOp : cBinaryOp
  val cShrOp : cBinaryOp
  val cSubOp : cBinaryOp
  val cUnary : cUnaryOp -> 'a cExpression -> 'a -> 'a cExpression
  val cWhile : 'a cExpression -> 'a cStatement -> bool -> 'a -> 'a cStatement
  val cXorOp : cBinaryOp
  val textstr_of_str : (abr_string -> abr_string) -> (int -> abr_string) -> (abr_string -> abr_string) -> abr_string -> abr_string
  val write_file0 : (all_meta_embedding list * abr_string option) compiler_env_config_ext -> (((string -> string -> unit CodeType.mlMonad) -> unit CodeType.mlMonad) -> unit CodeType.mlMonad) * string list
  val cAsmExt : 'a cStringLiteral -> 'a -> 'a cExternalDeclaration
  val cAssign : cAssignOp -> 'a cExpression -> 'a cExpression -> 'a -> 'a cExpression
  val cBinary : cBinaryOp -> 'a cExpression -> 'a cExpression -> 'a -> 'a cExpression
  val cCompOp : cUnaryOp
  val cExtern : 'a -> 'a cStorageSpecifier
  val cFunDef : 'a cDeclarationSpecifier list -> 'a cDeclarator -> 'a cDeclaration list -> 'a cStatement -> 'a -> 'a cFunctionDef
  val cMember : 'a cExpression -> ident -> bool -> 'a -> 'a cExpression
  val cPlusOp : cUnaryOp
  val cReturn : 'a cExpression optiona -> 'a -> 'a cStatement
  val cSUType : 'a cStructureUnion -> 'a -> 'a cTypeSpecifier
  val cStatic : 'a -> 'a cStorageSpecifier
  val cStrLit : cString -> 'a -> 'a cStringLiteral
  val cString : abr_string -> bool -> cString
  val cStruct : cStructTag -> ident optiona -> ('a cDeclaration list) optiona -> 'a cAttribute list -> 'a -> 'a cStructureUnion
  val cSwitch : 'a cExpression -> 'a cStatement -> 'a -> 'a cStatement
  val cThread : 'a -> 'a cStorageSpecifier
  val decRepr : cIntRepr
  val hexRepr : cIntRepr
  val onlyPos : positiona -> positiona * int -> nodeInfo
  val head : asmblock -> abr_string
  val mod1 : asmblock -> (abr_string option * (abr_string * expr)) list
  val mod2 : asmblock -> (abr_string option * (abr_string * expr)) list
  val mod3 : asmblock -> abr_string list
  val map_Region_Wrap : ('a -> 'b) -> 'a region_Wrap -> 'b region_Wrap
  val map_ctype : ('a -> 'b) -> 'a ctype -> 'b ctype
  val rec_expr :
    (binoptype -> expr -> expr -> 'a -> 'a -> 'b) ->
      (unoptype -> expr -> 'a -> 'b) ->
        (expr -> expr -> expr -> 'a -> 'a -> 'a -> 'b) ->
          (literalconstant_node region_Wrap -> 'b) ->
            (abr_string -> ((int ctype * more_info) option) unsynchronized_ref -> 'b) ->
              (expr -> abr_string -> 'a -> 'b) ->
                (expr -> expr -> 'a -> 'a -> 'b) ->
                  (expr -> 'a -> 'b) ->
                    ((expr * 'a) ctype region_Wrap -> expr -> 'a -> 'b) ->
                      (expr -> 'a -> 'b) ->
                        ((expr * 'a) ctype region_Wrap -> 'b) ->
                          (expr -> (expr * 'a) list -> 'a -> 'b) ->
                            ((expr * 'a) ctype -> ((designator * 'c) list * (initializer * 'd)) list -> 'b) ->
                              ((expr * 'a) ctype -> 'b) ->
                                (expr -> 'a -> 'b) -> ((expr_node * 'b) region_Wrap -> 'a) -> (expr -> 'a -> 'd) -> (((designator * 'c) list * (initializer * 'd)) list -> 'd) -> (expr -> 'a -> 'c) -> (abr_string -> 'c) -> expr -> 'a
  val rec_designator :
    (binoptype -> expr -> expr -> 'a -> 'a -> 'b) ->
      (unoptype -> expr -> 'a -> 'b) ->
        (expr -> expr -> expr -> 'a -> 'a -> 'a -> 'b) ->
          (literalconstant_node region_Wrap -> 'b) ->
            (abr_string -> ((int ctype * more_info) option) unsynchronized_ref -> 'b) ->
              (expr -> abr_string -> 'a -> 'b) ->
                (expr -> expr -> 'a -> 'a -> 'b) ->
                  (expr -> 'a -> 'b) ->
                    ((expr * 'a) ctype region_Wrap -> expr -> 'a -> 'b) ->
                      (expr -> 'a -> 'b) ->
                        ((expr * 'a) ctype region_Wrap -> 'b) ->
                          (expr -> (expr * 'a) list -> 'a -> 'b) ->
                            ((expr * 'a) ctype -> ((designator * 'c) list * (initializer * 'd)) list -> 'b) ->
                              ((expr * 'a) ctype -> 'b) ->
                                (expr -> 'a -> 'b) ->
                                  ((expr_node * 'b) region_Wrap -> 'a) -> (expr -> 'a -> 'd) -> (((designator * 'c) list * (initializer * 'd)) list -> 'd) -> (expr -> 'a -> 'c) -> (abr_string -> 'c) -> designator -> 'c
  val rec_initializer :
    (binoptype -> expr -> expr -> 'a -> 'a -> 'b) ->
      (unoptype -> expr -> 'a -> 'b) ->
        (expr -> expr -> expr -> 'a -> 'a -> 'a -> 'b) ->
          (literalconstant_node region_Wrap -> 'b) ->
            (abr_string -> ((int ctype * more_info) option) unsynchronized_ref -> 'b) ->
              (expr -> abr_string -> 'a -> 'b) ->
                (expr -> expr -> 'a -> 'a -> 'b) ->
                  (expr -> 'a -> 'b) ->
                    ((expr * 'a) ctype region_Wrap -> expr -> 'a -> 'b) ->
                      (expr -> 'a -> 'b) ->
                        ((expr * 'a) ctype region_Wrap -> 'b) ->
                          (expr -> (expr * 'a) list -> 'a -> 'b) ->
                            ((expr * 'a) ctype -> ((designator * 'c) list * (initializer * 'd)) list -> 'b) ->
                              ((expr * 'a) ctype -> 'b) ->
                                (expr -> 'a -> 'b) ->
                                  ((expr_node * 'b) region_Wrap -> 'a) -> (expr -> 'a -> 'd) -> (((designator * 'c) list * (initializer * 'd)) list -> 'd) -> (expr -> 'a -> 'c) -> (abr_string -> 'c) -> initializer -> 'd
  val rec_expr_node :
    (binoptype -> expr -> expr -> 'a -> 'a -> 'b) ->
      (unoptype -> expr -> 'a -> 'b) ->
        (expr -> expr -> expr -> 'a -> 'a -> 'a -> 'b) ->
          (literalconstant_node region_Wrap -> 'b) ->
            (abr_string -> ((int ctype * more_info) option) unsynchronized_ref -> 'b) ->
              (expr -> abr_string -> 'a -> 'b) ->
                (expr -> expr -> 'a -> 'a -> 'b) ->
                  (expr -> 'a -> 'b) ->
                    ((expr * 'a) ctype region_Wrap -> expr -> 'a -> 'b) ->
                      (expr -> 'a -> 'b) ->
                        ((expr * 'a) ctype region_Wrap -> 'b) ->
                          (expr -> (expr * 'a) list -> 'a -> 'b) ->
                            ((expr * 'a) ctype -> ((designator * 'c) list * (initializer * 'd)) list -> 'b) ->
                              ((expr * 'a) ctype -> 'b) ->
                                (expr -> 'a -> 'b) ->
                                  ((expr_node * 'b) region_Wrap -> 'a) -> (expr -> 'a -> 'd) -> (((designator * 'c) list * (initializer * 'd)) list -> 'd) -> (expr -> 'a -> 'c) -> (abr_string -> 'c) -> expr_node -> 'b
  val cArrSize : bool -> 'a cExpression -> 'a cArraySize
  val cAsmStmt : 'a cTypeQualifier optiona -> 'a cStringLiteral -> 'a cAssemblyOperand list -> 'a cAssemblyOperand list -> 'a cStringLiteral list -> 'a -> 'a cAssemblyStatement
  val cDeclExt : 'a cDeclaration -> 'a cExternalDeclaration
  val cDefault : 'a cStatement -> 'a -> 'a cStatement
  val cFDefExt : 'a cFunctionDef -> 'a cExternalDeclaration
  val cFunSpec : 'a cFunctionSpecifier -> 'a cDeclarationSpecifier
  val cGotoPtr : 'a cExpression -> 'a -> 'a cStatement
  val cIntType : 'a -> 'a cTypeSpecifier
  val cInteger : int -> cIntRepr -> cIntFlag flags -> cInteger
  val cOrAssOp : cAssignOp
  val cTypeDef : ident -> 'a -> 'a cTypeSpecifier
  val cTypedef : 'a -> 'a cStorageSpecifier
  val flagImag : cIntFlag
  val flagLong : cIntFlag
  val namedRef : ident -> sUERef
  val nodeInfo : positiona -> positiona * int -> namea -> nodeInfo
  val position : int -> abr_string -> int -> int -> positiona
  val fold_thy_shallow :
    ((unit -> unit compiler_env_config_ext * 'a) -> unit compiler_env_config_ext * 'a) ->
      (unit compiler_env_config_ext -> 'a -> 'a) ->
        (abr_string option -> all_meta list -> unit compiler_env_config_ext * 'a -> unit compiler_env_config_ext * 'a) -> fold_all_input -> unit compiler_env_config_ext * 'a -> unit compiler_env_config_ext * 'a
  val cAddAssOp : cAssignOp
  val cAndAssOp : cAssignOp
  val cArrDeclr : 'a cTypeQualifier list -> 'a cArraySize -> 'a -> 'a cDerivedDeclarator
  val cArrDesig : 'a cExpression -> 'a -> 'a cPartDesignator
  val cAssignOp : cAssignOp
  val cAttrQual : 'a cAttribute -> 'a cTypeQualifier
  val cBoolType : 'a -> 'a cTypeSpecifier
  val cCharType : 'a -> 'a cTypeSpecifier
  val cCompound : ident list -> 'a cCompoundBlockItem list -> 'a -> 'a cStatement
  val cDivAssOp : cAssignOp
  val cEnumType : 'a cEnumeration -> 'a -> 'a cTypeSpecifier
  val cFunDeclr : ((ident list), ('a cDeclaration list * bool)) either -> 'a cAttribute list -> 'a -> 'a cDerivedDeclarator
  val cInitExpr : 'a cExpression -> 'a -> 'a cInitializer
  val cInitList : ('a cPartDesignator list * 'a cInitializer) list -> 'a -> 'a cInitializer
  val cIntConst : cInteger -> 'a -> 'a cConstant
  val cLongType : 'a -> 'a cTypeSpecifier
  val cMulAssOp : cAssignOp
  val cPreDecOp : cUnaryOp
  val cPreIncOp : cUnaryOp
  val cPtrDeclr : 'a cTypeQualifier list -> 'a -> 'a cDerivedDeclarator
  val cRegister : 'a -> 'a cStorageSpecifier
  val cRmdAssOp : cAssignOp
  val cShlAssOp : cAssignOp
  val cShrAssOp : cAssignOp
  val cStatExpr : 'a cStatement -> 'a -> 'a cExpression
  val cStrConst : cString -> 'a -> 'a cConstant
  val cSubAssOp : cAssignOp
  val cTypeQual : 'a cTypeQualifier -> 'a cDeclarationSpecifier
  val cTypeSpec : 'a cTypeSpecifier -> 'a cDeclarationSpecifier
  val cUnionTag : cStructTag
  val cVoidType : 'a -> 'a cTypeSpecifier
  val cXorAssOp : cAssignOp
  val octalRepr : cIntRepr
  val rec_ctype :
    (base_inttype -> 'a) ->
      (base_inttype -> 'a) ->
        'a -> 'a -> (abr_string -> 'a) ->
                      (abr_string -> 'a) ->
                        (abr_string option -> 'a) -> ('b ctype -> 'a -> 'a) -> ('b ctype -> 'b option -> 'a -> 'a) -> (bool -> 'b -> 'a) -> (abr_string -> 'a) -> ('b ctype -> ('b ctype * 'a) list -> 'a -> 'a) -> 'a -> 'b ctype -> 'a
  val cAlignSpec : 'a cAlignmentSpecifier -> 'a cDeclarationSpecifier
  val cBlockDecl : 'a cDeclaration -> 'a cCompoundBlockItem
  val cBlockStmt : 'a cStatement -> 'a cCompoundBlockItem
  val cCharConst : cChar -> 'a -> 'a cConstant
  val cConstQual : 'a -> 'a cTypeQualifier
  val cFloatType : 'a -> 'a cTypeSpecifier
  val cNoArrSize : bool -> 'a cArraySize
  val cPostDecOp : cUnaryOp
  val cPostIncOp : cUnaryOp
  val cRestrQual : 'a -> 'a cTypeQualifier
  val cShortType : 'a -> 'a cTypeSpecifier
  val cStructTag : cStructTag
  val cUnsigType : 'a -> 'a cTypeSpecifier
  val cVolatQual : 'a -> 'a cTypeQualifier
  val noPosition : positiona
  val cAsmOperand : ident optiona -> 'a cStringLiteral -> 'a cExpression -> 'a -> 'a cAssemblyOperand
  val cAtomicQual : 'a -> 'a cTypeQualifier
  val cAtomicType : 'a cDeclaration -> 'a -> 'a cTypeSpecifier
  val cDoubleType : 'a -> 'a cTypeSpecifier
  val cFloatConst : cFloat -> 'a -> 'a cConstant
  val cInlineQual : 'a -> 'a cFunctionSpecifier
  val cInt128Type : 'a -> 'a cTypeSpecifier
  val cRangeDesig : 'a cExpression -> 'a cExpression -> 'a -> 'a cPartDesignator
  val cSignedType : 'a -> 'a cTypeSpecifier
  val cSizeofExpr : 'a cExpression -> 'a -> 'a cExpression
  val cSizeofType : 'a cDeclaration -> 'a -> 'a cExpression
  val cTranslUnit : 'a cExternalDeclaration list -> 'a -> 'a cTranslationUnit
  val cTypeOfExpr : 'a cExpression -> 'a -> 'a cTypeSpecifier
  val cTypeOfType : 'a cDeclaration -> 'a -> 'a cTypeSpecifier
  val map2_ctxt_term : (ocl_ctxt_term -> ocl_ctxt_term) -> all_meta_embedding -> all_meta_embedding
  val rec_Region : 'a -> (sourcePos -> sourcePos -> 'a) -> region -> 'a
  val rec_fnspec : (abr_string region_Wrap -> 'a) -> (abr_string region_Wrap -> 'a) -> (abr_string list -> 'a) -> 'a -> (gcc_attribute list -> 'a) -> fnspec -> 'a
  val anonymousRef : namea -> sUERef
  val cAlignAsExpr : 'a cExpression -> 'a -> 'a cAlignmentSpecifier
  val cAlignAsType : 'a cDeclaration -> 'a -> 'a cAlignmentSpecifier
  val cAlignofExpr : 'a cExpression -> 'a -> 'a cExpression
  val cAlignofType : 'a cDeclaration -> 'a -> 'a cExpression
  val cBuiltinExpr : 'a cBuiltinThing -> 'a cExpression
  val cComplexImag : 'a cExpression -> 'a -> 'a cExpression
  val cComplexReal : 'a cExpression -> 'a -> 'a cExpression
  val cComplexType : 'a -> 'a cTypeSpecifier
  val cCompoundLit : 'a cDeclaration -> ('a cPartDesignator list * 'a cInitializer) list -> 'a -> 'a cExpression
  val cLabAddrExpr : ident -> 'a -> 'a cExpression
  val cMemberDesig : ident -> 'a -> 'a cPartDesignator
  val cNonnullQual : 'a -> 'a cTypeQualifier
  val cStorageSpec : 'a cStorageSpecifier -> 'a cDeclarationSpecifier
  val flagLongLong : cIntFlag
  val flagUnsigned : cIntFlag
  val oidInit : internal_oid -> internal_oids
  val cBuiltinVaArg : 'a cExpression -> 'a cDeclaration -> 'a -> 'a cBuiltinThing
  val cNestedFunDef : 'a cFunctionDef -> 'a cCompoundBlockItem
  val cNoreturnQual : 'a -> 'a cFunctionSpecifier
  val cNullableQual : 'a -> 'a cTypeQualifier
  val cStaticAssert : 'a cExpression -> 'a cStringLiteral -> 'a -> 'a cDeclaration
  val clangCVersion : abr_string -> clangCVersion
  val isabelle_apply : abr_string -> abr_string list -> abr_string
  val builtinPosition : positiona
  val rec_ext_decl : (expr ctype * abr_string region_Wrap -> (expr ctype * abr_string region_Wrap) list -> fnspec list -> (block_item list) region_Wrap -> 'a) -> (declaration region_Wrap -> 'a) -> ext_decl -> 'a
  val rec_unoptype : 'a -> 'a -> 'a -> 'a -> unoptype -> 'a
  val cBuiltinOffsetOf : 'a cDeclaration -> 'a cPartDesignator list -> 'a -> 'a cBuiltinThing
  val internalPosition : positiona
  val cGenericSelection : 'a cExpression -> ('a cDeclaration optiona * 'a cExpression) list -> 'a -> 'a cExpression
  val check_export_code : ('a -> unit) -> ('a -> unit) -> ('a -> unit) -> (abr_string -> unit) -> (reporting * 'a) list -> abr_string -> unit
  val integer_to_digit16 : int -> abr_string
  val rec_SourcePos : (int -> abr_string -> int -> 'a) -> sourcePos -> 'a
  val rec_binoptype : 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> binoptype -> 'a
  val rec_more_info : (abr_string -> abr_string option -> 'a) -> 'a -> 'a -> more_info -> 'a
  val rec_statement :
    (expr -> expr -> 'a) ->
      (expr option -> expr -> expr list -> 'a) ->
        (expr -> 'a) ->
          (expr -> expr -> expr list -> 'a) ->
            ((block_item * 'b) list -> 'a) ->
              (expr -> abr_string region_Wrap option -> statement -> 'c -> 'a) ->
                (trappable -> statement -> 'c -> 'a) ->
                  (expr option -> 'a) ->
                    (expr -> expr list -> 'a) ->
                      'a -> 'a -> (expr -> statement -> statement -> 'c -> 'c -> 'a) ->
                                    (expr -> ((expr option) list * (block_item * 'b) list) list -> 'a) ->
                                      'a -> (abr_string -> 'a) ->
                                              (abr_string -> 'a) ->
                                                ((abr_string * abr_string) * ((statement * 'c) list * abr_string) -> 'a) ->
                                                  (bool -> asmblock -> 'a) -> (expr -> 'a) -> ((statement_node * 'a) region_Wrap -> 'c) -> (statement -> 'c -> 'b) -> (declaration region_Wrap -> 'b) -> statement -> 'c
  val rec_block_item :
    (expr -> expr -> 'a) ->
      (expr option -> expr -> expr list -> 'a) ->
        (expr -> 'a) ->
          (expr -> expr -> expr list -> 'a) ->
            ((block_item * 'b) list -> 'a) ->
              (expr -> abr_string region_Wrap option -> statement -> 'c -> 'a) ->
                (trappable -> statement -> 'c -> 'a) ->
                  (expr option -> 'a) ->
                    (expr -> expr list -> 'a) ->
                      'a -> 'a -> (expr -> statement -> statement -> 'c -> 'c -> 'a) ->
                                    (expr -> ((expr option) list * (block_item * 'b) list) list -> 'a) ->
                                      'a -> (abr_string -> 'a) ->
                                              (abr_string -> 'a) ->
                                                ((abr_string * abr_string) * ((statement * 'c) list * abr_string) -> 'a) ->
                                                  (bool -> asmblock -> 'a) -> (expr -> 'a) -> ((statement_node * 'a) region_Wrap -> 'c) -> (statement -> 'c -> 'b) -> (declaration region_Wrap -> 'b) -> block_item -> 'b
  val rec_statement_node :
    (expr -> expr -> 'a) ->
      (expr option -> expr -> expr list -> 'a) ->
        (expr -> 'a) ->
          (expr -> expr -> expr list -> 'a) ->
            ((block_item * 'b) list -> 'a) ->
              (expr -> abr_string region_Wrap option -> statement -> 'c -> 'a) ->
                (trappable -> statement -> 'c -> 'a) ->
                  (expr option -> 'a) ->
                    (expr -> expr list -> 'a) ->
                      'a -> 'a -> (expr -> statement -> statement -> 'c -> 'c -> 'a) ->
                                    (expr -> ((expr option) list * (block_item * 'b) list) list -> 'a) ->
                                      'a -> (abr_string -> 'a) ->
                                              (abr_string -> 'a) ->
                                                ((abr_string * abr_string) * ((statement * 'c) list * abr_string) -> 'a) ->
                                                  (bool -> asmblock -> 'a) -> (expr -> 'a) -> ((statement_node * 'a) region_Wrap -> 'c) -> (statement -> 'c -> 'b) -> (declaration region_Wrap -> 'b) -> statement_node -> 'a
  val rec_trappable : 'a -> 'a -> trappable -> 'a
  val d_output_sorry_dirty_update : (generation_lemma_mode option * bool -> generation_lemma_mode option * bool) -> 'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val d_ocl_semantics_update : (generation_semantics_ocl -> generation_semantics_ocl) -> 'a compiler_env_config_ext -> 'a compiler_env_config_ext
  val compiler_env_config_update : (unit compiler_env_config_ext -> unit compiler_env_config_ext) -> unit compiler_env_config_ext -> unit compiler_env_config_ext
  val of_Nila : abr_string
  val of_nata : 'a -> (abr_string -> 'b) -> Code_Numeral.natural -> 'b
  val compiler_env_config_reset_all : 'a compiler_env_config_ext -> unit compiler_env_config_ext * all_meta_embedding list
  val of_Consa : abr_string
  val of_Nonea : abr_string
  val of_Paira : abr_string
  val of_Somea : abr_string
  val of_boolb : (abr_string -> 'a) -> bool -> 'a
  val of_lista : ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> ('b -> 'a) -> 'b list -> 'a
  val of_paira : ('a -> 'b list -> 'c) -> (abr_string -> 'a) -> ('d -> 'b) -> ('e -> 'b) -> 'd * 'e -> 'c
  val of_unita : (abr_string -> 'a) -> unit -> 'a
  val rec_Region_Wrap : ('a -> region -> 'b) -> 'a region_Wrap -> 'b
  val rec_declaration :
    (expr ctype * (abr_string region_Wrap * (storage_class list * (initializer option * gcc_attribute list))) -> 'a) ->
      (abr_string region_Wrap -> (expr ctype * abr_string region_Wrap) list -> 'a) ->
        ((expr ctype * abr_string region_Wrap) list -> 'a) ->
          (expr ctype -> abr_string region_Wrap -> (expr ctype * abr_string option) list -> fnspec list -> 'a) -> ((abr_string option) region_Wrap -> (abr_string region_Wrap * expr option) list -> 'a) -> declaration -> 'a
  val cBuiltinTypesCompatible : 'a cDeclaration -> 'a cDeclaration -> 'a -> 'a cBuiltinThing
  val of_optiona : ('a -> 'b list -> 'a) -> (abr_string -> 'a) -> ('c -> 'b) -> 'c option -> 'a
  val of_string_gen : abr_string -> (abr_string -> abr_string) -> (abr_string -> abr_string) -> 'a -> (abr_string -> 'b) -> abr_string -> 'b
  val of_stringa : 'a -> (abr_string -> 'b) -> abr_string -> 'b
  val rec_base_inttype : 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> 'a -> base_inttype -> 'a
  val rec_gcc_attribute : (abr_string -> 'a) -> (abr_string -> expr list -> 'a) -> (abr_string -> 'a) -> gcc_attribute -> 'a
  val rec_storage_class : 'a -> 'a -> 'a -> 'a -> 'a -> storage_class -> 'a
  val rec_StringCvt_radix : 'a -> 'a -> 'a -> 'a -> stringCvt_radix -> 'a
  val of_string_b_a_s_ea : 'a -> (abr_string -> 'b) -> string_b_a_s_e -> 'b
  val compiler_env_configa : ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> (all_meta_embedding list * abr_string option) compiler_env_config_ext -> 'a
  val isabelle_of_compiler_env_config : ('a -> 'a list -> 'a) -> (abr_string -> 'a) -> (all_meta_embedding list * abr_string option) compiler_env_config_ext -> 'a
  val rec_Unsynchronized_ref : ('a -> 'b) -> 'a unsynchronized_ref -> 'b
  val rec_literalconstant_node : (int -> abr_string -> stringCvt_radix -> 'a) -> (abr_string -> 'a) -> literalconstant_node -> 'a
end = struct

datatype inta = Int_of_integer of int;

datatype num = One | Bit0 of num | Bit1 of num;

val one_inta : inta = Int_of_integer (1 : IntInf.int);

type 'a one = {one : 'a};
val one = #one : 'a one -> 'a;

val one_int = {one = one_inta} : inta one;

fun integer_of_int (Int_of_integer k) = k;

fun times_inta k l = Int_of_integer (integer_of_int k * integer_of_int l);

type 'a times = {times : 'a -> 'a -> 'a};
val times = #times : 'a times -> 'a -> 'a -> 'a;

type 'a power = {one_power : 'a one, times_power : 'a times};
val one_power = #one_power : 'a power -> 'a one;
val times_power = #times_power : 'a power -> 'a times;

val times_int = {times = times_inta} : inta times;

val power_int = {one_power = one_int, times_power = times_int} : inta power;

datatype nat = Nat of int;

fun integer_of_nat (Nat x) = x;

fun equal_nata m n = integer_of_nat m = integer_of_nat n;

type 'a equal = {equala : 'a -> 'a -> bool};
val equala = #equala : 'a equal -> 'a -> 'a -> bool;

val equal_nat = {equala = equal_nata} : nat equal;

val zero_nata : nat = Nat (0 : IntInf.int);

type 'a zero = {zero : 'a};
val zero = #zero : 'a zero -> 'a;

val zero_nat = {zero = zero_nata} : nat zero;

fun eq A_ a b = equala A_ a b;

fun equal_lista A_ [] (x21 :: x22) = false
  | equal_lista A_ (x21 :: x22) [] = false
  | equal_lista A_ (x21 :: x22) (y21 :: y22) = eq A_ x21 y21 andalso equal_lista A_ x22 y22
  | equal_lista A_ [] [] = true;

fun equal_list A_ = {equala = equal_lista A_} : ('a list) equal;

fun equal_bool p true = p
  | equal_bool p false = not p
  | equal_bool true p = p
  | equal_bool false p = not p;

datatype char = Chara of bool * bool * bool * bool * bool * bool * bool * bool;

fun equal_chara (Chara (x1, x2, x3, x4, x5, x6, x7, x8)) (Chara (y1, y2, y3, y4, y5, y6, y7, y8)) =
  equal_bool x1 y1 andalso (equal_bool x2 y2 andalso (equal_bool x3 y3 andalso (equal_bool x4 y4 andalso (equal_bool x5 y5 andalso (equal_bool x6 y6 andalso (equal_bool x7 y7 andalso equal_bool x8 y8))))));

val equal_char = {equala = equal_chara} : char equal;

fun shows_prec_char p c = (fn a => c :: a);

fun shows_string x = (fn a => x @ a);

fun shows_list_char cs = shows_string cs;

type 'a show = {shows_prec : nat -> 'a -> char list -> char list, shows_list : 'a list -> char list -> char list};
val shows_prec = #shows_prec : 'a show -> nat -> 'a -> char list -> char list;
val shows_list = #shows_list : 'a show -> 'a list -> char list -> char list;

val show_char = {shows_prec = shows_prec_char, shows_list = shows_list_char} : char show;

datatype string_b_a_s_e = ST of string | STa of int list;

val equal_integer = {equala = (fn a => fn b => a = b)} : int equal;

fun equal_string_b_a_s_e (ST x1) (STa x2) = false
  | equal_string_b_a_s_e (STa x2) (ST x1) = false
  | equal_string_b_a_s_e (STa x2) (STa y2) = equal_lista equal_integer x2 y2
  | equal_string_b_a_s_e (ST x1) (ST y1) = ((x1 : string) = y1);

datatype abr_string = SS_base of string_b_a_s_e | String_concatWith of abr_string * abr_string list;

fun equal_abr_stringa (SS_base x1) (String_concatWith (x21, x22)) = false
  | equal_abr_stringa (String_concatWith (x21, x22)) (SS_base x1) = false
  | equal_abr_stringa (String_concatWith (x21, x22)) (String_concatWith (y21, y22)) = equal_abr_stringa x21 y21 andalso equal_lista (equal_abr_string ()) x22 y22
  | equal_abr_stringa (SS_base x1) (SS_base y1) = equal_string_b_a_s_e x1 y1
and equal_abr_string () = {equala = equal_abr_stringa} : abr_string equal;
val equal_abr_string = equal_abr_string ();

datatype sourcePos = Ta of int * abr_string * int;

fun equal_SourcePos (Ta (x1, x2, x3)) (Ta (y1, y2, y3)) = x1 = y1 andalso (equal_abr_stringa x2 y2 andalso x3 = y3);

datatype region = Bogus | T of sourcePos * sourcePos;

fun equal_Region Bogus (T (x21, x22)) = false
  | equal_Region (T (x21, x22)) Bogus = false
  | equal_Region (T (x21, x22)) (T (y21, y22)) = equal_SourcePos x21 y21 andalso equal_SourcePos x22 y22
  | equal_Region Bogus Bogus = true;

datatype 'a region_Wrap = Tb of 'a * region;

fun equal_Region_Wrap A_ (Tb (x1, x2)) (Tb (y1, y2)) = eq A_ x1 y1 andalso equal_Region x2 y2;

datatype stringCvt_radix = BIN | OCT | DEC | HEX;

datatype literalconstant_node = NUMCONST of int * abr_string * stringCvt_radix | STRING_LIT of abr_string;

datatype 'a unsynchronized_ref = Unsynchronized_ref of 'a;

datatype more_info = MungedVar of abr_string * abr_string option | EnumC | FunctionName;

datatype binoptype = LogOr | LogAnd | Equals | NotEquals | BitwiseAnd | BitwiseOr | BitwiseXOr | Lt | Gt | Leq | Geq | Plus | Minus | Times | Divides | Modulus | RShift | LShift;

datatype unoptype = Negate | Not | Addr | BitNegate;

datatype base_inttype = Charb | Short | Inta | Long | LongLong | Double | Float;

datatype 'a ctype = Signed of base_inttype | Unsigned of base_inttype | Bool | PlainChar | StructTy of abr_string | UnionTy of abr_string | EnumTy of abr_string option | Ptr of 'a ctype | Array of 'a ctype * 'a option |
  Bitfield of bool * 'a | Identa of abr_string | Function of 'a ctype * 'a ctype list | Void;

datatype expr = E of expr_node region_Wrap
and designator = DesignE of expr | DesignFld of abr_string
and initializer = InitE of expr | InitList of (designator list * initializer) list
and expr_node = BinOp of binoptype * expr * expr | UnOp of unoptype * expr | CondExp of expr * expr * expr | Constant of literalconstant_node region_Wrap | Vara of abr_string * ((int ctype * more_info) option) unsynchronized_ref |
  StructDot of expr * abr_string | ArrayDeref of expr * expr | Deref of expr | TypeCast of expr ctype region_Wrap * expr | Sizeof of expr | SizeofTy of expr ctype region_Wrap | EFnCall of expr * expr list |
  CompLiteral of expr ctype * (designator list * initializer) list | Arbitrary of expr ctype | MKBOOL of expr;

fun equal_Unsynchronized_ref A_ (Unsynchronized_ref x) (Unsynchronized_ref ya) = eq A_ x ya;

fun equal_binoptype RShift LShift = false
  | equal_binoptype LShift RShift = false
  | equal_binoptype Modulus LShift = false
  | equal_binoptype LShift Modulus = false
  | equal_binoptype Modulus RShift = false
  | equal_binoptype RShift Modulus = false
  | equal_binoptype Divides LShift = false
  | equal_binoptype LShift Divides = false
  | equal_binoptype Divides RShift = false
  | equal_binoptype RShift Divides = false
  | equal_binoptype Divides Modulus = false
  | equal_binoptype Modulus Divides = false
  | equal_binoptype Times LShift = false
  | equal_binoptype LShift Times = false
  | equal_binoptype Times RShift = false
  | equal_binoptype RShift Times = false
  | equal_binoptype Times Modulus = false
  | equal_binoptype Modulus Times = false
  | equal_binoptype Times Divides = false
  | equal_binoptype Divides Times = false
  | equal_binoptype Minus LShift = false
  | equal_binoptype LShift Minus = false
  | equal_binoptype Minus RShift = false
  | equal_binoptype RShift Minus = false
  | equal_binoptype Minus Modulus = false
  | equal_binoptype Modulus Minus = false
  | equal_binoptype Minus Divides = false
  | equal_binoptype Divides Minus = false
  | equal_binoptype Minus Times = false
  | equal_binoptype Times Minus = false
  | equal_binoptype Plus LShift = false
  | equal_binoptype LShift Plus = false
  | equal_binoptype Plus RShift = false
  | equal_binoptype RShift Plus = false
  | equal_binoptype Plus Modulus = false
  | equal_binoptype Modulus Plus = false
  | equal_binoptype Plus Divides = false
  | equal_binoptype Divides Plus = false
  | equal_binoptype Plus Times = false
  | equal_binoptype Times Plus = false
  | equal_binoptype Plus Minus = false
  | equal_binoptype Minus Plus = false
  | equal_binoptype Geq LShift = false
  | equal_binoptype LShift Geq = false
  | equal_binoptype Geq RShift = false
  | equal_binoptype RShift Geq = false
  | equal_binoptype Geq Modulus = false
  | equal_binoptype Modulus Geq = false
  | equal_binoptype Geq Divides = false
  | equal_binoptype Divides Geq = false
  | equal_binoptype Geq Times = false
  | equal_binoptype Times Geq = false
  | equal_binoptype Geq Minus = false
  | equal_binoptype Minus Geq = false
  | equal_binoptype Geq Plus = false
  | equal_binoptype Plus Geq = false
  | equal_binoptype Leq LShift = false
  | equal_binoptype LShift Leq = false
  | equal_binoptype Leq RShift = false
  | equal_binoptype RShift Leq = false
  | equal_binoptype Leq Modulus = false
  | equal_binoptype Modulus Leq = false
  | equal_binoptype Leq Divides = false
  | equal_binoptype Divides Leq = false
  | equal_binoptype Leq Times = false
  | equal_binoptype Times Leq = false
  | equal_binoptype Leq Minus = false
  | equal_binoptype Minus Leq = false
  | equal_binoptype Leq Plus = false
  | equal_binoptype Plus Leq = false
  | equal_binoptype Leq Geq = false
  | equal_binoptype Geq Leq = false
  | equal_binoptype Gt LShift = false
  | equal_binoptype LShift Gt = false
  | equal_binoptype Gt RShift = false
  | equal_binoptype RShift Gt = false
  | equal_binoptype Gt Modulus = false
  | equal_binoptype Modulus Gt = false
  | equal_binoptype Gt Divides = false
  | equal_binoptype Divides Gt = false
  | equal_binoptype Gt Times = false
  | equal_binoptype Times Gt = false
  | equal_binoptype Gt Minus = false
  | equal_binoptype Minus Gt = false
  | equal_binoptype Gt Plus = false
  | equal_binoptype Plus Gt = false
  | equal_binoptype Gt Geq = false
  | equal_binoptype Geq Gt = false
  | equal_binoptype Gt Leq = false
  | equal_binoptype Leq Gt = false
  | equal_binoptype Lt LShift = false
  | equal_binoptype LShift Lt = false
  | equal_binoptype Lt RShift = false
  | equal_binoptype RShift Lt = false
  | equal_binoptype Lt Modulus = false
  | equal_binoptype Modulus Lt = false
  | equal_binoptype Lt Divides = false
  | equal_binoptype Divides Lt = false
  | equal_binoptype Lt Times = false
  | equal_binoptype Times Lt = false
  | equal_binoptype Lt Minus = false
  | equal_binoptype Minus Lt = false
  | equal_binoptype Lt Plus = false
  | equal_binoptype Plus Lt = false
  | equal_binoptype Lt Geq = false
  | equal_binoptype Geq Lt = false
  | equal_binoptype Lt Leq = false
  | equal_binoptype Leq Lt = false
  | equal_binoptype Lt Gt = false
  | equal_binoptype Gt Lt = false
  | equal_binoptype BitwiseXOr LShift = false
  | equal_binoptype LShift BitwiseXOr = false
  | equal_binoptype BitwiseXOr RShift = false
  | equal_binoptype RShift BitwiseXOr = false
  | equal_binoptype BitwiseXOr Modulus = false
  | equal_binoptype Modulus BitwiseXOr = false
  | equal_binoptype BitwiseXOr Divides = false
  | equal_binoptype Divides BitwiseXOr = false
  | equal_binoptype BitwiseXOr Times = false
  | equal_binoptype Times BitwiseXOr = false
  | equal_binoptype BitwiseXOr Minus = false
  | equal_binoptype Minus BitwiseXOr = false
  | equal_binoptype BitwiseXOr Plus = false
  | equal_binoptype Plus BitwiseXOr = false
  | equal_binoptype BitwiseXOr Geq = false
  | equal_binoptype Geq BitwiseXOr = false
  | equal_binoptype BitwiseXOr Leq = false
  | equal_binoptype Leq BitwiseXOr = false
  | equal_binoptype BitwiseXOr Gt = false
  | equal_binoptype Gt BitwiseXOr = false
  | equal_binoptype BitwiseXOr Lt = false
  | equal_binoptype Lt BitwiseXOr = false
  | equal_binoptype BitwiseOr LShift = false
  | equal_binoptype LShift BitwiseOr = false
  | equal_binoptype BitwiseOr RShift = false
  | equal_binoptype RShift BitwiseOr = false
  | equal_binoptype BitwiseOr Modulus = false
  | equal_binoptype Modulus BitwiseOr = false
  | equal_binoptype BitwiseOr Divides = false
  | equal_binoptype Divides BitwiseOr = false
  | equal_binoptype BitwiseOr Times = false
  | equal_binoptype Times BitwiseOr = false
  | equal_binoptype BitwiseOr Minus = false
  | equal_binoptype Minus BitwiseOr = false
  | equal_binoptype BitwiseOr Plus = false
  | equal_binoptype Plus BitwiseOr = false
  | equal_binoptype BitwiseOr Geq = false
  | equal_binoptype Geq BitwiseOr = false
  | equal_binoptype BitwiseOr Leq = false
  | equal_binoptype Leq BitwiseOr = false
  | equal_binoptype BitwiseOr Gt = false
  | equal_binoptype Gt BitwiseOr = false
  | equal_binoptype BitwiseOr Lt = false
  | equal_binoptype Lt BitwiseOr = false
  | equal_binoptype BitwiseOr BitwiseXOr = false
  | equal_binoptype BitwiseXOr BitwiseOr = false
  | equal_binoptype BitwiseAnd LShift = false
  | equal_binoptype LShift BitwiseAnd = false
  | equal_binoptype BitwiseAnd RShift = false
  | equal_binoptype RShift BitwiseAnd = false
  | equal_binoptype BitwiseAnd Modulus = false
  | equal_binoptype Modulus BitwiseAnd = false
  | equal_binoptype BitwiseAnd Divides = false
  | equal_binoptype Divides BitwiseAnd = false
  | equal_binoptype BitwiseAnd Times = false
  | equal_binoptype Times BitwiseAnd = false
  | equal_binoptype BitwiseAnd Minus = false
  | equal_binoptype Minus BitwiseAnd = false
  | equal_binoptype BitwiseAnd Plus = false
  | equal_binoptype Plus BitwiseAnd = false
  | equal_binoptype BitwiseAnd Geq = false
  | equal_binoptype Geq BitwiseAnd = false
  | equal_binoptype BitwiseAnd Leq = false
  | equal_binoptype Leq BitwiseAnd = false
  | equal_binoptype BitwiseAnd Gt = false
  | equal_binoptype Gt BitwiseAnd = false
  | equal_binoptype BitwiseAnd Lt = false
  | equal_binoptype Lt BitwiseAnd = false
  | equal_binoptype BitwiseAnd BitwiseXOr = false
  | equal_binoptype BitwiseXOr BitwiseAnd = false
  | equal_binoptype BitwiseAnd BitwiseOr = false
  | equal_binoptype BitwiseOr BitwiseAnd = false
  | equal_binoptype NotEquals LShift = false
  | equal_binoptype LShift NotEquals = false
  | equal_binoptype NotEquals RShift = false
  | equal_binoptype RShift NotEquals = false
  | equal_binoptype NotEquals Modulus = false
  | equal_binoptype Modulus NotEquals = false
  | equal_binoptype NotEquals Divides = false
  | equal_binoptype Divides NotEquals = false
  | equal_binoptype NotEquals Times = false
  | equal_binoptype Times NotEquals = false
  | equal_binoptype NotEquals Minus = false
  | equal_binoptype Minus NotEquals = false
  | equal_binoptype NotEquals Plus = false
  | equal_binoptype Plus NotEquals = false
  | equal_binoptype NotEquals Geq = false
  | equal_binoptype Geq NotEquals = false
  | equal_binoptype NotEquals Leq = false
  | equal_binoptype Leq NotEquals = false
  | equal_binoptype NotEquals Gt = false
  | equal_binoptype Gt NotEquals = false
  | equal_binoptype NotEquals Lt = false
  | equal_binoptype Lt NotEquals = false
  | equal_binoptype NotEquals BitwiseXOr = false
  | equal_binoptype BitwiseXOr NotEquals = false
  | equal_binoptype NotEquals BitwiseOr = false
  | equal_binoptype BitwiseOr NotEquals = false
  | equal_binoptype NotEquals BitwiseAnd = false
  | equal_binoptype BitwiseAnd NotEquals = false
  | equal_binoptype Equals LShift = false
  | equal_binoptype LShift Equals = false
  | equal_binoptype Equals RShift = false
  | equal_binoptype RShift Equals = false
  | equal_binoptype Equals Modulus = false
  | equal_binoptype Modulus Equals = false
  | equal_binoptype Equals Divides = false
  | equal_binoptype Divides Equals = false
  | equal_binoptype Equals Times = false
  | equal_binoptype Times Equals = false
  | equal_binoptype Equals Minus = false
  | equal_binoptype Minus Equals = false
  | equal_binoptype Equals Plus = false
  | equal_binoptype Plus Equals = false
  | equal_binoptype Equals Geq = false
  | equal_binoptype Geq Equals = false
  | equal_binoptype Equals Leq = false
  | equal_binoptype Leq Equals = false
  | equal_binoptype Equals Gt = false
  | equal_binoptype Gt Equals = false
  | equal_binoptype Equals Lt = false
  | equal_binoptype Lt Equals = false
  | equal_binoptype Equals BitwiseXOr = false
  | equal_binoptype BitwiseXOr Equals = false
  | equal_binoptype Equals BitwiseOr = false
  | equal_binoptype BitwiseOr Equals = false
  | equal_binoptype Equals BitwiseAnd = false
  | equal_binoptype BitwiseAnd Equals = false
  | equal_binoptype Equals NotEquals = false
  | equal_binoptype NotEquals Equals = false
  | equal_binoptype LogAnd LShift = false
  | equal_binoptype LShift LogAnd = false
  | equal_binoptype LogAnd RShift = false
  | equal_binoptype RShift LogAnd = false
  | equal_binoptype LogAnd Modulus = false
  | equal_binoptype Modulus LogAnd = false
  | equal_binoptype LogAnd Divides = false
  | equal_binoptype Divides LogAnd = false
  | equal_binoptype LogAnd Times = false
  | equal_binoptype Times LogAnd = false
  | equal_binoptype LogAnd Minus = false
  | equal_binoptype Minus LogAnd = false
  | equal_binoptype LogAnd Plus = false
  | equal_binoptype Plus LogAnd = false
  | equal_binoptype LogAnd Geq = false
  | equal_binoptype Geq LogAnd = false
  | equal_binoptype LogAnd Leq = false
  | equal_binoptype Leq LogAnd = false
  | equal_binoptype LogAnd Gt = false
  | equal_binoptype Gt LogAnd = false
  | equal_binoptype LogAnd Lt = false
  | equal_binoptype Lt LogAnd = false
  | equal_binoptype LogAnd BitwiseXOr = false
  | equal_binoptype BitwiseXOr LogAnd = false
  | equal_binoptype LogAnd BitwiseOr = false
  | equal_binoptype BitwiseOr LogAnd = false
  | equal_binoptype LogAnd BitwiseAnd = false
  | equal_binoptype BitwiseAnd LogAnd = false
  | equal_binoptype LogAnd NotEquals = false
  | equal_binoptype NotEquals LogAnd = false
  | equal_binoptype LogAnd Equals = false
  | equal_binoptype Equals LogAnd = false
  | equal_binoptype LogOr LShift = false
  | equal_binoptype LShift LogOr = false
  | equal_binoptype LogOr RShift = false
  | equal_binoptype RShift LogOr = false
  | equal_binoptype LogOr Modulus = false
  | equal_binoptype Modulus LogOr = false
  | equal_binoptype LogOr Divides = false
  | equal_binoptype Divides LogOr = false
  | equal_binoptype LogOr Times = false
  | equal_binoptype Times LogOr = false
  | equal_binoptype LogOr Minus = false
  | equal_binoptype Minus LogOr = false
  | equal_binoptype LogOr Plus = false
  | equal_binoptype Plus LogOr = false
  | equal_binoptype LogOr Geq = false
  | equal_binoptype Geq LogOr = false
  | equal_binoptype LogOr Leq = false
  | equal_binoptype Leq LogOr = false
  | equal_binoptype LogOr Gt = false
  | equal_binoptype Gt LogOr = false
  | equal_binoptype LogOr Lt = false
  | equal_binoptype Lt LogOr = false
  | equal_binoptype LogOr BitwiseXOr = false
  | equal_binoptype BitwiseXOr LogOr = false
  | equal_binoptype LogOr BitwiseOr = false
  | equal_binoptype BitwiseOr LogOr = false
  | equal_binoptype LogOr BitwiseAnd = false
  | equal_binoptype BitwiseAnd LogOr = false
  | equal_binoptype LogOr NotEquals = false
  | equal_binoptype NotEquals LogOr = false
  | equal_binoptype LogOr Equals = false
  | equal_binoptype Equals LogOr = false
  | equal_binoptype LogOr LogAnd = false
  | equal_binoptype LogAnd LogOr = false
  | equal_binoptype LShift LShift = true
  | equal_binoptype RShift RShift = true
  | equal_binoptype Modulus Modulus = true
  | equal_binoptype Divides Divides = true
  | equal_binoptype Times Times = true
  | equal_binoptype Minus Minus = true
  | equal_binoptype Plus Plus = true
  | equal_binoptype Geq Geq = true
  | equal_binoptype Leq Leq = true
  | equal_binoptype Gt Gt = true
  | equal_binoptype Lt Lt = true
  | equal_binoptype BitwiseXOr BitwiseXOr = true
  | equal_binoptype BitwiseOr BitwiseOr = true
  | equal_binoptype BitwiseAnd BitwiseAnd = true
  | equal_binoptype NotEquals NotEquals = true
  | equal_binoptype Equals Equals = true
  | equal_binoptype LogAnd LogAnd = true
  | equal_binoptype LogOr LogOr = true;

fun equal_unoptype Addr BitNegate = false
  | equal_unoptype BitNegate Addr = false
  | equal_unoptype Not BitNegate = false
  | equal_unoptype BitNegate Not = false
  | equal_unoptype Not Addr = false
  | equal_unoptype Addr Not = false
  | equal_unoptype Negate BitNegate = false
  | equal_unoptype BitNegate Negate = false
  | equal_unoptype Negate Addr = false
  | equal_unoptype Addr Negate = false
  | equal_unoptype Negate Not = false
  | equal_unoptype Not Negate = false
  | equal_unoptype BitNegate BitNegate = true
  | equal_unoptype Addr Addr = true
  | equal_unoptype Not Not = true
  | equal_unoptype Negate Negate = true;

fun equal_base_inttype Double Float = false
  | equal_base_inttype Float Double = false
  | equal_base_inttype LongLong Float = false
  | equal_base_inttype Float LongLong = false
  | equal_base_inttype LongLong Double = false
  | equal_base_inttype Double LongLong = false
  | equal_base_inttype Long Float = false
  | equal_base_inttype Float Long = false
  | equal_base_inttype Long Double = false
  | equal_base_inttype Double Long = false
  | equal_base_inttype Long LongLong = false
  | equal_base_inttype LongLong Long = false
  | equal_base_inttype Inta Float = false
  | equal_base_inttype Float Inta = false
  | equal_base_inttype Inta Double = false
  | equal_base_inttype Double Inta = false
  | equal_base_inttype Inta LongLong = false
  | equal_base_inttype LongLong Inta = false
  | equal_base_inttype Inta Long = false
  | equal_base_inttype Long Inta = false
  | equal_base_inttype Short Float = false
  | equal_base_inttype Float Short = false
  | equal_base_inttype Short Double = false
  | equal_base_inttype Double Short = false
  | equal_base_inttype Short LongLong = false
  | equal_base_inttype LongLong Short = false
  | equal_base_inttype Short Long = false
  | equal_base_inttype Long Short = false
  | equal_base_inttype Short Inta = false
  | equal_base_inttype Inta Short = false
  | equal_base_inttype Charb Float = false
  | equal_base_inttype Float Charb = false
  | equal_base_inttype Charb Double = false
  | equal_base_inttype Double Charb = false
  | equal_base_inttype Charb LongLong = false
  | equal_base_inttype LongLong Charb = false
  | equal_base_inttype Charb Long = false
  | equal_base_inttype Long Charb = false
  | equal_base_inttype Charb Inta = false
  | equal_base_inttype Inta Charb = false
  | equal_base_inttype Charb Short = false
  | equal_base_inttype Short Charb = false
  | equal_base_inttype Float Float = true
  | equal_base_inttype Double Double = true
  | equal_base_inttype LongLong LongLong = true
  | equal_base_inttype Long Long = true
  | equal_base_inttype Inta Inta = true
  | equal_base_inttype Short Short = true
  | equal_base_inttype Charb Charb = true;

fun equal_optiona A_ NONE (SOME x2) = false
  | equal_optiona A_ (SOME x2) NONE = false
  | equal_optiona A_ (SOME x2) (SOME y2) = eq A_ x2 y2
  | equal_optiona A_ NONE NONE = true;

fun equal_ctypea A_ (Function (x121, x122)) Void = false
  | equal_ctypea A_ Void (Function (x121, x122)) = false
  | equal_ctypea A_ (Identa x11) Void = false
  | equal_ctypea A_ Void (Identa x11) = false
  | equal_ctypea A_ (Identa x11) (Function (x121, x122)) = false
  | equal_ctypea A_ (Function (x121, x122)) (Identa x11) = false
  | equal_ctypea A_ (Bitfield (x101, x102)) Void = false
  | equal_ctypea A_ Void (Bitfield (x101, x102)) = false
  | equal_ctypea A_ (Bitfield (x101, x102)) (Function (x121, x122)) = false
  | equal_ctypea A_ (Function (x121, x122)) (Bitfield (x101, x102)) = false
  | equal_ctypea A_ (Bitfield (x101, x102)) (Identa x11) = false
  | equal_ctypea A_ (Identa x11) (Bitfield (x101, x102)) = false
  | equal_ctypea A_ (Array (x91, x92)) Void = false
  | equal_ctypea A_ Void (Array (x91, x92)) = false
  | equal_ctypea A_ (Array (x91, x92)) (Function (x121, x122)) = false
  | equal_ctypea A_ (Function (x121, x122)) (Array (x91, x92)) = false
  | equal_ctypea A_ (Array (x91, x92)) (Identa x11) = false
  | equal_ctypea A_ (Identa x11) (Array (x91, x92)) = false
  | equal_ctypea A_ (Array (x91, x92)) (Bitfield (x101, x102)) = false
  | equal_ctypea A_ (Bitfield (x101, x102)) (Array (x91, x92)) = false
  | equal_ctypea A_ (Ptr x8) Void = false
  | equal_ctypea A_ Void (Ptr x8) = false
  | equal_ctypea A_ (Ptr x8) (Function (x121, x122)) = false
  | equal_ctypea A_ (Function (x121, x122)) (Ptr x8) = false
  | equal_ctypea A_ (Ptr x8) (Identa x11) = false
  | equal_ctypea A_ (Identa x11) (Ptr x8) = false
  | equal_ctypea A_ (Ptr x8) (Bitfield (x101, x102)) = false
  | equal_ctypea A_ (Bitfield (x101, x102)) (Ptr x8) = false
  | equal_ctypea A_ (Ptr x8) (Array (x91, x92)) = false
  | equal_ctypea A_ (Array (x91, x92)) (Ptr x8) = false
  | equal_ctypea A_ (EnumTy x7) Void = false
  | equal_ctypea A_ Void (EnumTy x7) = false
  | equal_ctypea A_ (EnumTy x7) (Function (x121, x122)) = false
  | equal_ctypea A_ (Function (x121, x122)) (EnumTy x7) = false
  | equal_ctypea A_ (EnumTy x7) (Identa x11) = false
  | equal_ctypea A_ (Identa x11) (EnumTy x7) = false
  | equal_ctypea A_ (EnumTy x7) (Bitfield (x101, x102)) = false
  | equal_ctypea A_ (Bitfield (x101, x102)) (EnumTy x7) = false
  | equal_ctypea A_ (EnumTy x7) (Array (x91, x92)) = false
  | equal_ctypea A_ (Array (x91, x92)) (EnumTy x7) = false
  | equal_ctypea A_ (EnumTy x7) (Ptr x8) = false
  | equal_ctypea A_ (Ptr x8) (EnumTy x7) = false
  | equal_ctypea A_ (UnionTy x6) Void = false
  | equal_ctypea A_ Void (UnionTy x6) = false
  | equal_ctypea A_ (UnionTy x6) (Function (x121, x122)) = false
  | equal_ctypea A_ (Function (x121, x122)) (UnionTy x6) = false
  | equal_ctypea A_ (UnionTy x6) (Identa x11) = false
  | equal_ctypea A_ (Identa x11) (UnionTy x6) = false
  | equal_ctypea A_ (UnionTy x6) (Bitfield (x101, x102)) = false
  | equal_ctypea A_ (Bitfield (x101, x102)) (UnionTy x6) = false
  | equal_ctypea A_ (UnionTy x6) (Array (x91, x92)) = false
  | equal_ctypea A_ (Array (x91, x92)) (UnionTy x6) = false
  | equal_ctypea A_ (UnionTy x6) (Ptr x8) = false
  | equal_ctypea A_ (Ptr x8) (UnionTy x6) = false
  | equal_ctypea A_ (UnionTy x6) (EnumTy x7) = false
  | equal_ctypea A_ (EnumTy x7) (UnionTy x6) = false
  | equal_ctypea A_ (StructTy x5) Void = false
  | equal_ctypea A_ Void (StructTy x5) = false
  | equal_ctypea A_ (StructTy x5) (Function (x121, x122)) = false
  | equal_ctypea A_ (Function (x121, x122)) (StructTy x5) = false
  | equal_ctypea A_ (StructTy x5) (Identa x11) = false
  | equal_ctypea A_ (Identa x11) (StructTy x5) = false
  | equal_ctypea A_ (StructTy x5) (Bitfield (x101, x102)) = false
  | equal_ctypea A_ (Bitfield (x101, x102)) (StructTy x5) = false
  | equal_ctypea A_ (StructTy x5) (Array (x91, x92)) = false
  | equal_ctypea A_ (Array (x91, x92)) (StructTy x5) = false
  | equal_ctypea A_ (StructTy x5) (Ptr x8) = false
  | equal_ctypea A_ (Ptr x8) (StructTy x5) = false
  | equal_ctypea A_ (StructTy x5) (EnumTy x7) = false
  | equal_ctypea A_ (EnumTy x7) (StructTy x5) = false
  | equal_ctypea A_ (StructTy x5) (UnionTy x6) = false
  | equal_ctypea A_ (UnionTy x6) (StructTy x5) = false
  | equal_ctypea A_ PlainChar Void = false
  | equal_ctypea A_ Void PlainChar = false
  | equal_ctypea A_ PlainChar (Function (x121, x122)) = false
  | equal_ctypea A_ (Function (x121, x122)) PlainChar = false
  | equal_ctypea A_ PlainChar (Identa x11) = false
  | equal_ctypea A_ (Identa x11) PlainChar = false
  | equal_ctypea A_ PlainChar (Bitfield (x101, x102)) = false
  | equal_ctypea A_ (Bitfield (x101, x102)) PlainChar = false
  | equal_ctypea A_ PlainChar (Array (x91, x92)) = false
  | equal_ctypea A_ (Array (x91, x92)) PlainChar = false
  | equal_ctypea A_ PlainChar (Ptr x8) = false
  | equal_ctypea A_ (Ptr x8) PlainChar = false
  | equal_ctypea A_ PlainChar (EnumTy x7) = false
  | equal_ctypea A_ (EnumTy x7) PlainChar = false
  | equal_ctypea A_ PlainChar (UnionTy x6) = false
  | equal_ctypea A_ (UnionTy x6) PlainChar = false
  | equal_ctypea A_ PlainChar (StructTy x5) = false
  | equal_ctypea A_ (StructTy x5) PlainChar = false
  | equal_ctypea A_ Bool Void = false
  | equal_ctypea A_ Void Bool = false
  | equal_ctypea A_ Bool (Function (x121, x122)) = false
  | equal_ctypea A_ (Function (x121, x122)) Bool = false
  | equal_ctypea A_ Bool (Identa x11) = false
  | equal_ctypea A_ (Identa x11) Bool = false
  | equal_ctypea A_ Bool (Bitfield (x101, x102)) = false
  | equal_ctypea A_ (Bitfield (x101, x102)) Bool = false
  | equal_ctypea A_ Bool (Array (x91, x92)) = false
  | equal_ctypea A_ (Array (x91, x92)) Bool = false
  | equal_ctypea A_ Bool (Ptr x8) = false
  | equal_ctypea A_ (Ptr x8) Bool = false
  | equal_ctypea A_ Bool (EnumTy x7) = false
  | equal_ctypea A_ (EnumTy x7) Bool = false
  | equal_ctypea A_ Bool (UnionTy x6) = false
  | equal_ctypea A_ (UnionTy x6) Bool = false
  | equal_ctypea A_ Bool (StructTy x5) = false
  | equal_ctypea A_ (StructTy x5) Bool = false
  | equal_ctypea A_ Bool PlainChar = false
  | equal_ctypea A_ PlainChar Bool = false
  | equal_ctypea A_ (Unsigned x2) Void = false
  | equal_ctypea A_ Void (Unsigned x2) = false
  | equal_ctypea A_ (Unsigned x2) (Function (x121, x122)) = false
  | equal_ctypea A_ (Function (x121, x122)) (Unsigned x2) = false
  | equal_ctypea A_ (Unsigned x2) (Identa x11) = false
  | equal_ctypea A_ (Identa x11) (Unsigned x2) = false
  | equal_ctypea A_ (Unsigned x2) (Bitfield (x101, x102)) = false
  | equal_ctypea A_ (Bitfield (x101, x102)) (Unsigned x2) = false
  | equal_ctypea A_ (Unsigned x2) (Array (x91, x92)) = false
  | equal_ctypea A_ (Array (x91, x92)) (Unsigned x2) = false
  | equal_ctypea A_ (Unsigned x2) (Ptr x8) = false
  | equal_ctypea A_ (Ptr x8) (Unsigned x2) = false
  | equal_ctypea A_ (Unsigned x2) (EnumTy x7) = false
  | equal_ctypea A_ (EnumTy x7) (Unsigned x2) = false
  | equal_ctypea A_ (Unsigned x2) (UnionTy x6) = false
  | equal_ctypea A_ (UnionTy x6) (Unsigned x2) = false
  | equal_ctypea A_ (Unsigned x2) (StructTy x5) = false
  | equal_ctypea A_ (StructTy x5) (Unsigned x2) = false
  | equal_ctypea A_ (Unsigned x2) PlainChar = false
  | equal_ctypea A_ PlainChar (Unsigned x2) = false
  | equal_ctypea A_ (Unsigned x2) Bool = false
  | equal_ctypea A_ Bool (Unsigned x2) = false
  | equal_ctypea A_ (Signed x1) Void = false
  | equal_ctypea A_ Void (Signed x1) = false
  | equal_ctypea A_ (Signed x1) (Function (x121, x122)) = false
  | equal_ctypea A_ (Function (x121, x122)) (Signed x1) = false
  | equal_ctypea A_ (Signed x1) (Identa x11) = false
  | equal_ctypea A_ (Identa x11) (Signed x1) = false
  | equal_ctypea A_ (Signed x1) (Bitfield (x101, x102)) = false
  | equal_ctypea A_ (Bitfield (x101, x102)) (Signed x1) = false
  | equal_ctypea A_ (Signed x1) (Array (x91, x92)) = false
  | equal_ctypea A_ (Array (x91, x92)) (Signed x1) = false
  | equal_ctypea A_ (Signed x1) (Ptr x8) = false
  | equal_ctypea A_ (Ptr x8) (Signed x1) = false
  | equal_ctypea A_ (Signed x1) (EnumTy x7) = false
  | equal_ctypea A_ (EnumTy x7) (Signed x1) = false
  | equal_ctypea A_ (Signed x1) (UnionTy x6) = false
  | equal_ctypea A_ (UnionTy x6) (Signed x1) = false
  | equal_ctypea A_ (Signed x1) (StructTy x5) = false
  | equal_ctypea A_ (StructTy x5) (Signed x1) = false
  | equal_ctypea A_ (Signed x1) PlainChar = false
  | equal_ctypea A_ PlainChar (Signed x1) = false
  | equal_ctypea A_ (Signed x1) Bool = false
  | equal_ctypea A_ Bool (Signed x1) = false
  | equal_ctypea A_ (Signed x1) (Unsigned x2) = false
  | equal_ctypea A_ (Unsigned x2) (Signed x1) = false
  | equal_ctypea A_ (Function (x121, x122)) (Function (y121, y122)) = equal_ctypea A_ x121 y121 andalso equal_lista (equal_ctype A_) x122 y122
  | equal_ctypea A_ (Identa x11) (Identa y11) = equal_abr_stringa x11 y11
  | equal_ctypea A_ (Bitfield (x101, x102)) (Bitfield (y101, y102)) = equal_bool x101 y101 andalso eq A_ x102 y102
  | equal_ctypea A_ (Array (x91, x92)) (Array (y91, y92)) = equal_ctypea A_ x91 y91 andalso equal_optiona A_ x92 y92
  | equal_ctypea A_ (Ptr x8) (Ptr y8) = equal_ctypea A_ x8 y8
  | equal_ctypea A_ (EnumTy x7) (EnumTy y7) = equal_optiona equal_abr_string x7 y7
  | equal_ctypea A_ (UnionTy x6) (UnionTy y6) = equal_abr_stringa x6 y6
  | equal_ctypea A_ (StructTy x5) (StructTy y5) = equal_abr_stringa x5 y5
  | equal_ctypea A_ (Unsigned x2) (Unsigned y2) = equal_base_inttype x2 y2
  | equal_ctypea A_ (Signed x1) (Signed y1) = equal_base_inttype x1 y1
  | equal_ctypea A_ Void Void = true
  | equal_ctypea A_ PlainChar PlainChar = true
  | equal_ctypea A_ Bool Bool = true
and equal_ctype A_ = {equala = equal_ctypea A_} : 'a ctype equal;

fun equal_StringCvt_radix DEC HEX = false
  | equal_StringCvt_radix HEX DEC = false
  | equal_StringCvt_radix OCT HEX = false
  | equal_StringCvt_radix HEX OCT = false
  | equal_StringCvt_radix OCT DEC = false
  | equal_StringCvt_radix DEC OCT = false
  | equal_StringCvt_radix BIN HEX = false
  | equal_StringCvt_radix HEX BIN = false
  | equal_StringCvt_radix BIN DEC = false
  | equal_StringCvt_radix DEC BIN = false
  | equal_StringCvt_radix BIN OCT = false
  | equal_StringCvt_radix OCT BIN = false
  | equal_StringCvt_radix HEX HEX = true
  | equal_StringCvt_radix DEC DEC = true
  | equal_StringCvt_radix OCT OCT = true
  | equal_StringCvt_radix BIN BIN = true;

fun equal_literalconstant_nodea (NUMCONST (x11, x12, x13)) (STRING_LIT x2) = false
  | equal_literalconstant_nodea (STRING_LIT x2) (NUMCONST (x11, x12, x13)) = false
  | equal_literalconstant_nodea (STRING_LIT x2) (STRING_LIT y2) = equal_abr_stringa x2 y2
  | equal_literalconstant_nodea (NUMCONST (x11, x12, x13)) (NUMCONST (y11, y12, y13)) = x11 = y11 andalso (equal_abr_stringa x12 y12 andalso equal_StringCvt_radix x13 y13);

val equal_literalconstant_node = {equala = equal_literalconstant_nodea} : literalconstant_node equal;

fun equal_proda A_ B_ (x1, x2) (y1, y2) = eq A_ x1 y1 andalso eq B_ x2 y2;

fun equal_prod A_ B_ = {equala = equal_proda A_ B_} : ('a * 'b) equal;

fun equal_more_infoa EnumC FunctionName = false
  | equal_more_infoa FunctionName EnumC = false
  | equal_more_infoa (MungedVar (x11, x12)) FunctionName = false
  | equal_more_infoa FunctionName (MungedVar (x11, x12)) = false
  | equal_more_infoa (MungedVar (x11, x12)) EnumC = false
  | equal_more_infoa EnumC (MungedVar (x11, x12)) = false
  | equal_more_infoa (MungedVar (x11, x12)) (MungedVar (y11, y12)) = equal_abr_stringa x11 y11 andalso equal_optiona equal_abr_string x12 y12
  | equal_more_infoa FunctionName FunctionName = true
  | equal_more_infoa EnumC EnumC = true;

val equal_more_info = {equala = equal_more_infoa} : more_info equal;

fun equal_option A_ = {equala = equal_optiona A_} : ('a option) equal;

fun equal_expr () = {equala = equal_expra} : expr equal
and equal_expr_nodea (Arbitrary x14) (MKBOOL x15) = false
  | equal_expr_nodea (MKBOOL x15) (Arbitrary x14) = false
  | equal_expr_nodea (CompLiteral (x131, x132)) (MKBOOL x15) = false
  | equal_expr_nodea (MKBOOL x15) (CompLiteral (x131, x132)) = false
  | equal_expr_nodea (CompLiteral (x131, x132)) (Arbitrary x14) = false
  | equal_expr_nodea (Arbitrary x14) (CompLiteral (x131, x132)) = false
  | equal_expr_nodea (EFnCall (x121, x122)) (MKBOOL x15) = false
  | equal_expr_nodea (MKBOOL x15) (EFnCall (x121, x122)) = false
  | equal_expr_nodea (EFnCall (x121, x122)) (Arbitrary x14) = false
  | equal_expr_nodea (Arbitrary x14) (EFnCall (x121, x122)) = false
  | equal_expr_nodea (EFnCall (x121, x122)) (CompLiteral (x131, x132)) = false
  | equal_expr_nodea (CompLiteral (x131, x132)) (EFnCall (x121, x122)) = false
  | equal_expr_nodea (SizeofTy x11a) (MKBOOL x15) = false
  | equal_expr_nodea (MKBOOL x15) (SizeofTy x11a) = false
  | equal_expr_nodea (SizeofTy x11a) (Arbitrary x14) = false
  | equal_expr_nodea (Arbitrary x14) (SizeofTy x11a) = false
  | equal_expr_nodea (SizeofTy x11a) (CompLiteral (x131, x132)) = false
  | equal_expr_nodea (CompLiteral (x131, x132)) (SizeofTy x11a) = false
  | equal_expr_nodea (SizeofTy x11a) (EFnCall (x121, x122)) = false
  | equal_expr_nodea (EFnCall (x121, x122)) (SizeofTy x11a) = false
  | equal_expr_nodea (Sizeof x10) (MKBOOL x15) = false
  | equal_expr_nodea (MKBOOL x15) (Sizeof x10) = false
  | equal_expr_nodea (Sizeof x10) (Arbitrary x14) = false
  | equal_expr_nodea (Arbitrary x14) (Sizeof x10) = false
  | equal_expr_nodea (Sizeof x10) (CompLiteral (x131, x132)) = false
  | equal_expr_nodea (CompLiteral (x131, x132)) (Sizeof x10) = false
  | equal_expr_nodea (Sizeof x10) (EFnCall (x121, x122)) = false
  | equal_expr_nodea (EFnCall (x121, x122)) (Sizeof x10) = false
  | equal_expr_nodea (Sizeof x10) (SizeofTy x11a) = false
  | equal_expr_nodea (SizeofTy x11a) (Sizeof x10) = false
  | equal_expr_nodea (TypeCast (x91, x92)) (MKBOOL x15) = false
  | equal_expr_nodea (MKBOOL x15) (TypeCast (x91, x92)) = false
  | equal_expr_nodea (TypeCast (x91, x92)) (Arbitrary x14) = false
  | equal_expr_nodea (Arbitrary x14) (TypeCast (x91, x92)) = false
  | equal_expr_nodea (TypeCast (x91, x92)) (CompLiteral (x131, x132)) = false
  | equal_expr_nodea (CompLiteral (x131, x132)) (TypeCast (x91, x92)) = false
  | equal_expr_nodea (TypeCast (x91, x92)) (EFnCall (x121, x122)) = false
  | equal_expr_nodea (EFnCall (x121, x122)) (TypeCast (x91, x92)) = false
  | equal_expr_nodea (TypeCast (x91, x92)) (SizeofTy x11a) = false
  | equal_expr_nodea (SizeofTy x11a) (TypeCast (x91, x92)) = false
  | equal_expr_nodea (TypeCast (x91, x92)) (Sizeof x10) = false
  | equal_expr_nodea (Sizeof x10) (TypeCast (x91, x92)) = false
  | equal_expr_nodea (Deref x8) (MKBOOL x15) = false
  | equal_expr_nodea (MKBOOL x15) (Deref x8) = false
  | equal_expr_nodea (Deref x8) (Arbitrary x14) = false
  | equal_expr_nodea (Arbitrary x14) (Deref x8) = false
  | equal_expr_nodea (Deref x8) (CompLiteral (x131, x132)) = false
  | equal_expr_nodea (CompLiteral (x131, x132)) (Deref x8) = false
  | equal_expr_nodea (Deref x8) (EFnCall (x121, x122)) = false
  | equal_expr_nodea (EFnCall (x121, x122)) (Deref x8) = false
  | equal_expr_nodea (Deref x8) (SizeofTy x11a) = false
  | equal_expr_nodea (SizeofTy x11a) (Deref x8) = false
  | equal_expr_nodea (Deref x8) (Sizeof x10) = false
  | equal_expr_nodea (Sizeof x10) (Deref x8) = false
  | equal_expr_nodea (Deref x8) (TypeCast (x91, x92)) = false
  | equal_expr_nodea (TypeCast (x91, x92)) (Deref x8) = false
  | equal_expr_nodea (ArrayDeref (x71, x72)) (MKBOOL x15) = false
  | equal_expr_nodea (MKBOOL x15) (ArrayDeref (x71, x72)) = false
  | equal_expr_nodea (ArrayDeref (x71, x72)) (Arbitrary x14) = false
  | equal_expr_nodea (Arbitrary x14) (ArrayDeref (x71, x72)) = false
  | equal_expr_nodea (ArrayDeref (x71, x72)) (CompLiteral (x131, x132)) = false
  | equal_expr_nodea (CompLiteral (x131, x132)) (ArrayDeref (x71, x72)) = false
  | equal_expr_nodea (ArrayDeref (x71, x72)) (EFnCall (x121, x122)) = false
  | equal_expr_nodea (EFnCall (x121, x122)) (ArrayDeref (x71, x72)) = false
  | equal_expr_nodea (ArrayDeref (x71, x72)) (SizeofTy x11a) = false
  | equal_expr_nodea (SizeofTy x11a) (ArrayDeref (x71, x72)) = false
  | equal_expr_nodea (ArrayDeref (x71, x72)) (Sizeof x10) = false
  | equal_expr_nodea (Sizeof x10) (ArrayDeref (x71, x72)) = false
  | equal_expr_nodea (ArrayDeref (x71, x72)) (TypeCast (x91, x92)) = false
  | equal_expr_nodea (TypeCast (x91, x92)) (ArrayDeref (x71, x72)) = false
  | equal_expr_nodea (ArrayDeref (x71, x72)) (Deref x8) = false
  | equal_expr_nodea (Deref x8) (ArrayDeref (x71, x72)) = false
  | equal_expr_nodea (StructDot (x61, x62)) (MKBOOL x15) = false
  | equal_expr_nodea (MKBOOL x15) (StructDot (x61, x62)) = false
  | equal_expr_nodea (StructDot (x61, x62)) (Arbitrary x14) = false
  | equal_expr_nodea (Arbitrary x14) (StructDot (x61, x62)) = false
  | equal_expr_nodea (StructDot (x61, x62)) (CompLiteral (x131, x132)) = false
  | equal_expr_nodea (CompLiteral (x131, x132)) (StructDot (x61, x62)) = false
  | equal_expr_nodea (StructDot (x61, x62)) (EFnCall (x121, x122)) = false
  | equal_expr_nodea (EFnCall (x121, x122)) (StructDot (x61, x62)) = false
  | equal_expr_nodea (StructDot (x61, x62)) (SizeofTy x11a) = false
  | equal_expr_nodea (SizeofTy x11a) (StructDot (x61, x62)) = false
  | equal_expr_nodea (StructDot (x61, x62)) (Sizeof x10) = false
  | equal_expr_nodea (Sizeof x10) (StructDot (x61, x62)) = false
  | equal_expr_nodea (StructDot (x61, x62)) (TypeCast (x91, x92)) = false
  | equal_expr_nodea (TypeCast (x91, x92)) (StructDot (x61, x62)) = false
  | equal_expr_nodea (StructDot (x61, x62)) (Deref x8) = false
  | equal_expr_nodea (Deref x8) (StructDot (x61, x62)) = false
  | equal_expr_nodea (StructDot (x61, x62)) (ArrayDeref (x71, x72)) = false
  | equal_expr_nodea (ArrayDeref (x71, x72)) (StructDot (x61, x62)) = false
  | equal_expr_nodea (Vara (x51, x52)) (MKBOOL x15) = false
  | equal_expr_nodea (MKBOOL x15) (Vara (x51, x52)) = false
  | equal_expr_nodea (Vara (x51, x52)) (Arbitrary x14) = false
  | equal_expr_nodea (Arbitrary x14) (Vara (x51, x52)) = false
  | equal_expr_nodea (Vara (x51, x52)) (CompLiteral (x131, x132)) = false
  | equal_expr_nodea (CompLiteral (x131, x132)) (Vara (x51, x52)) = false
  | equal_expr_nodea (Vara (x51, x52)) (EFnCall (x121, x122)) = false
  | equal_expr_nodea (EFnCall (x121, x122)) (Vara (x51, x52)) = false
  | equal_expr_nodea (Vara (x51, x52)) (SizeofTy x11a) = false
  | equal_expr_nodea (SizeofTy x11a) (Vara (x51, x52)) = false
  | equal_expr_nodea (Vara (x51, x52)) (Sizeof x10) = false
  | equal_expr_nodea (Sizeof x10) (Vara (x51, x52)) = false
  | equal_expr_nodea (Vara (x51, x52)) (TypeCast (x91, x92)) = false
  | equal_expr_nodea (TypeCast (x91, x92)) (Vara (x51, x52)) = false
  | equal_expr_nodea (Vara (x51, x52)) (Deref x8) = false
  | equal_expr_nodea (Deref x8) (Vara (x51, x52)) = false
  | equal_expr_nodea (Vara (x51, x52)) (ArrayDeref (x71, x72)) = false
  | equal_expr_nodea (ArrayDeref (x71, x72)) (Vara (x51, x52)) = false
  | equal_expr_nodea (Vara (x51, x52)) (StructDot (x61, x62)) = false
  | equal_expr_nodea (StructDot (x61, x62)) (Vara (x51, x52)) = false
  | equal_expr_nodea (Constant x4) (MKBOOL x15) = false
  | equal_expr_nodea (MKBOOL x15) (Constant x4) = false
  | equal_expr_nodea (Constant x4) (Arbitrary x14) = false
  | equal_expr_nodea (Arbitrary x14) (Constant x4) = false
  | equal_expr_nodea (Constant x4) (CompLiteral (x131, x132)) = false
  | equal_expr_nodea (CompLiteral (x131, x132)) (Constant x4) = false
  | equal_expr_nodea (Constant x4) (EFnCall (x121, x122)) = false
  | equal_expr_nodea (EFnCall (x121, x122)) (Constant x4) = false
  | equal_expr_nodea (Constant x4) (SizeofTy x11a) = false
  | equal_expr_nodea (SizeofTy x11a) (Constant x4) = false
  | equal_expr_nodea (Constant x4) (Sizeof x10) = false
  | equal_expr_nodea (Sizeof x10) (Constant x4) = false
  | equal_expr_nodea (Constant x4) (TypeCast (x91, x92)) = false
  | equal_expr_nodea (TypeCast (x91, x92)) (Constant x4) = false
  | equal_expr_nodea (Constant x4) (Deref x8) = false
  | equal_expr_nodea (Deref x8) (Constant x4) = false
  | equal_expr_nodea (Constant x4) (ArrayDeref (x71, x72)) = false
  | equal_expr_nodea (ArrayDeref (x71, x72)) (Constant x4) = false
  | equal_expr_nodea (Constant x4) (StructDot (x61, x62)) = false
  | equal_expr_nodea (StructDot (x61, x62)) (Constant x4) = false
  | equal_expr_nodea (Constant x4) (Vara (x51, x52)) = false
  | equal_expr_nodea (Vara (x51, x52)) (Constant x4) = false
  | equal_expr_nodea (CondExp (x31, x32, x33)) (MKBOOL x15) = false
  | equal_expr_nodea (MKBOOL x15) (CondExp (x31, x32, x33)) = false
  | equal_expr_nodea (CondExp (x31, x32, x33)) (Arbitrary x14) = false
  | equal_expr_nodea (Arbitrary x14) (CondExp (x31, x32, x33)) = false
  | equal_expr_nodea (CondExp (x31, x32, x33)) (CompLiteral (x131, x132)) = false
  | equal_expr_nodea (CompLiteral (x131, x132)) (CondExp (x31, x32, x33)) = false
  | equal_expr_nodea (CondExp (x31, x32, x33)) (EFnCall (x121, x122)) = false
  | equal_expr_nodea (EFnCall (x121, x122)) (CondExp (x31, x32, x33)) = false
  | equal_expr_nodea (CondExp (x31, x32, x33)) (SizeofTy x11a) = false
  | equal_expr_nodea (SizeofTy x11a) (CondExp (x31, x32, x33)) = false
  | equal_expr_nodea (CondExp (x31, x32, x33)) (Sizeof x10) = false
  | equal_expr_nodea (Sizeof x10) (CondExp (x31, x32, x33)) = false
  | equal_expr_nodea (CondExp (x31, x32, x33)) (TypeCast (x91, x92)) = false
  | equal_expr_nodea (TypeCast (x91, x92)) (CondExp (x31, x32, x33)) = false
  | equal_expr_nodea (CondExp (x31, x32, x33)) (Deref x8) = false
  | equal_expr_nodea (Deref x8) (CondExp (x31, x32, x33)) = false
  | equal_expr_nodea (CondExp (x31, x32, x33)) (ArrayDeref (x71, x72)) = false
  | equal_expr_nodea (ArrayDeref (x71, x72)) (CondExp (x31, x32, x33)) = false
  | equal_expr_nodea (CondExp (x31, x32, x33)) (StructDot (x61, x62)) = false
  | equal_expr_nodea (StructDot (x61, x62)) (CondExp (x31, x32, x33)) = false
  | equal_expr_nodea (CondExp (x31, x32, x33)) (Vara (x51, x52)) = false
  | equal_expr_nodea (Vara (x51, x52)) (CondExp (x31, x32, x33)) = false
  | equal_expr_nodea (CondExp (x31, x32, x33)) (Constant x4) = false
  | equal_expr_nodea (Constant x4) (CondExp (x31, x32, x33)) = false
  | equal_expr_nodea (UnOp (x21, x22)) (MKBOOL x15) = false
  | equal_expr_nodea (MKBOOL x15) (UnOp (x21, x22)) = false
  | equal_expr_nodea (UnOp (x21, x22)) (Arbitrary x14) = false
  | equal_expr_nodea (Arbitrary x14) (UnOp (x21, x22)) = false
  | equal_expr_nodea (UnOp (x21, x22)) (CompLiteral (x131, x132)) = false
  | equal_expr_nodea (CompLiteral (x131, x132)) (UnOp (x21, x22)) = false
  | equal_expr_nodea (UnOp (x21, x22)) (EFnCall (x121, x122)) = false
  | equal_expr_nodea (EFnCall (x121, x122)) (UnOp (x21, x22)) = false
  | equal_expr_nodea (UnOp (x21, x22)) (SizeofTy x11a) = false
  | equal_expr_nodea (SizeofTy x11a) (UnOp (x21, x22)) = false
  | equal_expr_nodea (UnOp (x21, x22)) (Sizeof x10) = false
  | equal_expr_nodea (Sizeof x10) (UnOp (x21, x22)) = false
  | equal_expr_nodea (UnOp (x21, x22)) (TypeCast (x91, x92)) = false
  | equal_expr_nodea (TypeCast (x91, x92)) (UnOp (x21, x22)) = false
  | equal_expr_nodea (UnOp (x21, x22)) (Deref x8) = false
  | equal_expr_nodea (Deref x8) (UnOp (x21, x22)) = false
  | equal_expr_nodea (UnOp (x21, x22)) (ArrayDeref (x71, x72)) = false
  | equal_expr_nodea (ArrayDeref (x71, x72)) (UnOp (x21, x22)) = false
  | equal_expr_nodea (UnOp (x21, x22)) (StructDot (x61, x62)) = false
  | equal_expr_nodea (StructDot (x61, x62)) (UnOp (x21, x22)) = false
  | equal_expr_nodea (UnOp (x21, x22)) (Vara (x51, x52)) = false
  | equal_expr_nodea (Vara (x51, x52)) (UnOp (x21, x22)) = false
  | equal_expr_nodea (UnOp (x21, x22)) (Constant x4) = false
  | equal_expr_nodea (Constant x4) (UnOp (x21, x22)) = false
  | equal_expr_nodea (UnOp (x21, x22)) (CondExp (x31, x32, x33)) = false
  | equal_expr_nodea (CondExp (x31, x32, x33)) (UnOp (x21, x22)) = false
  | equal_expr_nodea (BinOp (x11, x12, x13)) (MKBOOL x15) = false
  | equal_expr_nodea (MKBOOL x15) (BinOp (x11, x12, x13)) = false
  | equal_expr_nodea (BinOp (x11, x12, x13)) (Arbitrary x14) = false
  | equal_expr_nodea (Arbitrary x14) (BinOp (x11, x12, x13)) = false
  | equal_expr_nodea (BinOp (x11, x12, x13)) (CompLiteral (x131, x132)) = false
  | equal_expr_nodea (CompLiteral (x131, x132)) (BinOp (x11, x12, x13)) = false
  | equal_expr_nodea (BinOp (x11, x12, x13)) (EFnCall (x121, x122)) = false
  | equal_expr_nodea (EFnCall (x121, x122)) (BinOp (x11, x12, x13)) = false
  | equal_expr_nodea (BinOp (x11, x12, x13)) (SizeofTy x11a) = false
  | equal_expr_nodea (SizeofTy x11a) (BinOp (x11, x12, x13)) = false
  | equal_expr_nodea (BinOp (x11, x12, x13)) (Sizeof x10) = false
  | equal_expr_nodea (Sizeof x10) (BinOp (x11, x12, x13)) = false
  | equal_expr_nodea (BinOp (x11, x12, x13)) (TypeCast (x91, x92)) = false
  | equal_expr_nodea (TypeCast (x91, x92)) (BinOp (x11, x12, x13)) = false
  | equal_expr_nodea (BinOp (x11, x12, x13)) (Deref x8) = false
  | equal_expr_nodea (Deref x8) (BinOp (x11, x12, x13)) = false
  | equal_expr_nodea (BinOp (x11, x12, x13)) (ArrayDeref (x71, x72)) = false
  | equal_expr_nodea (ArrayDeref (x71, x72)) (BinOp (x11, x12, x13)) = false
  | equal_expr_nodea (BinOp (x11, x12, x13)) (StructDot (x61, x62)) = false
  | equal_expr_nodea (StructDot (x61, x62)) (BinOp (x11, x12, x13)) = false
  | equal_expr_nodea (BinOp (x11, x12, x13)) (Vara (x51, x52)) = false
  | equal_expr_nodea (Vara (x51, x52)) (BinOp (x11, x12, x13)) = false
  | equal_expr_nodea (BinOp (x11, x12, x13)) (Constant x4) = false
  | equal_expr_nodea (Constant x4) (BinOp (x11, x12, x13)) = false
  | equal_expr_nodea (BinOp (x11, x12, x13)) (CondExp (x31, x32, x33)) = false
  | equal_expr_nodea (CondExp (x31, x32, x33)) (BinOp (x11, x12, x13)) = false
  | equal_expr_nodea (BinOp (x11, x12, x13)) (UnOp (x21, x22)) = false
  | equal_expr_nodea (UnOp (x21, x22)) (BinOp (x11, x12, x13)) = false
  | equal_expr_nodea (MKBOOL x15) (MKBOOL y15) = equal_expra x15 y15
  | equal_expr_nodea (Arbitrary x14) (Arbitrary y14) = equal_ctypea (equal_expr ()) x14 y14
  | equal_expr_nodea (CompLiteral (x131, x132)) (CompLiteral (y131, y132)) = equal_ctypea (equal_expr ()) x131 y131 andalso equal_lista (equal_prod (equal_list (equal_designator ())) (equal_initializer ())) x132 y132
  | equal_expr_nodea (EFnCall (x121, x122)) (EFnCall (y121, y122)) = equal_expra x121 y121 andalso equal_lista (equal_expr ()) x122 y122
  | equal_expr_nodea (SizeofTy x11a) (SizeofTy y11a) = equal_Region_Wrap (equal_ctype (equal_expr ())) x11a y11a
  | equal_expr_nodea (Sizeof x10) (Sizeof y10) = equal_expra x10 y10
  | equal_expr_nodea (TypeCast (x91, x92)) (TypeCast (y91, y92)) = equal_Region_Wrap (equal_ctype (equal_expr ())) x91 y91 andalso equal_expra x92 y92
  | equal_expr_nodea (Deref x8) (Deref y8) = equal_expra x8 y8
  | equal_expr_nodea (ArrayDeref (x71, x72)) (ArrayDeref (y71, y72)) = equal_expra x71 y71 andalso equal_expra x72 y72
  | equal_expr_nodea (StructDot (x61, x62)) (StructDot (y61, y62)) = equal_expra x61 y61 andalso equal_abr_stringa x62 y62
  | equal_expr_nodea (Vara (x51, x52)) (Vara (y51, y52)) = equal_abr_stringa x51 y51 andalso equal_Unsynchronized_ref (equal_option (equal_prod (equal_ctype equal_integer) equal_more_info)) x52 y52
  | equal_expr_nodea (Constant x4) (Constant y4) = equal_Region_Wrap equal_literalconstant_node x4 y4
  | equal_expr_nodea (CondExp (x31, x32, x33)) (CondExp (y31, y32, y33)) = equal_expra x31 y31 andalso (equal_expra x32 y32 andalso equal_expra x33 y33)
  | equal_expr_nodea (UnOp (x21, x22)) (UnOp (y21, y22)) = equal_unoptype x21 y21 andalso equal_expra x22 y22
  | equal_expr_nodea (BinOp (x11, x12, x13)) (BinOp (y11, y12, y13)) = equal_binoptype x11 y11 andalso (equal_expra x12 y12 andalso equal_expra x13 y13)
and equal_expr_node () = {equala = equal_expr_nodea} : expr_node equal
and equal_expra (E x) (E ya) = equal_Region_Wrap (equal_expr_node ()) x ya
and equal_designatora (DesignE x1) (DesignFld x2) = false
  | equal_designatora (DesignFld x2) (DesignE x1) = false
  | equal_designatora (DesignFld x2) (DesignFld y2) = equal_abr_stringa x2 y2
  | equal_designatora (DesignE x1) (DesignE y1) = equal_expra x1 y1
and equal_designator () = {equala = equal_designatora} : designator equal
and equal_initializera (InitE x1) (InitList x2) = false
  | equal_initializera (InitList x2) (InitE x1) = false
  | equal_initializera (InitList x2) (InitList y2) = equal_lista (equal_prod (equal_list (equal_designator ())) (equal_initializer ())) x2 y2
  | equal_initializera (InitE x1) (InitE y1) = equal_expra x1 y1
and equal_initializer () = {equala = equal_initializera} : initializer equal;
val equal_expr = equal_expr ();
val equal_expr_node = equal_expr_node ();
val equal_designator = equal_designator ();
val equal_initializer = equal_initializer ();

val equal_literal = {equala = (fn a => fn b => ((a : string) = b))} : string equal;

datatype ocl_multiplicity_single = Mult_nat of Code_Numeral.natural | Mult_star | Mult_infinity;

datatype ocl_collection = Set | Sequence | Ordered0 | Subsets0 | Union0 | Redefines0 | Derived0 | Qualifier0 | Nonunique0;

datatype 'a ocl_multiplicity_ext = Ocl_multiplicity_ext of (ocl_multiplicity_single * ocl_multiplicity_single option) list * abr_string option * ocl_collection list * 'a;

fun equal_naturala m n = Code_Numeral.integer_of_natural m = Code_Numeral.integer_of_natural n;

fun equal_ocl_multiplicity_singlea Mult_star Mult_infinity = false
  | equal_ocl_multiplicity_singlea Mult_infinity Mult_star = false
  | equal_ocl_multiplicity_singlea (Mult_nat x1) Mult_infinity = false
  | equal_ocl_multiplicity_singlea Mult_infinity (Mult_nat x1) = false
  | equal_ocl_multiplicity_singlea (Mult_nat x1) Mult_star = false
  | equal_ocl_multiplicity_singlea Mult_star (Mult_nat x1) = false
  | equal_ocl_multiplicity_singlea (Mult_nat x1) (Mult_nat y1) = equal_naturala x1 y1
  | equal_ocl_multiplicity_singlea Mult_infinity Mult_infinity = true
  | equal_ocl_multiplicity_singlea Mult_star Mult_star = true;

val equal_ocl_multiplicity_single = {equala = equal_ocl_multiplicity_singlea} : ocl_multiplicity_single equal;

fun equal_ocl_collectiona Qualifier0 Nonunique0 = false
  | equal_ocl_collectiona Nonunique0 Qualifier0 = false
  | equal_ocl_collectiona Derived0 Nonunique0 = false
  | equal_ocl_collectiona Nonunique0 Derived0 = false
  | equal_ocl_collectiona Derived0 Qualifier0 = false
  | equal_ocl_collectiona Qualifier0 Derived0 = false
  | equal_ocl_collectiona Redefines0 Nonunique0 = false
  | equal_ocl_collectiona Nonunique0 Redefines0 = false
  | equal_ocl_collectiona Redefines0 Qualifier0 = false
  | equal_ocl_collectiona Qualifier0 Redefines0 = false
  | equal_ocl_collectiona Redefines0 Derived0 = false
  | equal_ocl_collectiona Derived0 Redefines0 = false
  | equal_ocl_collectiona Union0 Nonunique0 = false
  | equal_ocl_collectiona Nonunique0 Union0 = false
  | equal_ocl_collectiona Union0 Qualifier0 = false
  | equal_ocl_collectiona Qualifier0 Union0 = false
  | equal_ocl_collectiona Union0 Derived0 = false
  | equal_ocl_collectiona Derived0 Union0 = false
  | equal_ocl_collectiona Union0 Redefines0 = false
  | equal_ocl_collectiona Redefines0 Union0 = false
  | equal_ocl_collectiona Subsets0 Nonunique0 = false
  | equal_ocl_collectiona Nonunique0 Subsets0 = false
  | equal_ocl_collectiona Subsets0 Qualifier0 = false
  | equal_ocl_collectiona Qualifier0 Subsets0 = false
  | equal_ocl_collectiona Subsets0 Derived0 = false
  | equal_ocl_collectiona Derived0 Subsets0 = false
  | equal_ocl_collectiona Subsets0 Redefines0 = false
  | equal_ocl_collectiona Redefines0 Subsets0 = false
  | equal_ocl_collectiona Subsets0 Union0 = false
  | equal_ocl_collectiona Union0 Subsets0 = false
  | equal_ocl_collectiona Ordered0 Nonunique0 = false
  | equal_ocl_collectiona Nonunique0 Ordered0 = false
  | equal_ocl_collectiona Ordered0 Qualifier0 = false
  | equal_ocl_collectiona Qualifier0 Ordered0 = false
  | equal_ocl_collectiona Ordered0 Derived0 = false
  | equal_ocl_collectiona Derived0 Ordered0 = false
  | equal_ocl_collectiona Ordered0 Redefines0 = false
  | equal_ocl_collectiona Redefines0 Ordered0 = false
  | equal_ocl_collectiona Ordered0 Union0 = false
  | equal_ocl_collectiona Union0 Ordered0 = false
  | equal_ocl_collectiona Ordered0 Subsets0 = false
  | equal_ocl_collectiona Subsets0 Ordered0 = false
  | equal_ocl_collectiona Sequence Nonunique0 = false
  | equal_ocl_collectiona Nonunique0 Sequence = false
  | equal_ocl_collectiona Sequence Qualifier0 = false
  | equal_ocl_collectiona Qualifier0 Sequence = false
  | equal_ocl_collectiona Sequence Derived0 = false
  | equal_ocl_collectiona Derived0 Sequence = false
  | equal_ocl_collectiona Sequence Redefines0 = false
  | equal_ocl_collectiona Redefines0 Sequence = false
  | equal_ocl_collectiona Sequence Union0 = false
  | equal_ocl_collectiona Union0 Sequence = false
  | equal_ocl_collectiona Sequence Subsets0 = false
  | equal_ocl_collectiona Subsets0 Sequence = false
  | equal_ocl_collectiona Sequence Ordered0 = false
  | equal_ocl_collectiona Ordered0 Sequence = false
  | equal_ocl_collectiona Set Nonunique0 = false
  | equal_ocl_collectiona Nonunique0 Set = false
  | equal_ocl_collectiona Set Qualifier0 = false
  | equal_ocl_collectiona Qualifier0 Set = false
  | equal_ocl_collectiona Set Derived0 = false
  | equal_ocl_collectiona Derived0 Set = false
  | equal_ocl_collectiona Set Redefines0 = false
  | equal_ocl_collectiona Redefines0 Set = false
  | equal_ocl_collectiona Set Union0 = false
  | equal_ocl_collectiona Union0 Set = false
  | equal_ocl_collectiona Set Subsets0 = false
  | equal_ocl_collectiona Subsets0 Set = false
  | equal_ocl_collectiona Set Ordered0 = false
  | equal_ocl_collectiona Ordered0 Set = false
  | equal_ocl_collectiona Set Sequence = false
  | equal_ocl_collectiona Sequence Set = false
  | equal_ocl_collectiona Nonunique0 Nonunique0 = true
  | equal_ocl_collectiona Qualifier0 Qualifier0 = true
  | equal_ocl_collectiona Derived0 Derived0 = true
  | equal_ocl_collectiona Redefines0 Redefines0 = true
  | equal_ocl_collectiona Union0 Union0 = true
  | equal_ocl_collectiona Subsets0 Subsets0 = true
  | equal_ocl_collectiona Ordered0 Ordered0 = true
  | equal_ocl_collectiona Sequence Sequence = true
  | equal_ocl_collectiona Set Set = true;

val equal_ocl_collection = {equala = equal_ocl_collectiona} : ocl_collection equal;

fun equal_ocl_multiplicity_ext A_ (Ocl_multiplicity_ext (tyMulta, tyRolea, tyCollecta, morea)) (Ocl_multiplicity_ext (tyMult, tyRole, tyCollect, more)) =
  equal_lista (equal_prod equal_ocl_multiplicity_single (equal_option equal_ocl_multiplicity_single)) tyMulta tyMult andalso
    (equal_optiona equal_abr_string tyRolea tyRole andalso (equal_lista equal_ocl_collection tyCollecta tyCollect andalso eq A_ morea more));

datatype 'a ocl_ty_class_node_ext = Ocl_ty_class_node_ext of Code_Numeral.natural * unit ocl_multiplicity_ext * abr_string * 'a;

fun equal_unita u v = true;

val equal_unit = {equala = equal_unita} : unit equal;

fun equal_ocl_ty_class_node_ext A_ (Ocl_ty_class_node_ext (tyObjN_ass_switcha, tyObjN_role_multipa, tyObjN_role_tya, morea)) (Ocl_ty_class_node_ext (tyObjN_ass_switch, tyObjN_role_multip, tyObjN_role_ty, more)) =
  equal_naturala tyObjN_ass_switcha tyObjN_ass_switch andalso (equal_ocl_multiplicity_ext equal_unit tyObjN_role_multipa tyObjN_role_multip andalso (equal_abr_stringa tyObjN_role_tya tyObjN_role_ty andalso eq A_ morea more));

datatype 'a ocl_ty_class_ext = Ocl_ty_class_ext of abr_string * Code_Numeral.natural * Code_Numeral.natural * unit ocl_ty_class_node_ext * unit ocl_ty_class_node_ext * 'a;

fun equal_ocl_ty_class_ext A_ (Ocl_ty_class_ext (tyObj_namea, tyObj_ass_ida, tyObj_ass_aritya, tyObj_froma, tyObj_toa, morea)) (Ocl_ty_class_ext (tyObj_name, tyObj_ass_id, tyObj_ass_arity, tyObj_from, tyObj_to, more)) =
  equal_abr_stringa tyObj_namea tyObj_name andalso
    (equal_naturala tyObj_ass_ida tyObj_ass_id andalso
      (equal_naturala tyObj_ass_aritya tyObj_ass_arity andalso (equal_ocl_ty_class_node_ext equal_unit tyObj_froma tyObj_from andalso (equal_ocl_ty_class_node_ext equal_unit tyObj_toa tyObj_to andalso eq A_ morea more))));

datatype ocl_ty_obj_core = OclTyCore_pre of abr_string | OclTyCore of unit ocl_ty_class_ext;

fun equal_ocl_ty_obj_corea (OclTyCore_pre x1) (OclTyCore x2) = false
  | equal_ocl_ty_obj_corea (OclTyCore x2) (OclTyCore_pre x1) = false
  | equal_ocl_ty_obj_corea (OclTyCore x2) (OclTyCore y2) = equal_ocl_ty_class_ext equal_unit x2 y2
  | equal_ocl_ty_obj_corea (OclTyCore_pre x1) (OclTyCore_pre y1) = equal_abr_stringa x1 y1;

datatype ocl_ty_obj = OclTyObj of ocl_ty_obj_core * (ocl_ty_obj_core list) list;

val equal_ocl_ty_obj_core = {equala = equal_ocl_ty_obj_corea} : ocl_ty_obj_core equal;

fun equal_ocl_ty_obj (OclTyObj (x1, x2)) (OclTyObj (y1, y2)) = equal_ocl_ty_obj_corea x1 y1 andalso equal_lista (equal_list equal_ocl_ty_obj_core) x2 y2;

datatype ocl_ty = OclTy_base_void | OclTy_base_boolean | OclTy_base_integer | OclTy_base_unlimitednatural | OclTy_base_real | OclTy_base_string | OclTy_object of ocl_ty_obj | OclTy_collection of unit ocl_multiplicity_ext * ocl_ty |
  OclTy_pair of ocl_ty * ocl_ty | OclTy_binding of (abr_string option * ocl_ty) | OclTy_arrow of ocl_ty * ocl_ty | OclTy_class_syn of abr_string | OclTy_enum of abr_string | OclTy_raw of abr_string;

fun equal_ocl_ty () = {equala = equal_ocl_tya} : ocl_ty equal
and equal_ocl_tya (OclTy_enum x13) (OclTy_raw x14) = false
  | equal_ocl_tya (OclTy_raw x14) (OclTy_enum x13) = false
  | equal_ocl_tya (OclTy_class_syn x12) (OclTy_raw x14) = false
  | equal_ocl_tya (OclTy_raw x14) (OclTy_class_syn x12) = false
  | equal_ocl_tya (OclTy_class_syn x12) (OclTy_enum x13) = false
  | equal_ocl_tya (OclTy_enum x13) (OclTy_class_syn x12) = false
  | equal_ocl_tya (OclTy_arrow (x111, x112)) (OclTy_raw x14) = false
  | equal_ocl_tya (OclTy_raw x14) (OclTy_arrow (x111, x112)) = false
  | equal_ocl_tya (OclTy_arrow (x111, x112)) (OclTy_enum x13) = false
  | equal_ocl_tya (OclTy_enum x13) (OclTy_arrow (x111, x112)) = false
  | equal_ocl_tya (OclTy_arrow (x111, x112)) (OclTy_class_syn x12) = false
  | equal_ocl_tya (OclTy_class_syn x12) (OclTy_arrow (x111, x112)) = false
  | equal_ocl_tya (OclTy_binding x10) (OclTy_raw x14) = false
  | equal_ocl_tya (OclTy_raw x14) (OclTy_binding x10) = false
  | equal_ocl_tya (OclTy_binding x10) (OclTy_enum x13) = false
  | equal_ocl_tya (OclTy_enum x13) (OclTy_binding x10) = false
  | equal_ocl_tya (OclTy_binding x10) (OclTy_class_syn x12) = false
  | equal_ocl_tya (OclTy_class_syn x12) (OclTy_binding x10) = false
  | equal_ocl_tya (OclTy_binding x10) (OclTy_arrow (x111, x112)) = false
  | equal_ocl_tya (OclTy_arrow (x111, x112)) (OclTy_binding x10) = false
  | equal_ocl_tya (OclTy_pair (x91, x92)) (OclTy_raw x14) = false
  | equal_ocl_tya (OclTy_raw x14) (OclTy_pair (x91, x92)) = false
  | equal_ocl_tya (OclTy_pair (x91, x92)) (OclTy_enum x13) = false
  | equal_ocl_tya (OclTy_enum x13) (OclTy_pair (x91, x92)) = false
  | equal_ocl_tya (OclTy_pair (x91, x92)) (OclTy_class_syn x12) = false
  | equal_ocl_tya (OclTy_class_syn x12) (OclTy_pair (x91, x92)) = false
  | equal_ocl_tya (OclTy_pair (x91, x92)) (OclTy_arrow (x111, x112)) = false
  | equal_ocl_tya (OclTy_arrow (x111, x112)) (OclTy_pair (x91, x92)) = false
  | equal_ocl_tya (OclTy_pair (x91, x92)) (OclTy_binding x10) = false
  | equal_ocl_tya (OclTy_binding x10) (OclTy_pair (x91, x92)) = false
  | equal_ocl_tya (OclTy_collection (x81, x82)) (OclTy_raw x14) = false
  | equal_ocl_tya (OclTy_raw x14) (OclTy_collection (x81, x82)) = false
  | equal_ocl_tya (OclTy_collection (x81, x82)) (OclTy_enum x13) = false
  | equal_ocl_tya (OclTy_enum x13) (OclTy_collection (x81, x82)) = false
  | equal_ocl_tya (OclTy_collection (x81, x82)) (OclTy_class_syn x12) = false
  | equal_ocl_tya (OclTy_class_syn x12) (OclTy_collection (x81, x82)) = false
  | equal_ocl_tya (OclTy_collection (x81, x82)) (OclTy_arrow (x111, x112)) = false
  | equal_ocl_tya (OclTy_arrow (x111, x112)) (OclTy_collection (x81, x82)) = false
  | equal_ocl_tya (OclTy_collection (x81, x82)) (OclTy_binding x10) = false
  | equal_ocl_tya (OclTy_binding x10) (OclTy_collection (x81, x82)) = false
  | equal_ocl_tya (OclTy_collection (x81, x82)) (OclTy_pair (x91, x92)) = false
  | equal_ocl_tya (OclTy_pair (x91, x92)) (OclTy_collection (x81, x82)) = false
  | equal_ocl_tya (OclTy_object x7) (OclTy_raw x14) = false
  | equal_ocl_tya (OclTy_raw x14) (OclTy_object x7) = false
  | equal_ocl_tya (OclTy_object x7) (OclTy_enum x13) = false
  | equal_ocl_tya (OclTy_enum x13) (OclTy_object x7) = false
  | equal_ocl_tya (OclTy_object x7) (OclTy_class_syn x12) = false
  | equal_ocl_tya (OclTy_class_syn x12) (OclTy_object x7) = false
  | equal_ocl_tya (OclTy_object x7) (OclTy_arrow (x111, x112)) = false
  | equal_ocl_tya (OclTy_arrow (x111, x112)) (OclTy_object x7) = false
  | equal_ocl_tya (OclTy_object x7) (OclTy_binding x10) = false
  | equal_ocl_tya (OclTy_binding x10) (OclTy_object x7) = false
  | equal_ocl_tya (OclTy_object x7) (OclTy_pair (x91, x92)) = false
  | equal_ocl_tya (OclTy_pair (x91, x92)) (OclTy_object x7) = false
  | equal_ocl_tya (OclTy_object x7) (OclTy_collection (x81, x82)) = false
  | equal_ocl_tya (OclTy_collection (x81, x82)) (OclTy_object x7) = false
  | equal_ocl_tya OclTy_base_string (OclTy_raw x14) = false
  | equal_ocl_tya (OclTy_raw x14) OclTy_base_string = false
  | equal_ocl_tya OclTy_base_string (OclTy_enum x13) = false
  | equal_ocl_tya (OclTy_enum x13) OclTy_base_string = false
  | equal_ocl_tya OclTy_base_string (OclTy_class_syn x12) = false
  | equal_ocl_tya (OclTy_class_syn x12) OclTy_base_string = false
  | equal_ocl_tya OclTy_base_string (OclTy_arrow (x111, x112)) = false
  | equal_ocl_tya (OclTy_arrow (x111, x112)) OclTy_base_string = false
  | equal_ocl_tya OclTy_base_string (OclTy_binding x10) = false
  | equal_ocl_tya (OclTy_binding x10) OclTy_base_string = false
  | equal_ocl_tya OclTy_base_string (OclTy_pair (x91, x92)) = false
  | equal_ocl_tya (OclTy_pair (x91, x92)) OclTy_base_string = false
  | equal_ocl_tya OclTy_base_string (OclTy_collection (x81, x82)) = false
  | equal_ocl_tya (OclTy_collection (x81, x82)) OclTy_base_string = false
  | equal_ocl_tya OclTy_base_string (OclTy_object x7) = false
  | equal_ocl_tya (OclTy_object x7) OclTy_base_string = false
  | equal_ocl_tya OclTy_base_real (OclTy_raw x14) = false
  | equal_ocl_tya (OclTy_raw x14) OclTy_base_real = false
  | equal_ocl_tya OclTy_base_real (OclTy_enum x13) = false
  | equal_ocl_tya (OclTy_enum x13) OclTy_base_real = false
  | equal_ocl_tya OclTy_base_real (OclTy_class_syn x12) = false
  | equal_ocl_tya (OclTy_class_syn x12) OclTy_base_real = false
  | equal_ocl_tya OclTy_base_real (OclTy_arrow (x111, x112)) = false
  | equal_ocl_tya (OclTy_arrow (x111, x112)) OclTy_base_real = false
  | equal_ocl_tya OclTy_base_real (OclTy_binding x10) = false
  | equal_ocl_tya (OclTy_binding x10) OclTy_base_real = false
  | equal_ocl_tya OclTy_base_real (OclTy_pair (x91, x92)) = false
  | equal_ocl_tya (OclTy_pair (x91, x92)) OclTy_base_real = false
  | equal_ocl_tya OclTy_base_real (OclTy_collection (x81, x82)) = false
  | equal_ocl_tya (OclTy_collection (x81, x82)) OclTy_base_real = false
  | equal_ocl_tya OclTy_base_real (OclTy_object x7) = false
  | equal_ocl_tya (OclTy_object x7) OclTy_base_real = false
  | equal_ocl_tya OclTy_base_real OclTy_base_string = false
  | equal_ocl_tya OclTy_base_string OclTy_base_real = false
  | equal_ocl_tya OclTy_base_unlimitednatural (OclTy_raw x14) = false
  | equal_ocl_tya (OclTy_raw x14) OclTy_base_unlimitednatural = false
  | equal_ocl_tya OclTy_base_unlimitednatural (OclTy_enum x13) = false
  | equal_ocl_tya (OclTy_enum x13) OclTy_base_unlimitednatural = false
  | equal_ocl_tya OclTy_base_unlimitednatural (OclTy_class_syn x12) = false
  | equal_ocl_tya (OclTy_class_syn x12) OclTy_base_unlimitednatural = false
  | equal_ocl_tya OclTy_base_unlimitednatural (OclTy_arrow (x111, x112)) = false
  | equal_ocl_tya (OclTy_arrow (x111, x112)) OclTy_base_unlimitednatural = false
  | equal_ocl_tya OclTy_base_unlimitednatural (OclTy_binding x10) = false
  | equal_ocl_tya (OclTy_binding x10) OclTy_base_unlimitednatural = false
  | equal_ocl_tya OclTy_base_unlimitednatural (OclTy_pair (x91, x92)) = false
  | equal_ocl_tya (OclTy_pair (x91, x92)) OclTy_base_unlimitednatural = false
  | equal_ocl_tya OclTy_base_unlimitednatural (OclTy_collection (x81, x82)) = false
  | equal_ocl_tya (OclTy_collection (x81, x82)) OclTy_base_unlimitednatural = false
  | equal_ocl_tya OclTy_base_unlimitednatural (OclTy_object x7) = false
  | equal_ocl_tya (OclTy_object x7) OclTy_base_unlimitednatural = false
  | equal_ocl_tya OclTy_base_unlimitednatural OclTy_base_string = false
  | equal_ocl_tya OclTy_base_string OclTy_base_unlimitednatural = false
  | equal_ocl_tya OclTy_base_unlimitednatural OclTy_base_real = false
  | equal_ocl_tya OclTy_base_real OclTy_base_unlimitednatural = false
  | equal_ocl_tya OclTy_base_integer (OclTy_raw x14) = false
  | equal_ocl_tya (OclTy_raw x14) OclTy_base_integer = false
  | equal_ocl_tya OclTy_base_integer (OclTy_enum x13) = false
  | equal_ocl_tya (OclTy_enum x13) OclTy_base_integer = false
  | equal_ocl_tya OclTy_base_integer (OclTy_class_syn x12) = false
  | equal_ocl_tya (OclTy_class_syn x12) OclTy_base_integer = false
  | equal_ocl_tya OclTy_base_integer (OclTy_arrow (x111, x112)) = false
  | equal_ocl_tya (OclTy_arrow (x111, x112)) OclTy_base_integer = false
  | equal_ocl_tya OclTy_base_integer (OclTy_binding x10) = false
  | equal_ocl_tya (OclTy_binding x10) OclTy_base_integer = false
  | equal_ocl_tya OclTy_base_integer (OclTy_pair (x91, x92)) = false
  | equal_ocl_tya (OclTy_pair (x91, x92)) OclTy_base_integer = false
  | equal_ocl_tya OclTy_base_integer (OclTy_collection (x81, x82)) = false
  | equal_ocl_tya (OclTy_collection (x81, x82)) OclTy_base_integer = false
  | equal_ocl_tya OclTy_base_integer (OclTy_object x7) = false
  | equal_ocl_tya (OclTy_object x7) OclTy_base_integer = false
  | equal_ocl_tya OclTy_base_integer OclTy_base_string = false
  | equal_ocl_tya OclTy_base_string OclTy_base_integer = false
  | equal_ocl_tya OclTy_base_integer OclTy_base_real = false
  | equal_ocl_tya OclTy_base_real OclTy_base_integer = false
  | equal_ocl_tya OclTy_base_integer OclTy_base_unlimitednatural = false
  | equal_ocl_tya OclTy_base_unlimitednatural OclTy_base_integer = false
  | equal_ocl_tya OclTy_base_boolean (OclTy_raw x14) = false
  | equal_ocl_tya (OclTy_raw x14) OclTy_base_boolean = false
  | equal_ocl_tya OclTy_base_boolean (OclTy_enum x13) = false
  | equal_ocl_tya (OclTy_enum x13) OclTy_base_boolean = false
  | equal_ocl_tya OclTy_base_boolean (OclTy_class_syn x12) = false
  | equal_ocl_tya (OclTy_class_syn x12) OclTy_base_boolean = false
  | equal_ocl_tya OclTy_base_boolean (OclTy_arrow (x111, x112)) = false
  | equal_ocl_tya (OclTy_arrow (x111, x112)) OclTy_base_boolean = false
  | equal_ocl_tya OclTy_base_boolean (OclTy_binding x10) = false
  | equal_ocl_tya (OclTy_binding x10) OclTy_base_boolean = false
  | equal_ocl_tya OclTy_base_boolean (OclTy_pair (x91, x92)) = false
  | equal_ocl_tya (OclTy_pair (x91, x92)) OclTy_base_boolean = false
  | equal_ocl_tya OclTy_base_boolean (OclTy_collection (x81, x82)) = false
  | equal_ocl_tya (OclTy_collection (x81, x82)) OclTy_base_boolean = false
  | equal_ocl_tya OclTy_base_boolean (OclTy_object x7) = false
  | equal_ocl_tya (OclTy_object x7) OclTy_base_boolean = false
  | equal_ocl_tya OclTy_base_boolean OclTy_base_string = false
  | equal_ocl_tya OclTy_base_string OclTy_base_boolean = false
  | equal_ocl_tya OclTy_base_boolean OclTy_base_real = false
  | equal_ocl_tya OclTy_base_real OclTy_base_boolean = false
  | equal_ocl_tya OclTy_base_boolean OclTy_base_unlimitednatural = false
  | equal_ocl_tya OclTy_base_unlimitednatural OclTy_base_boolean = false
  | equal_ocl_tya OclTy_base_boolean OclTy_base_integer = false
  | equal_ocl_tya OclTy_base_integer OclTy_base_boolean = false
  | equal_ocl_tya OclTy_base_void (OclTy_raw x14) = false
  | equal_ocl_tya (OclTy_raw x14) OclTy_base_void = false
  | equal_ocl_tya OclTy_base_void (OclTy_enum x13) = false
  | equal_ocl_tya (OclTy_enum x13) OclTy_base_void = false
  | equal_ocl_tya OclTy_base_void (OclTy_class_syn x12) = false
  | equal_ocl_tya (OclTy_class_syn x12) OclTy_base_void = false
  | equal_ocl_tya OclTy_base_void (OclTy_arrow (x111, x112)) = false
  | equal_ocl_tya (OclTy_arrow (x111, x112)) OclTy_base_void = false
  | equal_ocl_tya OclTy_base_void (OclTy_binding x10) = false
  | equal_ocl_tya (OclTy_binding x10) OclTy_base_void = false
  | equal_ocl_tya OclTy_base_void (OclTy_pair (x91, x92)) = false
  | equal_ocl_tya (OclTy_pair (x91, x92)) OclTy_base_void = false
  | equal_ocl_tya OclTy_base_void (OclTy_collection (x81, x82)) = false
  | equal_ocl_tya (OclTy_collection (x81, x82)) OclTy_base_void = false
  | equal_ocl_tya OclTy_base_void (OclTy_object x7) = false
  | equal_ocl_tya (OclTy_object x7) OclTy_base_void = false
  | equal_ocl_tya OclTy_base_void OclTy_base_string = false
  | equal_ocl_tya OclTy_base_string OclTy_base_void = false
  | equal_ocl_tya OclTy_base_void OclTy_base_real = false
  | equal_ocl_tya OclTy_base_real OclTy_base_void = false
  | equal_ocl_tya OclTy_base_void OclTy_base_unlimitednatural = false
  | equal_ocl_tya OclTy_base_unlimitednatural OclTy_base_void = false
  | equal_ocl_tya OclTy_base_void OclTy_base_integer = false
  | equal_ocl_tya OclTy_base_integer OclTy_base_void = false
  | equal_ocl_tya OclTy_base_void OclTy_base_boolean = false
  | equal_ocl_tya OclTy_base_boolean OclTy_base_void = false
  | equal_ocl_tya (OclTy_raw x14) (OclTy_raw y14) = equal_abr_stringa x14 y14
  | equal_ocl_tya (OclTy_enum x13) (OclTy_enum y13) = equal_abr_stringa x13 y13
  | equal_ocl_tya (OclTy_class_syn x12) (OclTy_class_syn y12) = equal_abr_stringa x12 y12
  | equal_ocl_tya (OclTy_arrow (x111, x112)) (OclTy_arrow (y111, y112)) = equal_ocl_tya x111 y111 andalso equal_ocl_tya x112 y112
  | equal_ocl_tya (OclTy_binding x10) (OclTy_binding y10) = equal_proda (equal_option equal_abr_string) (equal_ocl_ty ()) x10 y10
  | equal_ocl_tya (OclTy_pair (x91, x92)) (OclTy_pair (y91, y92)) = equal_ocl_tya x91 y91 andalso equal_ocl_tya x92 y92
  | equal_ocl_tya (OclTy_collection (x81, x82)) (OclTy_collection (y81, y82)) = equal_ocl_multiplicity_ext equal_unit x81 y81 andalso equal_ocl_tya x82 y82
  | equal_ocl_tya (OclTy_object x7) (OclTy_object y7) = equal_ocl_ty_obj x7 y7
  | equal_ocl_tya OclTy_base_string OclTy_base_string = true
  | equal_ocl_tya OclTy_base_real OclTy_base_real = true
  | equal_ocl_tya OclTy_base_unlimitednatural OclTy_base_unlimitednatural = true
  | equal_ocl_tya OclTy_base_integer OclTy_base_integer = true
  | equal_ocl_tya OclTy_base_boolean OclTy_base_boolean = true
  | equal_ocl_tya OclTy_base_void OclTy_base_void = true;
val equal_ocl_ty = equal_ocl_ty ();

datatype 'a itself = Type;

type 'a len0 = {len_of : 'a itself -> nat};
val len_of = #len_of : 'a len0 -> 'a itself -> nat;

fun times_nat m n = Nat (integer_of_nat m * integer_of_nat n);

type 'a ord = {less_eq : 'a -> 'a -> bool, less : 'a -> 'a -> bool};
val less_eq = #less_eq : 'a ord -> 'a -> 'a -> bool;
val less = #less : 'a ord -> 'a -> 'a -> bool;

fun max A_ a b = (if less_eq A_ a b then b else a);

val ord_integer = {less_eq = (fn a => fn b => a <= b), less = (fn a => fn b => a < b)} : int ord;

fun nat_of_integer k = Nat (max ord_integer (0 : IntInf.int) k);

type 'a finite = {};

datatype 'a bit0 = Abs_bit0 of inta;

fun len_of_bit0 A_ uu = times_nat (nat_of_integer (2 : IntInf.int)) (len_of A_ Type);

fun len0_bit0 A_ = {len_of = len_of_bit0 A_} : 'a bit0 len0;

val one_nat : nat = Nat (1 : IntInf.int);

datatype num1 = One_num1;

fun len_of_num1 uu = one_nat;

val len0_num1 = {len_of = len_of_num1} : num1 len0;

datatype ocl_class = OclClass of abr_string * (abr_string * ocl_ty) list * ocl_class list;

fun equal_ocl_class () = {equala = equal_ocl_classa} : ocl_class equal
and equal_ocl_classa (OclClass (x1, x2, x3)) (OclClass (y1, y2, y3)) = equal_abr_stringa x1 y1 andalso (equal_lista (equal_prod equal_abr_string equal_ocl_ty) x2 y2 andalso equal_lista (equal_ocl_class ()) x3 y3);
val equal_ocl_class = equal_ocl_class ();

datatype opt_ident = OptIdent of Code_Numeral.natural;

fun equal_opt_identa (OptIdent x) (OptIdent ya) = equal_naturala x ya;

val equal_opt_ident = {equala = equal_opt_identa} : opt_ident equal;

val one_integera : int = (1 : IntInf.int);

val one_integer = {one = one_integera} : int one;

type 'a plus = {plusa : 'a -> 'a -> 'a};
val plusa = #plusa : 'a plus -> 'a -> 'a -> 'a;

val plus_integer = {plusa = (fn a => fn b => a + b)} : int plus;

val zero_integer = {zero = (0 : IntInf.int)} : int zero;

type 'a zero_neq_one = {one_zero_neq_one : 'a one, zero_zero_neq_one : 'a zero};
val one_zero_neq_one = #one_zero_neq_one : 'a zero_neq_one -> 'a one;
val zero_zero_neq_one = #zero_zero_neq_one : 'a zero_neq_one -> 'a zero;

val zero_neq_one_integer = {one_zero_neq_one = one_integer, zero_zero_neq_one = zero_integer} : int zero_neq_one;

val equal_natural = {equala = equal_naturala} : Code_Numeral.natural equal;

val one_natural = {one = Code_Numeral.one_natural} : Code_Numeral.natural one;

val plus_natural = {plusa = Code_Numeral.plus_natural} : Code_Numeral.natural plus;

val zero_natural = {zero = Code_Numeral.zero_natural} : Code_Numeral.natural zero;

datatype gcc_attribute = GCC_AttribID of abr_string | GCC_AttribFn of abr_string * expr list | OWNED_BY of abr_string;

fun equal_gcc_attributea (GCC_AttribFn (x21, x22)) (OWNED_BY x3) = false
  | equal_gcc_attributea (OWNED_BY x3) (GCC_AttribFn (x21, x22)) = false
  | equal_gcc_attributea (GCC_AttribID x1) (OWNED_BY x3) = false
  | equal_gcc_attributea (OWNED_BY x3) (GCC_AttribID x1) = false
  | equal_gcc_attributea (GCC_AttribID x1) (GCC_AttribFn (x21, x22)) = false
  | equal_gcc_attributea (GCC_AttribFn (x21, x22)) (GCC_AttribID x1) = false
  | equal_gcc_attributea (OWNED_BY x3) (OWNED_BY y3) = equal_abr_stringa x3 y3
  | equal_gcc_attributea (GCC_AttribFn (x21, x22)) (GCC_AttribFn (y21, y22)) = equal_abr_stringa x21 y21 andalso equal_lista equal_expr x22 y22
  | equal_gcc_attributea (GCC_AttribID x1) (GCC_AttribID y1) = equal_abr_stringa x1 y1;

val equal_gcc_attribute = {equala = equal_gcc_attributea} : gcc_attribute equal;

datatype opt_attr_type = OptInh | OptOwn;

fun equal_opt_attr_typea OptInh OptOwn = false
  | equal_opt_attr_typea OptOwn OptInh = false
  | equal_opt_attr_typea OptOwn OptOwn = true
  | equal_opt_attr_typea OptInh OptInh = true;

val equal_opt_attr_type = {equala = equal_opt_attr_typea} : opt_attr_type equal;

datatype internal_oid = Oid of Code_Numeral.natural;

fun equal_internal_oida (Oid x) (Oid ya) = equal_naturala x ya;

val equal_internal_oid = {equala = equal_internal_oida} : internal_oid equal;

datatype generation_lemma_mode = Gen_sorry | Gen_no_dirty;

fun equal_generation_lemma_modea Gen_sorry Gen_no_dirty = false
  | equal_generation_lemma_modea Gen_no_dirty Gen_sorry = false
  | equal_generation_lemma_modea Gen_no_dirty Gen_no_dirty = true
  | equal_generation_lemma_modea Gen_sorry Gen_sorry = true;

val equal_generation_lemma_mode = {equala = equal_generation_lemma_modea} : generation_lemma_mode equal;

datatype 'a word = Word of inta;

datatype ('a, 'b) nsplit = Nsplit_text of 'a | Nsplit_sep of 'b;

datatype ('b, 'a) alist = Alist of ('b * 'a) list;

datatype ('a, 'b) sum = Inl of 'a | Inr of 'b;

datatype thyName = ThyName of abr_string;

datatype name = QName of thyName * abr_string | Name of abr_string;

datatype function_Kind = Definition | Primrec | Fun | Function_Sorry;

datatype typea = Typea of name * typea list | Func of typea * typea | TVar of name | NoType;

datatype typeSign = TypeSign of name * (name * name list) list * typea;

datatype literal = Int of Code_Numeral.natural | Stringa of abr_string;

datatype term = Literal of literal | Const of name | Abs of name * term | App of term * term | If of term * term * term | Let of (term * term) list * term | Case of term * (term * term) list | ListCompr of term * listComprFragment list
  | RecConstr of name * (name * term) list | RecUpdate of term * (name * term) list | DoBlock of abr_string * doBlockFragment list * abr_string | Parenthesized of term
and doBlockFragment = DoGenerator of term * term | DoQualifier of term | DoLetStmt of (term * term) list
and listComprFragment = Generator of (term * term) | Guard of term;

datatype function_Stmt = Function_Stmt of function_Kind * typeSign list * ((name * term list) * term) list;

datatype typeSpec = TypeSpec of name list * name;

datatype stmt = Datatype of (typeSpec * (name * typea list) list) list | Record of typeSpec * (name * typea) list | TypeSynonym of (typeSpec * typea) list | Functiona of function_Stmt | Class of name * name list * typeSign list |
  Instance of name * name * (name * name list) list * function_Stmt list | Comment of abr_string | SML of function_Stmt;

datatype typ = Typeb of abr_string * typ list | TFree of abr_string * abr_string list | TVara of (abr_string * Code_Numeral.natural) * abr_string list;

datatype fnspec = Fnspec of abr_string region_Wrap | Relspec of abr_string region_Wrap | Fn_modifies of abr_string list | Didnt_translate | Gcc_attribs of gcc_attribute list;

datatype semi_typ = Typ_apply of semi_typ * semi_typ list | Typ_apply_bin of abr_string * semi_typ * semi_typ | Typ_apply_paren of abr_string * abr_string * semi_typ | Typ_base of abr_string;

datatype terma = Consta of abr_string * typ | Free of abr_string * typ | Var of (abr_string * Code_Numeral.natural) * typ | Bound of Code_Numeral.natural | Absa of abr_string * typ * terma | Appa of terma * terma;

datatype semi_terma = Term_rewrite of semi_terma * abr_string * semi_terma | Term_basic of abr_string list | Term_annot of semi_terma * semi_typ | Term_bind of abr_string * semi_terma * semi_terma |
  Term_fun_case of semi_terma option * (semi_terma * semi_terma) list | Term_apply of semi_terma * semi_terma list | Term_paren of abr_string * abr_string * semi_terma | Term_if_then_else of semi_terma * semi_terma * semi_terma |
  Term_let of (semi_terma * semi_terma) list * semi_terma | Term_term of abr_string list * terma;

datatype 'a semi_locale_ext = Semi_locale_ext of abr_string * ((semi_terma * semi_typ) list * (abr_string * semi_terma) option) list * 'a;

datatype semi_thm_attribute = Thm_thm of abr_string | Thm_thms of abr_string | Thm_THEN of semi_thm_attribute * semi_thm_attribute | Thm_simplified of semi_thm_attribute * semi_thm_attribute | Thm_symmetric of semi_thm_attribute |
  Thm_where of semi_thm_attribute * (abr_string * semi_terma) list | Thm_of of semi_thm_attribute * semi_terma list | Thm_OF of semi_thm_attribute * semi_thm_attribute;

datatype semi_thm = Thms_single of semi_thm_attribute | Thms_mult of semi_thm_attribute;

datatype semi_method_simp = Method_simp_only of semi_thm list | Method_simp_add_del_split of semi_thm list * semi_thm list * semi_thm list;

datatype semi_method = Method_rule of semi_thm_attribute option | Method_drule of semi_thm_attribute | Method_erule of semi_thm_attribute | Method_intro of semi_thm_attribute list | Method_elim of semi_thm_attribute |
  Method_subst of bool * abr_string list * semi_thm_attribute | Method_insert of semi_thm list | Method_plus of semi_method list | Method_option of semi_method list | Method_or of semi_method list | Method_one of semi_method_simp |
  Method_all of semi_method_simp | Method_auto_simp_add_split of semi_thm list * abr_string list | Method_rename_tac of abr_string list | Method_case_tac of semi_terma | Method_blast of Code_Numeral.natural option | Method_clarify |
  Method_metis of abr_string list * semi_thm_attribute list;

datatype semi_command_final = Command_done | Command_by of semi_method list | Command_sorry;

datatype interpretation = Interpretation of abr_string * abr_string * semi_terma list * semi_command_final;

datatype axiomatization = Axiomatization of abr_string * semi_terma;

datatype type_notation = Type_notation of abr_string * abr_string;

datatype instantiation = Instantiation of abr_string * abr_string * semi_terma;

datatype code_reflect = Code_reflect of bool * abr_string * abr_string list;

datatype type_synonym = Type_synonym of (abr_string * abr_string list) * semi_typ;

datatype abbreviation = Abbreviation of semi_terma;

datatype overloading = Overloading of abr_string * semi_terma * abr_string * semi_terma;

datatype hide_const = Hide_const of bool * abr_string list;

datatype definition = Definitiona of semi_terma | Definition_where1 of abr_string * (semi_terma * Code_Numeral.natural) * semi_terma | Definition_where2 of abr_string * semi_terma * semi_terma;

datatype text_raw = Text_raw of abr_string;

datatype semi_datatype_version = Datatype_new | Datatype_old | Datatype_old_atomic | Datatype_old_atomic_sub;

datatype datatypea = Datatypea of semi_datatype_version * ((abr_string * abr_string list) * (abr_string * semi_typ list) list) list;

datatype section = Section of Code_Numeral.natural * abr_string;

datatype lemmas = Lemmas_simp_thm of bool * abr_string * semi_thm_attribute list | Lemmas_simp_thms of abr_string * abr_string list;

datatype consts = Consts of abr_string * semi_typ * abr_string;

datatype semi_val_fun = Sval | Sfun;

datatype semi_term = SML_top of semi_term_1 list
and semi_term_0 = SML_string of abr_string | SML_rewrite of semi_term_0 * abr_string * semi_term_0 | SML_basic of abr_string list | SML_binop of semi_term_0 * abr_string * semi_term_0 | SML_annot of semi_term_0 * abr_string |
  SML_function of (semi_term_0 * semi_term_0) list | SML_apply of semi_term_0 * semi_term_0 list | SML_paren of abr_string * abr_string * semi_term_0 | SML_let of semi_term * semi_term_0
and semi_term_1 = SML_open of abr_string | SML_val_fun of semi_val_fun option * semi_term_0;

datatype setup = Setup of semi_term;

datatype semi_command_state = Command_apply_end of semi_method list;

datatype semi_command_proof = Command_apply of semi_method list | Command_using of semi_thm list | Command_unfolding of semi_thm list | Command_let of semi_terma * semi_terma |
  Command_have of abr_string * bool * semi_terma * semi_command_final | Command_fix_let of abr_string list * (semi_terma * semi_terma) list * (semi_terma list * semi_terma list) option * semi_command_state list;

datatype lemma = Lemma of abr_string * semi_terma list * (semi_method list) list * semi_command_final | Lemma_assumes of abr_string * (abr_string * (bool * semi_terma)) list * semi_terma * semi_command_proof list * semi_command_final;

datatype text = Text of abr_string;

datatype thm = Thm of semi_thm_attribute list;

datatype ml = SMLa of semi_term;

datatype semi_theory = Theory_datatype of datatypea | Theory_type_synonym of type_synonym | Theory_type_notation of type_notation | Theory_instantiation of instantiation | Theory_overloading of overloading | Theory_consts of consts |
  Theory_definition of definition | Theory_lemmas of lemmas | Theory_lemma of lemma | Theory_axiomatization of axiomatization | Theory_section of section | Theory_text of text | Theory_text_raw of text_raw | Theory_ML of ml |
  Theory_setup of setup | Theory_thm of thm | Theory_interpretation of interpretation | Theory_hide_const of hide_const | Theory_abbreviation of abbreviation | Theory_code_reflect of code_reflect;

datatype generation_semantics_ocl = Gen_only_design | Gen_only_analysis | Gen_default;

datatype boot_generation_syntax = Boot_generation_syntax of generation_semantics_ocl;

datatype ocl_association_relation = OclAssRel of (ocl_ty_obj * unit ocl_multiplicity_ext) list;

datatype ocl_association_type = OclAssTy_native_attribute | OclAssTy_association | OclAssTy_composition | OclAssTy_aggregation;

datatype 'a ocl_association_ext = Ocl_association_ext of ocl_association_type * ocl_association_relation * 'a;

datatype ocl_ctxt_term = T_pure of terma * abr_string option | T_to_be_parsed of abr_string * abr_string | T_lambda of abr_string * ocl_ctxt_term;

datatype ocl_prop = OclProp_ctxt of abr_string option * ocl_ctxt_term;

datatype ocl_ctxt_term_inv = T_inv of bool * ocl_prop;

datatype ocl_ctxt_prefix = OclCtxtPre | OclCtxtPost;

datatype ocl_ctxt_term_pp = T_pp of ocl_ctxt_prefix * ocl_prop | T_invariant of ocl_ctxt_term_inv;

datatype 'a ocl_ctxt_pre_post_ext = Ocl_ctxt_pre_post_ext of abr_string * ocl_ty * ocl_ctxt_term_pp list * 'a;

datatype ocl_ctxt_clause = Ctxt_pp of unit ocl_ctxt_pre_post_ext | Ctxt_inv of ocl_ctxt_term_inv;

datatype 'a ocl_class_raw_ext = Ocl_class_raw_ext of ocl_ty_obj * (abr_string * ocl_ty) list * ocl_ctxt_clause list * bool * 'a;

datatype ocl_def_base = OclDefInteger of abr_string | OclDefReal of (abr_string * abr_string) | OclDefString of abr_string;

datatype ocl_data_shallow = ShallB_term of ocl_def_base | ShallB_str of abr_string | ShallB_self of internal_oid | ShallB_list of ocl_data_shallow list;

datatype 'a ocl_list_attr = OclAttrNoCast of 'a | OclAttrCast of abr_string * 'a ocl_list_attr * 'a;

datatype 'a ocl_instance_single_ext = Ocl_instance_single_ext of abr_string option * abr_string option * abr_string option * (((abr_string * abr_string) option * (abr_string * ocl_data_shallow)) list) ocl_list_attr * 'a;

datatype 'a ocl_def_state_core = OclDefCoreAdd of unit ocl_instance_single_ext | OclDefCoreBinding of 'a;

datatype ocl_def_pp_core = OclDefPPCoreAdd of abr_string ocl_def_state_core list | OclDefPPCoreBinding of abr_string;

datatype ocl_def_transition = OclDefPP of abr_string option * ocl_def_pp_core * ocl_def_pp_core option;

datatype ocl_def_base_l = OclDefBase of ocl_def_base list;

datatype ocl_class_tree = OclClassTree of Code_Numeral.natural * Code_Numeral.natural;

datatype ocl_def_state = OclDefSt of abr_string * abr_string ocl_def_state_core list;

datatype ocl_instance = OclInstance of unit ocl_instance_single_ext list;

datatype 'a ocl_ctxt_ext = Ocl_ctxt_ext of abr_string list * ocl_ty_obj * ocl_ctxt_clause list * 'a;

datatype ocl_class_synonym = OclClassSynonym of abr_string * ocl_ty;

datatype ocl_flush_all = OclFlushAll;

datatype ocl_ass_class = OclAssClass of unit ocl_association_ext * unit ocl_class_raw_ext;

datatype ocl_generic = OclGeneric of abr_string;

datatype ocl_enum = OclEnum of abr_string * abr_string list;

datatype gen_meta = Gen_apply_hol of abr_string | Gen_apply_sml of abr_string | Gen_apply_sml_cmd of abr_string * abr_string | Gen_no_apply;

datatype module = Module of thyName * thyName list * stmt list * bool;

datatype isaUnit = IsaUnit of (bool * Code_Numeral.natural) * (abr_string * abr_string option) list * gen_meta * abr_string * (module list * bool);

datatype floor = Floor1 | Floor2 | Floor3;

datatype all_meta_embedding = META_enum of ocl_enum | META_class_raw of floor * unit ocl_class_raw_ext | META_association of unit ocl_association_ext | META_ass_class of floor * ocl_ass_class | META_ctxt of floor * unit ocl_ctxt_ext |
  META_haskell of isaUnit | META_class_synonym of ocl_class_synonym | META_instance of ocl_instance | META_def_base_l of ocl_def_base_l | META_def_state of floor * ocl_def_state | META_def_transition of floor * ocl_def_transition |
  META_class_tree of ocl_class_tree | META_flush_all of ocl_flush_all | META_generic of ocl_generic;

datatype semi_theories = Theories_one of semi_theory | Theories_locale of unit semi_locale_ext * (semi_theory list) list;

datatype internal_oids = Oids of Code_Numeral.natural * Code_Numeral.natural * Code_Numeral.natural;

datatype 'a compiler_env_config_ext =
  Compiler_env_config_ext of
    bool * (abr_string * (abr_string list * abr_string)) option * internal_oids * (Code_Numeral.natural * Code_Numeral.natural) * generation_semantics_ocl * ocl_class option * all_meta_embedding list *
      (string_b_a_s_e * (unit ocl_instance_single_ext * internal_oids)) list * (string_b_a_s_e * (internal_oids * (abr_string * unit ocl_instance_single_ext) ocl_def_state_core) list) list * bool * bool *
      (string_b_a_s_e list * string_b_a_s_e list) * string_b_a_s_e list * string_b_a_s_e list * (generation_lemma_mode option * bool) * 'a;

datatype boot_setup_env = Boot_setup_env of unit compiler_env_config_ext;

datatype all_meta = META_semi_theories of semi_theories | META_boot_generation_syntax of boot_generation_syntax | META_boot_setup_env of boot_setup_env | META_all_meta_embedding of all_meta_embedding;

datatype 'a embedding_fun = Embedding_fun_info of abr_string * 'a | Embedding_fun_simple of 'a;

datatype ('a, 'b) embedding = Embed_theories of ('a -> 'b -> all_meta list * 'b) embedding_fun list |
  Embed_locale of ('a -> 'b -> all_meta list * 'b) embedding_fun list * ('a -> 'b -> unit semi_locale_ext * 'b) * ('a -> 'b -> semi_theory list * 'b) list * ('a -> 'b -> all_meta list * 'b) embedding_fun list;

datatype 'a tree = Tree of 'a * 'a tree list;

datatype asmblock = Asmblock of abr_string * (abr_string option * (abr_string * expr)) list * (abr_string option * (abr_string * expr)) list * abr_string list;

datatype storage_class = SC_EXTERN | SC_STATIC | SC_AUTO | SC_REGISTER | SC_THRD_LOCAL;

datatype declaration = VarDecl of (expr ctype * (abr_string region_Wrap * (storage_class list * (initializer option * gcc_attribute list)))) | StructDecl of abr_string region_Wrap * (expr ctype * abr_string region_Wrap) list |
  TypeDecl of (expr ctype * abr_string region_Wrap) list | ExtFnDecl of expr ctype * abr_string region_Wrap * (expr ctype * abr_string option) list * fnspec list |
  EnumDecl of (abr_string option) region_Wrap * (abr_string region_Wrap * expr option) list;

datatype trappable = BreakT | ContinueT;

datatype block_item = BI_Stmt of statement | BI_Decl of declaration region_Wrap
and statement_node = Assign of expr * expr | AssignFnCall of expr option * expr * expr list | Chaos of expr | EmbFnCall of expr * expr * expr list | Block of block_item list | While of expr * abr_string region_Wrap option * statement |
  Trap of trappable * statement | Return of expr option | ReturnFnCall of expr * expr list | Break | Continue | IfStmt of expr * statement * statement | Switch of expr * ((expr option) list * block_item list) list | EmptyStmt |
  Auxupd of abr_string | Ghostupd of abr_string | Spec of ((abr_string * abr_string) * (statement list * abr_string)) | AsmStmt of bool * asmblock | LocalInit of expr
and statement = Stmt of statement_node region_Wrap;

datatype ext_decl = FnDefn of (expr ctype * abr_string region_Wrap) * (expr ctype * abr_string region_Wrap) list * fnspec list * (block_item list) region_Wrap | Decl of declaration region_Wrap;

datatype 'a tmp_inh = Tinh of 'a;

datatype 'a tmp_sub = Tsub of 'a;

datatype namea = Name0 of int;

datatype position = EQ | LT | GT | UN;

datatype 'a tmp_univ = Tuniv of 'a;

datatype cChar = CChar0 of char * bool | CChars0 of char list * bool;

datatype 'a flags = Flags0 of int;

datatype positiona = Position0 of int * abr_string * int * int | NoPosition0 | BuiltinPosition0 | InternalPosition0;

datatype nodeInfo = OnlyPos0 of positiona * (positiona * int) | NodeInfo0 of positiona * (positiona * int) * namea;

datatype ident = Ident0 of abr_string * int * nodeInfo;

datatype cFloat = CFloat0 of abr_string;

datatype sUERef = AnonymousRef0 of namea | NamedRef0 of ident;

datatype ('a, 'b) either = Left of 'a | Right of 'b;

datatype 'a optiona = None | Some of 'a;

datatype ('a, 'b, 'c, 'd) struct_flat = Struct_root of 'a * 'b * (('a * 'c), 'd) sum list | Struct_leaf of (('a * 'b), 'd) sum;

datatype ('a, 'b, 'c, 'd) struct_tree = Struct_tree of 'a option * 'b * ((('a, 'b, 'c, 'd) struct_tree * 'c), 'd) sum list;

datatype reporting = Warning | Error | Writeln;

datatype cString = CString0 of abr_string * bool;

datatype commentFormat = SingleLine | MultiLine;

datatype comment = Commenta of positiona * abr_string * commentFormat;

datatype ('a, 'b, 'c, 'd, 'e, 'f) declaration0 = VarDecl0 of 'a | StructDecl0_root of 'b | StructDecl0_child of 'c | TypeDecl0 of 'd | ExtFnDecl0 of 'e | EnumDecl0 of 'f;

datatype cIntFlag = FlagUnsigned0 | FlagLong0 | FlagLongLong0 | FlagImag0;

datatype cIntRepr = DecRepr0 | HexRepr0 | OctalRepr0;

datatype cInteger = CInteger0 of int * cIntRepr * cIntFlag flags;

datatype cUnaryOp = CPreIncOp0 | CPreDecOp0 | CPostIncOp0 | CPostDecOp0 | CAdrOp0 | CIndOp0 | CPlusOp0 | CMinOp0 | CCompOp0 | CNegOp0;

datatype parsing_style = Style_Haskell | Style_ML;

datatype cAssignOp = CAssignOp0 | CMulAssOp0 | CDivAssOp0 | CRmdAssOp0 | CAddAssOp0 | CSubAssOp0 | CShlAssOp0 | CShrAssOp0 | CAndAssOp0 | CXorAssOp0 | COrAssOp0;

datatype cBinaryOp = CMulOp0 | CDivOp0 | CRmdOp0 | CAddOp0 | CSubOp0 | CShlOp0 | CShrOp0 | CLeOp0 | CGrOp0 | CLeqOp0 | CGeqOp0 | CEqOp0 | CNeqOp0 | CAndOp0 | CXorOp0 | COrOp0 | CLndOp0 | CLorOp0;

datatype 'a cConstant = CIntConst0 of cInteger * 'a | CCharConst0 of cChar * 'a | CFloatConst0 of cFloat * 'a | CStrConst0 of cString * 'a;

datatype 'a class_output = C_out_OclAny | C_out_simple of 'a;

datatype 'a cFunctionSpecifier = CInlineQual0 of 'a | CNoreturnQual0 of 'a;

datatype 'a cStorageSpecifier = CAuto0 of 'a | CRegister0 of 'a | CStatic0 of 'a | CExtern0 of 'a | CTypedef0 of 'a | CThread0 of 'a;

datatype cStructTag = CStructTag0 | CUnionTag0;

datatype 'a cStringLiteral = CStrLit0 of cString * 'a;

datatype 'a cArraySize = CNoArrSize0 of bool | CArrSize0 of bool * 'a cExpression
and 'a cDerivedDeclarator = CPtrDeclr0 of 'a cTypeQualifier list * 'a | CArrDeclr0 of 'a cTypeQualifier list * 'a cArraySize * 'a | CFunDeclr0 of ((ident list), ('a cDeclaration list * bool)) either * 'a cAttribute list * 'a
and 'a cDeclarator = CDeclr0 of ident optiona * 'a cDerivedDeclarator list * 'a cStringLiteral optiona * 'a cAttribute list * 'a
and 'a cFunctionDef = CFunDef0 of 'a cDeclarationSpecifier list * 'a cDeclarator * 'a cDeclaration list * 'a cStatement * 'a
and 'a cCompoundBlockItem = CBlockStmt0 of 'a cStatement | CBlockDecl0 of 'a cDeclaration | CNestedFunDef0 of 'a cFunctionDef
and 'a cStatement = CLabel0 of ident * 'a cStatement * 'a cAttribute list * 'a | CCase0 of 'a cExpression * 'a cStatement * 'a | CCases0 of 'a cExpression * 'a cExpression * 'a cStatement * 'a | CDefault0 of 'a cStatement * 'a |
  CExpr0 of 'a cExpression optiona * 'a | CCompound0 of ident list * 'a cCompoundBlockItem list * 'a | CIf0 of 'a cExpression * 'a cStatement * 'a cStatement optiona * 'a | CSwitch0 of 'a cExpression * 'a cStatement * 'a |
  CWhile0 of 'a cExpression * 'a cStatement * bool * 'a | CFor0 of ('a cExpression optiona, 'a cDeclaration) either * 'a cExpression optiona * 'a cExpression optiona * 'a cStatement * 'a | CGoto0 of ident * 'a |
  CGotoPtr0 of 'a cExpression * 'a | CCont0 of 'a | CBreak0 of 'a | CReturn0 of 'a cExpression optiona * 'a | CAsm0 of 'a cAssemblyStatement * 'a
and 'a cExpression = CComma0 of 'a cExpression list * 'a | CAssign0 of cAssignOp * 'a cExpression * 'a cExpression * 'a | CCond0 of 'a cExpression * 'a cExpression optiona * 'a cExpression * 'a |
  CBinary0 of cBinaryOp * 'a cExpression * 'a cExpression * 'a | CCast0 of 'a cDeclaration * 'a cExpression * 'a | CUnary0 of cUnaryOp * 'a cExpression * 'a | CSizeofExpr0 of 'a cExpression * 'a | CSizeofType0 of 'a cDeclaration * 'a |
  CAlignofExpr0 of 'a cExpression * 'a | CAlignofType0 of 'a cDeclaration * 'a | CComplexReal0 of 'a cExpression * 'a | CComplexImag0 of 'a cExpression * 'a | CIndex0 of 'a cExpression * 'a cExpression * 'a |
  CCall0 of 'a cExpression * 'a cExpression list * 'a | CMember0 of 'a cExpression * ident * bool * 'a | CVar0 of ident * 'a | CConst0 of 'a cConstant |
  CCompoundLit0 of 'a cDeclaration * ('a cPartDesignator list * 'a cInitializer) list * 'a | CGenericSelection0 of 'a cExpression * ('a cDeclaration optiona * 'a cExpression) list * 'a | CStatExpr0 of 'a cStatement * 'a |
  CLabAddrExpr0 of ident * 'a | CBuiltinExpr0 of 'a cBuiltinThing
and 'a cAttribute = CAttr0 of ident * 'a cExpression list * 'a
and 'a cTypeQualifier = CConstQual0 of 'a | CVolatQual0 of 'a | CRestrQual0 of 'a | CAtomicQual0 of 'a | CAttrQual0 of 'a cAttribute | CNullableQual0 of 'a | CNonnullQual0 of 'a
and 'a cEnumeration = CEnum0 of ident optiona * ((ident * 'a cExpression optiona) list) optiona * 'a cAttribute list * 'a
and 'a cPartDesignator = CArrDesig0 of 'a cExpression * 'a | CMemberDesig0 of ident * 'a | CRangeDesig0 of 'a cExpression * 'a cExpression * 'a
and 'a cInitializer = CInitExpr0 of 'a cExpression * 'a | CInitList0 of ('a cPartDesignator list * 'a cInitializer) list * 'a
and 'a cAssemblyOperand = CAsmOperand0 of ident optiona * 'a cStringLiteral * 'a cExpression * 'a
and 'a cAssemblyStatement = CAsmStmt0 of 'a cTypeQualifier optiona * 'a cStringLiteral * 'a cAssemblyOperand list * 'a cAssemblyOperand list * 'a cStringLiteral list * 'a
and 'a cAlignmentSpecifier = CAlignAsType0 of 'a cDeclaration * 'a | CAlignAsExpr0 of 'a cExpression * 'a
and 'a cDeclarationSpecifier = CStorageSpec0 of 'a cStorageSpecifier | CTypeSpec0 of 'a cTypeSpecifier | CTypeQual0 of 'a cTypeQualifier | CFunSpec0 of 'a cFunctionSpecifier | CAlignSpec0 of 'a cAlignmentSpecifier
and 'a cDeclaration = CDecl0 of 'a cDeclarationSpecifier list * (('a cDeclarator optiona * 'a cInitializer optiona) * 'a cExpression optiona) list * 'a | CStaticAssert0 of 'a cExpression * 'a cStringLiteral * 'a
and 'a cBuiltinThing = CBuiltinVaArg0 of 'a cExpression * 'a cDeclaration * 'a | CBuiltinOffsetOf0 of 'a cDeclaration * 'a cPartDesignator list * 'a | CBuiltinTypesCompatible0 of 'a cDeclaration * 'a cDeclaration * 'a
and 'a cStructureUnion = CStruct0 of cStructTag * ident optiona * ('a cDeclaration list) optiona * 'a cAttribute list * 'a
and 'a cTypeSpecifier = CVoidType0 of 'a | CCharType0 of 'a | CShortType0 of 'a | CIntType0 of 'a | CLongType0 of 'a | CFloatType0 of 'a | CDoubleType0 of 'a | CSignedType0 of 'a | CUnsigType0 of 'a | CBoolType0 of 'a |
  CComplexType0 of 'a | CInt128Type0 of 'a | CSUType0 of 'a cStructureUnion * 'a | CEnumType0 of 'a cEnumeration * 'a | CTypeDef0 of ident * 'a | CTypeOfExpr0 of 'a cExpression * 'a | CTypeOfType0 of 'a cDeclaration * 'a |
  CAtomicType0 of 'a cDeclaration * 'a;

datatype fold_all_input = Fold_meta of all_meta_embedding | Fold_custom of all_meta list;

datatype clangCVersion = ClangCVersion0 of abr_string;

datatype 'a cExternalDeclaration = CDeclExt0 of 'a cDeclaration | CFDefExt0 of 'a cFunctionDef | CAsmExt0 of 'a cStringLiteral * 'a;

datatype 'a cTranslationUnit = CTranslUnit0 of 'a cExternalDeclaration list * 'a;

datatype 'a comment_type = Invariant of char list | Fnspeca of (char list * char list) list | Relspeca of char list | Modifies of ((char list) option) list | Dont_translate | Auxupda of char list | Ghostupda of char list |
  Speca of (char list * char list) | End_spec of char list | Calls of ((char list) option) list | Owned_by of char list | OTHER of 'a;

datatype ('a, 'b) inheritance_ext = Inheritance_ext of 'a * ('a * 'a list) list * 'a list * 'b;

datatype 'a lexical_ext = Lexical_ext of abr_string * abr_string * (abr_string -> semi_terma) * 'a;

datatype print_examp_instance_draw_list_attr = Return_obj of unit ocl_ty_class_ext | Return_exp of semi_terma;

datatype print_examp_instance_draw_list_attr_err = Return_err_ty of (ocl_ty * ocl_data_shallow) | Return_err_ty_auto | Return_ocl_null | Return_ocl_invalid | Return_object_variable of abr_string |
  Return_err_l of print_examp_instance_draw_list_attr_err list;

datatype 'a print_examp_instance_draw_list_attra = Return_val of 'a | Return_err of print_examp_instance_draw_list_attr_err;

datatype ('a, 'b) print_iskindof_up_istypeof_output = M_simp_only of 'a | M_erule of 'b | M_simp_d_e_p_t_h_1 | M_simp_d_e_p_t_h_2 | M_simp_b_r_e_a_d_t_h;

fun id x = (fn xa => xa) x;

fun plus_nat m n = Nat (integer_of_nat m + integer_of_nat n);

fun suc n = plus_nat n one_nat;

fun d_output_header_thy
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = d_output_header_thy;

fun d_ocl_semantics
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = d_ocl_semantics;

fun flattena x = String_concatWith (SS_base (ST ""), x);

fun flattenb a b = flattena [a, b];

fun foldl f a [] = a
  | foldl f a (x :: xs) = foldl f (f a x) xs;

fun fold f (x :: xs) s = fold f xs (f x s)
  | fold f [] s = s;

fun rev xs = fold (fn a => fn b => a :: b) xs [];

fun map f l = rev (foldl (fn la => fn x => f x :: la) [] l);

fun replace_integers f s1 s s2 =
  flattenb s1 (flattenb (case s of NONE => SS_base (ST "")
                          | SOME sa => flattena (map f ((List.map (fn c => let val k = Char.ord c in if k < 128 then IntInf.fromInt k else raise Fail "Non-ASCII character in literal" end)  o String.explode) sa)))
                s2);

fun map_gena replace g = (fn a => (case a of ST s => replace (SS_base (ST "")) (SOME s) (SS_base (ST "")) | STa s => flattena (map g s)));

fun mapa f [] = []
  | mapa f (x21 :: x22) = f x21 :: mapa f x22;

fun map_gen replace g e = (case e of SS_base a => map_gena replace g a | String_concatWith (abr, l) => String_concatWith (map_gen replace g abr, mapa (map_gen replace g) l));

fun replace_integersa f = map_gen (replace_integers f) f;

fun mapM f l accu = let
                      val a = fold (fn x => fn (la, accua) => let
                                                                val a = f x accua;
                                                                val (xa, aa) = a;
                                                              in
                                                                (xa :: la, aa)
                                                              end)
                                l ([], accu);
                      val (la, aa) = a;
                    in
                      (rev la, aa)
                    end;

fun start_map f = mapM (fn x => (fn a => (f x, a)));

fun start_mapf f fl =
  (fn env => start_map f (fl (flattenb (case d_output_header_thy env of NONE => SS_base (ST "") | SOME (n_thy, (_, _)) => replace_integersa (fn n => (if n = (95 : IntInf.int) then SS_base (ST "-") else SS_base (STa [n]))) n_thy))
                           (d_ocl_semantics env))
               env);

fun i x = META_semi_theories o Theories_one o x;

fun text x = i Theory_text x;

fun txt f = Embedding_fun_simple (start_mapf text o (fn _ => fn n_thy => fn design_analysis => [Text (f n_thy design_analysis)]));

fun minus_nat m n = Nat (max ord_integer (0 : IntInf.int) (integer_of_nat m - integer_of_nat n));

fun nth (x :: xs) n = (if equal_nata n zero_nata then x else nth xs (minus_nat n one_nat));

fun less_nat m n = integer_of_nat m < integer_of_nat n;

fun upt i j = (if less_nat i j then i :: upt (suc i) j else []);

fun zip (x :: xs) (y :: ys) = (x, y) :: zip xs ys
  | zip xs [] = []
  | zip [] ys = [];

fun app_rev x f = f x;

val current_parsing_style : parsing_style = Style_ML;

fun function_definition_params0 f =
  (fn a => (case a of [] => mapa f [] | CDecl0 ([], list2, xa) :: lista => mapa f (CDecl0 ([], list2, xa) :: lista)
             | CDecl0 (ab :: listb, list2, xa) :: lista =>
               (case ab of CStorageSpec0 cStorageSpecifier => mapa f (CDecl0 (CStorageSpec0 cStorageSpecifier :: listb, list2, xa) :: lista)
                 | CTypeSpec0 (CVoidType0 x) =>
                   (case listb of [] => (case list2 of [] => (case lista of [] => [] | ad :: listaa => mapa f (CDecl0 ([CTypeSpec0 (CVoidType0 x)], [], xa) :: ad :: listaa))
                                          | ad :: listba => mapa f (CDecl0 ([CTypeSpec0 (CVoidType0 x)], ad :: listba, xa) :: lista))
                     | ad :: listc => mapa f (CDecl0 (CTypeSpec0 (CVoidType0 x) :: ad :: listc, list2, xa) :: lista))
                 | CTypeSpec0 (CCharType0 aba) => mapa f (CDecl0 (CTypeSpec0 (CCharType0 aba) :: listb, list2, xa) :: lista) | CTypeSpec0 (CShortType0 aba) => mapa f (CDecl0 (CTypeSpec0 (CShortType0 aba) :: listb, list2, xa) :: lista)
                 | CTypeSpec0 (CIntType0 aba) => mapa f (CDecl0 (CTypeSpec0 (CIntType0 aba) :: listb, list2, xa) :: lista) | CTypeSpec0 (CLongType0 aba) => mapa f (CDecl0 (CTypeSpec0 (CLongType0 aba) :: listb, list2, xa) :: lista)
                 | CTypeSpec0 (CFloatType0 aba) => mapa f (CDecl0 (CTypeSpec0 (CFloatType0 aba) :: listb, list2, xa) :: lista)
                 | CTypeSpec0 (CDoubleType0 aba) => mapa f (CDecl0 (CTypeSpec0 (CDoubleType0 aba) :: listb, list2, xa) :: lista)
                 | CTypeSpec0 (CSignedType0 aba) => mapa f (CDecl0 (CTypeSpec0 (CSignedType0 aba) :: listb, list2, xa) :: lista)
                 | CTypeSpec0 (CUnsigType0 aba) => mapa f (CDecl0 (CTypeSpec0 (CUnsigType0 aba) :: listb, list2, xa) :: lista) | CTypeSpec0 (CBoolType0 aba) => mapa f (CDecl0 (CTypeSpec0 (CBoolType0 aba) :: listb, list2, xa) :: lista)
                 | CTypeSpec0 (CComplexType0 aba) => mapa f (CDecl0 (CTypeSpec0 (CComplexType0 aba) :: listb, list2, xa) :: lista)
                 | CTypeSpec0 (CInt128Type0 aba) => mapa f (CDecl0 (CTypeSpec0 (CInt128Type0 aba) :: listb, list2, xa) :: lista)
                 | CTypeSpec0 (CSUType0 (cStructureUnion, aba)) => mapa f (CDecl0 (CTypeSpec0 (CSUType0 (cStructureUnion, aba)) :: listb, list2, xa) :: lista)
                 | CTypeSpec0 (CEnumType0 (cEnumeration, aba)) => mapa f (CDecl0 (CTypeSpec0 (CEnumType0 (cEnumeration, aba)) :: listb, list2, xa) :: lista)
                 | CTypeSpec0 (CTypeDef0 (ident, aba)) => mapa f (CDecl0 (CTypeSpec0 (CTypeDef0 (ident, aba)) :: listb, list2, xa) :: lista)
                 | CTypeSpec0 (CTypeOfExpr0 (cExpression, aba)) => mapa f (CDecl0 (CTypeSpec0 (CTypeOfExpr0 (cExpression, aba)) :: listb, list2, xa) :: lista)
                 | CTypeSpec0 (CTypeOfType0 (cDeclaration, aba)) => mapa f (CDecl0 (CTypeSpec0 (CTypeOfType0 (cDeclaration, aba)) :: listb, list2, xa) :: lista)
                 | CTypeSpec0 (CAtomicType0 (cDeclaration, aba)) => mapa f (CDecl0 (CTypeSpec0 (CAtomicType0 (cDeclaration, aba)) :: listb, list2, xa) :: lista)
                 | CTypeQual0 cTypeQualifier => mapa f (CDecl0 (CTypeQual0 cTypeQualifier :: listb, list2, xa) :: lista) | CFunSpec0 cFunctionSpecifier => mapa f (CDecl0 (CFunSpec0 cFunctionSpecifier :: listb, list2, xa) :: lista)
                 | CAlignSpec0 cAlignmentSpecifier => mapa f (CDecl0 (CAlignSpec0 cAlignmentSpecifier :: listb, list2, xa) :: lista))
             | CStaticAssert0 (cExpression, cStringLiteral, aa) :: lista => mapa f (CStaticAssert0 (cExpression, cStringLiteral, aa) :: lista)));

fun ident_struct_type0 s = flattena [s, SS_base (ST "_C")];

fun less_eq_nat m n = integer_of_nat m <= integer_of_nat n;

fun foldl_one f accu = foldl f accu o (List.map (fn c => let val k = Char.ord c in if k < 128 then IntInf.fromInt k else raise Fail "Non-ASCII character in literal" end)  o String.explode);

fun foldlb f accu = (fn a => (case a of ST aa => foldl_one f accu aa | STa aa => foldl f accu aa));

fun foldla f accu e = (case e of SS_base a => foldlb f accu a | String_concatWith (abr, a) => (case a of [] => accu | x :: aa => foldl (fn accua => foldla f (foldla f accua abr)) (foldla f accu x) aa));

fun to_list s = rev (foldla (fn l => fn c => c :: l) [] s);

fun length x = foldla (fn n => fn _ => suc n) zero_nata x;

fun pref_ident s = (if less_eq_nat one_nat (length s) andalso nth (to_list s) zero_nata = (95 : IntInf.int) then flattena [SS_base (ST "StrictC'"), s] else s);

fun ident_struct_type x = (fn Ident0 (s, _, _) => pref_ident (ident_struct_type0 s)) x;

fun decl_spec_ty_tag x = (fn a => (case a of CStructTag0 => StructTy | CUnionTag0 => UnionTy)) x;

fun map_option f = (fn a => (case a of None => NONE | Some x => SOME (f x)));

fun ident x = (fn Ident0 (s, _, _) => pref_ident s) x;

fun ident_option x = map_option ident x;

fun map_filter f [] = []
  | map_filter f (x :: xs) = (case f x of NONE => map_filter f xs | SOME y => y :: map_filter f xs);

fun identb x = (fn Ident0 (s, _, _) => Identa (pref_ident s)) x;

fun takeWhile p [] = []
  | takeWhile p (x :: xs) = (if p x then x :: takeWhile p xs else []);

fun dropWhile p [] = []
  | dropWhile p (x :: xs) = (if p x then dropWhile p xs else x :: xs);

fun groupBy cmp l = (case l of [] => [] | x :: xs => let
                                                       val cmp_x = cmp x;
                                                     in
                                                       (x :: takeWhile cmp_x xs) :: groupBy cmp (dropWhile cmp_x xs)
                                                     end);

fun tl [] = []
  | tl (x21 :: x22) = x22;

fun hd (x21 :: x22) = x21;

fun decl_spec_ty l_decl_spec =
  (case map_filter (fn a => (case a of CStorageSpec0 _ => NONE | CTypeSpec0 aa => SOME aa | CTypeQual0 _ => NONE | CFunSpec0 _ => NONE | CAlignSpec0 _ => NONE)) l_decl_spec
    of [] => let
               val (siga, l) =
                 (case hd [] of CVoidType0 _ => (NONE, []) | CCharType0 _ => (NONE, []) | CShortType0 _ => (NONE, []) | CIntType0 _ => (NONE, []) | CLongType0 _ => (NONE, []) | CFloatType0 _ => (NONE, []) | CDoubleType0 _ => (NONE, [])
                   | CSignedType0 _ => (SOME Signed, tl []) | CUnsigType0 _ => (SOME Unsigned, tl []) | CBoolType0 _ => (NONE, []) | CComplexType0 _ => (NONE, []) | CInt128Type0 _ => (NONE, []) | CSUType0 (_, _) => (NONE, [])
                   | CEnumType0 (_, _) => (NONE, []) | CTypeDef0 (_, _) => (NONE, []) | CTypeOfExpr0 (_, _) => (NONE, []) | CTypeOfType0 (_, _) => (NONE, []) | CAtomicType0 (_, _) => (NONE, []));
             in
               (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                  | [CDoubleType0 _] => Double))
                                    (groupBy (fn a => fn b =>
                                               (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                 | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                 | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                 | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                 | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                 | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                 | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                 | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                      l)
                              of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                              | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                 of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                 | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
             end
    | [CVoidType0 _] => Void
    | CVoidType0 x :: ab :: lista =>
      let
        val (siga, l) =
          (case hd (CVoidType0 x :: ab :: lista) of CVoidType0 _ => (NONE, CVoidType0 x :: ab :: lista) | CCharType0 _ => (NONE, CVoidType0 x :: ab :: lista) | CShortType0 _ => (NONE, CVoidType0 x :: ab :: lista)
            | CIntType0 _ => (NONE, CVoidType0 x :: ab :: lista) | CLongType0 _ => (NONE, CVoidType0 x :: ab :: lista) | CFloatType0 _ => (NONE, CVoidType0 x :: ab :: lista) | CDoubleType0 _ => (NONE, CVoidType0 x :: ab :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CVoidType0 x :: ab :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CVoidType0 x :: ab :: lista)) | CBoolType0 _ => (NONE, CVoidType0 x :: ab :: lista)
            | CComplexType0 _ => (NONE, CVoidType0 x :: ab :: lista) | CInt128Type0 _ => (NONE, CVoidType0 x :: ab :: lista) | CSUType0 (_, _) => (NONE, CVoidType0 x :: ab :: lista)
            | CEnumType0 (_, _) => (NONE, CVoidType0 x :: ab :: lista) | CTypeDef0 (_, _) => (NONE, CVoidType0 x :: ab :: lista) | CTypeOfExpr0 (_, _) => (NONE, CVoidType0 x :: ab :: lista)
            | CTypeOfType0 (_, _) => (NONE, CVoidType0 x :: ab :: lista) | CAtomicType0 (_, _) => (NONE, CVoidType0 x :: ab :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CCharType0 aa :: lista =>
      let
        val (siga, l) =
          (case hd (CCharType0 aa :: lista) of CVoidType0 _ => (NONE, CCharType0 aa :: lista) | CCharType0 _ => (NONE, CCharType0 aa :: lista) | CShortType0 _ => (NONE, CCharType0 aa :: lista)
            | CIntType0 _ => (NONE, CCharType0 aa :: lista) | CLongType0 _ => (NONE, CCharType0 aa :: lista) | CFloatType0 _ => (NONE, CCharType0 aa :: lista) | CDoubleType0 _ => (NONE, CCharType0 aa :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CCharType0 aa :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CCharType0 aa :: lista)) | CBoolType0 _ => (NONE, CCharType0 aa :: lista)
            | CComplexType0 _ => (NONE, CCharType0 aa :: lista) | CInt128Type0 _ => (NONE, CCharType0 aa :: lista) | CSUType0 (_, _) => (NONE, CCharType0 aa :: lista) | CEnumType0 (_, _) => (NONE, CCharType0 aa :: lista)
            | CTypeDef0 (_, _) => (NONE, CCharType0 aa :: lista) | CTypeOfExpr0 (_, _) => (NONE, CCharType0 aa :: lista) | CTypeOfType0 (_, _) => (NONE, CCharType0 aa :: lista) | CAtomicType0 (_, _) => (NONE, CCharType0 aa :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | [CShortType0 x] =>
      let
        val (siga, l) =
          (case hd [CShortType0 x] of CVoidType0 _ => (NONE, [CShortType0 x]) | CCharType0 _ => (NONE, [CShortType0 x]) | CShortType0 _ => (NONE, [CShortType0 x]) | CIntType0 _ => (NONE, [CShortType0 x])
            | CLongType0 _ => (NONE, [CShortType0 x]) | CFloatType0 _ => (NONE, [CShortType0 x]) | CDoubleType0 _ => (NONE, [CShortType0 x]) | CSignedType0 _ => (SOME Signed, tl [CShortType0 x])
            | CUnsigType0 _ => (SOME Unsigned, tl [CShortType0 x]) | CBoolType0 _ => (NONE, [CShortType0 x]) | CComplexType0 _ => (NONE, [CShortType0 x]) | CInt128Type0 _ => (NONE, [CShortType0 x])
            | CSUType0 (_, _) => (NONE, [CShortType0 x]) | CEnumType0 (_, _) => (NONE, [CShortType0 x]) | CTypeDef0 (_, _) => (NONE, [CShortType0 x]) | CTypeOfExpr0 (_, _) => (NONE, [CShortType0 x])
            | CTypeOfType0 (_, _) => (NONE, [CShortType0 x]) | CAtomicType0 (_, _) => (NONE, [CShortType0 x]));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CVoidType0 ac :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CVoidType0 ac :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CVoidType0 ac :: lista) | CCharType0 _ => (NONE, CShortType0 x :: CVoidType0 ac :: lista)
            | CShortType0 _ => (NONE, CShortType0 x :: CVoidType0 ac :: lista) | CIntType0 _ => (NONE, CShortType0 x :: CVoidType0 ac :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CVoidType0 ac :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CVoidType0 ac :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CVoidType0 ac :: lista) | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CVoidType0 ac :: lista))
            | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CVoidType0 ac :: lista)) | CBoolType0 _ => (NONE, CShortType0 x :: CVoidType0 ac :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CVoidType0 ac :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CVoidType0 ac :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CVoidType0 ac :: lista) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CVoidType0 ac :: lista)
            | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CVoidType0 ac :: lista) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CVoidType0 ac :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CVoidType0 ac :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CVoidType0 ac :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CCharType0 ac :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CCharType0 ac :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CCharType0 ac :: lista) | CCharType0 _ => (NONE, CShortType0 x :: CCharType0 ac :: lista)
            | CShortType0 _ => (NONE, CShortType0 x :: CCharType0 ac :: lista) | CIntType0 _ => (NONE, CShortType0 x :: CCharType0 ac :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CCharType0 ac :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CCharType0 ac :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CCharType0 ac :: lista) | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CCharType0 ac :: lista))
            | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CCharType0 ac :: lista)) | CBoolType0 _ => (NONE, CShortType0 x :: CCharType0 ac :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CCharType0 ac :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CCharType0 ac :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CCharType0 ac :: lista) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CCharType0 ac :: lista)
            | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CCharType0 ac :: lista) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CCharType0 ac :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CCharType0 ac :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CCharType0 ac :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CShortType0 ac :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CShortType0 ac :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CShortType0 ac :: lista) | CCharType0 _ => (NONE, CShortType0 x :: CShortType0 ac :: lista)
            | CShortType0 _ => (NONE, CShortType0 x :: CShortType0 ac :: lista) | CIntType0 _ => (NONE, CShortType0 x :: CShortType0 ac :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CShortType0 ac :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CShortType0 ac :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CShortType0 ac :: lista) | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CShortType0 ac :: lista))
            | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CShortType0 ac :: lista)) | CBoolType0 _ => (NONE, CShortType0 x :: CShortType0 ac :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CShortType0 ac :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CShortType0 ac :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CShortType0 ac :: lista) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CShortType0 ac :: lista)
            | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CShortType0 ac :: lista) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CShortType0 ac :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CShortType0 ac :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CShortType0 ac :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CIntType0 ac :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CIntType0 ac :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CIntType0 ac :: lista) | CCharType0 _ => (NONE, CShortType0 x :: CIntType0 ac :: lista)
            | CShortType0 _ => (NONE, CShortType0 x :: CIntType0 ac :: lista) | CIntType0 _ => (NONE, CShortType0 x :: CIntType0 ac :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CIntType0 ac :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CIntType0 ac :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CIntType0 ac :: lista) | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CIntType0 ac :: lista))
            | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CIntType0 ac :: lista)) | CBoolType0 _ => (NONE, CShortType0 x :: CIntType0 ac :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CIntType0 ac :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CIntType0 ac :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CIntType0 ac :: lista) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CIntType0 ac :: lista)
            | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CIntType0 ac :: lista) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CIntType0 ac :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CIntType0 ac :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CIntType0 ac :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CLongType0 ac :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CLongType0 ac :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CLongType0 ac :: lista) | CCharType0 _ => (NONE, CShortType0 x :: CLongType0 ac :: lista)
            | CShortType0 _ => (NONE, CShortType0 x :: CLongType0 ac :: lista) | CIntType0 _ => (NONE, CShortType0 x :: CLongType0 ac :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CLongType0 ac :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CLongType0 ac :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CLongType0 ac :: lista) | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CLongType0 ac :: lista))
            | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CLongType0 ac :: lista)) | CBoolType0 _ => (NONE, CShortType0 x :: CLongType0 ac :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CLongType0 ac :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CLongType0 ac :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CLongType0 ac :: lista) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CLongType0 ac :: lista)
            | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CLongType0 ac :: lista) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CLongType0 ac :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CLongType0 ac :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CLongType0 ac :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CFloatType0 ac :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CFloatType0 ac :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CFloatType0 ac :: lista) | CCharType0 _ => (NONE, CShortType0 x :: CFloatType0 ac :: lista)
            | CShortType0 _ => (NONE, CShortType0 x :: CFloatType0 ac :: lista) | CIntType0 _ => (NONE, CShortType0 x :: CFloatType0 ac :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CFloatType0 ac :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CFloatType0 ac :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CFloatType0 ac :: lista) | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CFloatType0 ac :: lista))
            | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CFloatType0 ac :: lista)) | CBoolType0 _ => (NONE, CShortType0 x :: CFloatType0 ac :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CFloatType0 ac :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CFloatType0 ac :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CFloatType0 ac :: lista) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CFloatType0 ac :: lista)
            | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CFloatType0 ac :: lista) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CFloatType0 ac :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CFloatType0 ac :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CFloatType0 ac :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CDoubleType0 ac :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CDoubleType0 ac :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CDoubleType0 ac :: lista) | CCharType0 _ => (NONE, CShortType0 x :: CDoubleType0 ac :: lista)
            | CShortType0 _ => (NONE, CShortType0 x :: CDoubleType0 ac :: lista) | CIntType0 _ => (NONE, CShortType0 x :: CDoubleType0 ac :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CDoubleType0 ac :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CDoubleType0 ac :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CDoubleType0 ac :: lista) | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CDoubleType0 ac :: lista))
            | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CDoubleType0 ac :: lista)) | CBoolType0 _ => (NONE, CShortType0 x :: CDoubleType0 ac :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CDoubleType0 ac :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CDoubleType0 ac :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CDoubleType0 ac :: lista) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CDoubleType0 ac :: lista)
            | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CDoubleType0 ac :: lista) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CDoubleType0 ac :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CDoubleType0 ac :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CDoubleType0 ac :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CSignedType0 ac :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CSignedType0 ac :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CSignedType0 ac :: lista) | CCharType0 _ => (NONE, CShortType0 x :: CSignedType0 ac :: lista)
            | CShortType0 _ => (NONE, CShortType0 x :: CSignedType0 ac :: lista) | CIntType0 _ => (NONE, CShortType0 x :: CSignedType0 ac :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CSignedType0 ac :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CSignedType0 ac :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CSignedType0 ac :: lista) | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CSignedType0 ac :: lista))
            | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CSignedType0 ac :: lista)) | CBoolType0 _ => (NONE, CShortType0 x :: CSignedType0 ac :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CSignedType0 ac :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CSignedType0 ac :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CSignedType0 ac :: lista) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CSignedType0 ac :: lista)
            | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CSignedType0 ac :: lista) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CSignedType0 ac :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CSignedType0 ac :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CSignedType0 ac :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CUnsigType0 xa :: lista =>
      (case lista of [] => let
                             val (siga, l) =
                               (case hd [CShortType0 x, CUnsigType0 xa] of CVoidType0 _ => (NONE, [CShortType0 x, CUnsigType0 xa]) | CCharType0 _ => (NONE, [CShortType0 x, CUnsigType0 xa])
                                 | CShortType0 _ => (NONE, [CShortType0 x, CUnsigType0 xa]) | CIntType0 _ => (NONE, [CShortType0 x, CUnsigType0 xa]) | CLongType0 _ => (NONE, [CShortType0 x, CUnsigType0 xa])
                                 | CFloatType0 _ => (NONE, [CShortType0 x, CUnsigType0 xa]) | CDoubleType0 _ => (NONE, [CShortType0 x, CUnsigType0 xa]) | CSignedType0 _ => (SOME Signed, tl [CShortType0 x, CUnsigType0 xa])
                                 | CUnsigType0 _ => (SOME Unsigned, tl [CShortType0 x, CUnsigType0 xa]) | CBoolType0 _ => (NONE, [CShortType0 x, CUnsigType0 xa]) | CComplexType0 _ => (NONE, [CShortType0 x, CUnsigType0 xa])
                                 | CInt128Type0 _ => (NONE, [CShortType0 x, CUnsigType0 xa]) | CSUType0 (_, _) => (NONE, [CShortType0 x, CUnsigType0 xa]) | CEnumType0 (_, _) => (NONE, [CShortType0 x, CUnsigType0 xa])
                                 | CTypeDef0 (_, _) => (NONE, [CShortType0 x, CUnsigType0 xa]) | CTypeOfExpr0 (_, _) => (NONE, [CShortType0 x, CUnsigType0 xa]) | CTypeOfType0 (_, _) => (NONE, [CShortType0 x, CUnsigType0 xa])
                                 | CAtomicType0 (_, _) => (NONE, [CShortType0 x, CUnsigType0 xa]));
                           in
                             (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong
                                                                | [CFloatType0 _] => Float | [CDoubleType0 _] => Double))
                                                  (groupBy (fn a => fn b =>
                                                             (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                               | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                               | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                               | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                               | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false
                                                               | (CLongType0 _, CTypeOfType0 (_, _)) => false | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false
                                                               | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false
                                                               | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false
                                                               | (CAtomicType0 (_, _), _) => false))
                                                    l)
                                            of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                                            | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                               of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                               | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
                           end
        | CVoidType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb))
                | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CCharType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb))
                | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CShortType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb))
                | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | [CIntType0 _] => Unsigned Short
        | CIntType0 xb :: af :: listaa =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa))
                | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa) | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa)
                | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa) | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa)
                | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa)
                | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa)
                | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb))
                | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CFloatType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb))
                | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CDoubleType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb))
                | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CSignedType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb))
                | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CUnsigType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb))
                | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CBoolType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb))
                | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CComplexType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb))
                | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CInt128Type0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb))
                | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CSUType0 (cStructureUnion, ae) :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb))
                | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)) | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CEnumType0 (cEnumeration, ae) :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb))
                | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)) | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CTypeDef0 (ident, ae) :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb))
                | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CTypeOfExpr0 (cExpression, ae) :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb))
                | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)) | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CTypeOfType0 (cDeclaration, ae) :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb))
                | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)) | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CAtomicType0 (cDeclaration, ae) :: listb =>
          let
            val (siga, l) =
              (case hd (CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) of CVoidType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CCharType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CShortType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CIntType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CLongType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CFloatType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CDoubleType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb))
                | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)) | CBoolType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CComplexType0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CInt128Type0 _ => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CSUType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end)
    | CShortType0 x :: CBoolType0 ac :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CBoolType0 ac :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CBoolType0 ac :: lista) | CCharType0 _ => (NONE, CShortType0 x :: CBoolType0 ac :: lista)
            | CShortType0 _ => (NONE, CShortType0 x :: CBoolType0 ac :: lista) | CIntType0 _ => (NONE, CShortType0 x :: CBoolType0 ac :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CBoolType0 ac :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CBoolType0 ac :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CBoolType0 ac :: lista) | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CBoolType0 ac :: lista))
            | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CBoolType0 ac :: lista)) | CBoolType0 _ => (NONE, CShortType0 x :: CBoolType0 ac :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CBoolType0 ac :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CBoolType0 ac :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CBoolType0 ac :: lista) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CBoolType0 ac :: lista)
            | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CBoolType0 ac :: lista) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CBoolType0 ac :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CBoolType0 ac :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CBoolType0 ac :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CComplexType0 ac :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CComplexType0 ac :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CComplexType0 ac :: lista) | CCharType0 _ => (NONE, CShortType0 x :: CComplexType0 ac :: lista)
            | CShortType0 _ => (NONE, CShortType0 x :: CComplexType0 ac :: lista) | CIntType0 _ => (NONE, CShortType0 x :: CComplexType0 ac :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CComplexType0 ac :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CComplexType0 ac :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CComplexType0 ac :: lista) | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CComplexType0 ac :: lista))
            | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CComplexType0 ac :: lista)) | CBoolType0 _ => (NONE, CShortType0 x :: CComplexType0 ac :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CComplexType0 ac :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CComplexType0 ac :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CComplexType0 ac :: lista) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CComplexType0 ac :: lista)
            | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CComplexType0 ac :: lista) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CComplexType0 ac :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CComplexType0 ac :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CComplexType0 ac :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CInt128Type0 ac :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CInt128Type0 ac :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CInt128Type0 ac :: lista) | CCharType0 _ => (NONE, CShortType0 x :: CInt128Type0 ac :: lista)
            | CShortType0 _ => (NONE, CShortType0 x :: CInt128Type0 ac :: lista) | CIntType0 _ => (NONE, CShortType0 x :: CInt128Type0 ac :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CInt128Type0 ac :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CInt128Type0 ac :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CInt128Type0 ac :: lista) | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CInt128Type0 ac :: lista))
            | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CInt128Type0 ac :: lista)) | CBoolType0 _ => (NONE, CShortType0 x :: CInt128Type0 ac :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CInt128Type0 ac :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CInt128Type0 ac :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CInt128Type0 ac :: lista) | CEnumType0 (_, _) => (NONE, CShortType0 x :: CInt128Type0 ac :: lista)
            | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CInt128Type0 ac :: lista) | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CInt128Type0 ac :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CInt128Type0 ac :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CInt128Type0 ac :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista)
            | CCharType0 _ => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista) | CShortType0 _ => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista)
            | CIntType0 _ => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista))
            | CBoolType0 _ => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista)
            | CEnumType0 (_, _) => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista)
            | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CSUType0 (cStructureUnion, ac) :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista)
            | CCharType0 _ => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista) | CShortType0 _ => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista)
            | CIntType0 _ => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista))
            | CBoolType0 _ => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista)
            | CEnumType0 (_, _) => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista)
            | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CEnumType0 (cEnumeration, ac) :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CTypeDef0 (ident, ac) :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CTypeDef0 (ident, ac) :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista) | CCharType0 _ => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista)
            | CShortType0 _ => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista) | CIntType0 _ => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CTypeDef0 (ident, ac) :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CTypeDef0 (ident, ac) :: lista))
            | CBoolType0 _ => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista)
            | CEnumType0 (_, _) => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista)
            | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CTypeDef0 (ident, ac) :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista)
            | CCharType0 _ => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista) | CShortType0 _ => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista)
            | CIntType0 _ => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista))
            | CBoolType0 _ => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista)
            | CEnumType0 (_, _) => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista)
            | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CTypeOfExpr0 (cExpression, ac) :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista)
            | CCharType0 _ => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista) | CShortType0 _ => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista)
            | CIntType0 _ => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista))
            | CBoolType0 _ => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista)
            | CEnumType0 (_, _) => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista)
            | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CTypeOfType0 (cDeclaration, ac) :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista =>
      let
        val (siga, l) =
          (case hd (CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista) of CVoidType0 _ => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista)
            | CCharType0 _ => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista) | CShortType0 _ => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista)
            | CIntType0 _ => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista) | CLongType0 _ => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista)
            | CFloatType0 _ => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista) | CDoubleType0 _ => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista))
            | CBoolType0 _ => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista) | CComplexType0 _ => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista)
            | CInt128Type0 _ => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista) | CSUType0 (_, _) => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista)
            | CEnumType0 (_, _) => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista) | CTypeDef0 (_, _) => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista)
            | CTypeOfExpr0 (_, _) => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista) | CTypeOfType0 (_, _) => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista)
            | CAtomicType0 (_, _) => (NONE, CShortType0 x :: CAtomicType0 (cDeclaration, ac) :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CIntType0 aa :: lista =>
      let
        val (siga, l) =
          (case hd (CIntType0 aa :: lista) of CVoidType0 _ => (NONE, CIntType0 aa :: lista) | CCharType0 _ => (NONE, CIntType0 aa :: lista) | CShortType0 _ => (NONE, CIntType0 aa :: lista) | CIntType0 _ => (NONE, CIntType0 aa :: lista)
            | CLongType0 _ => (NONE, CIntType0 aa :: lista) | CFloatType0 _ => (NONE, CIntType0 aa :: lista) | CDoubleType0 _ => (NONE, CIntType0 aa :: lista) | CSignedType0 _ => (SOME Signed, tl (CIntType0 aa :: lista))
            | CUnsigType0 _ => (SOME Unsigned, tl (CIntType0 aa :: lista)) | CBoolType0 _ => (NONE, CIntType0 aa :: lista) | CComplexType0 _ => (NONE, CIntType0 aa :: lista) | CInt128Type0 _ => (NONE, CIntType0 aa :: lista)
            | CSUType0 (_, _) => (NONE, CIntType0 aa :: lista) | CEnumType0 (_, _) => (NONE, CIntType0 aa :: lista) | CTypeDef0 (_, _) => (NONE, CIntType0 aa :: lista) | CTypeOfExpr0 (_, _) => (NONE, CIntType0 aa :: lista)
            | CTypeOfType0 (_, _) => (NONE, CIntType0 aa :: lista) | CAtomicType0 (_, _) => (NONE, CIntType0 aa :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CLongType0 x :: lista =>
      (case lista of [] => let
                             val (siga, l) =
                               (case hd [CLongType0 x] of CVoidType0 _ => (NONE, [CLongType0 x]) | CCharType0 _ => (NONE, [CLongType0 x]) | CShortType0 _ => (NONE, [CLongType0 x]) | CIntType0 _ => (NONE, [CLongType0 x])
                                 | CLongType0 _ => (NONE, [CLongType0 x]) | CFloatType0 _ => (NONE, [CLongType0 x]) | CDoubleType0 _ => (NONE, [CLongType0 x]) | CSignedType0 _ => (SOME Signed, tl [CLongType0 x])
                                 | CUnsigType0 _ => (SOME Unsigned, tl [CLongType0 x]) | CBoolType0 _ => (NONE, [CLongType0 x]) | CComplexType0 _ => (NONE, [CLongType0 x]) | CInt128Type0 _ => (NONE, [CLongType0 x])
                                 | CSUType0 (_, _) => (NONE, [CLongType0 x]) | CEnumType0 (_, _) => (NONE, [CLongType0 x]) | CTypeDef0 (_, _) => (NONE, [CLongType0 x]) | CTypeOfExpr0 (_, _) => (NONE, [CLongType0 x])
                                 | CTypeOfType0 (_, _) => (NONE, [CLongType0 x]) | CAtomicType0 (_, _) => (NONE, [CLongType0 x]));
                           in
                             (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong
                                                                | [CFloatType0 _] => Float | [CDoubleType0 _] => Double))
                                                  (groupBy (fn a => fn b =>
                                                             (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                               | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                               | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                               | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                               | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false
                                                               | (CLongType0 _, CTypeOfType0 (_, _)) => false | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false
                                                               | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false
                                                               | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false
                                                               | (CAtomicType0 (_, _), _) => false))
                                                    l)
                                            of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                                            | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                               of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                               | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
                           end
        | CVoidType0 ac :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CVoidType0 ac :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CVoidType0 ac :: listaa) | CCharType0 _ => (NONE, CLongType0 x :: CVoidType0 ac :: listaa)
                | CShortType0 _ => (NONE, CLongType0 x :: CVoidType0 ac :: listaa) | CIntType0 _ => (NONE, CLongType0 x :: CVoidType0 ac :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CVoidType0 ac :: listaa)
                | CFloatType0 _ => (NONE, CLongType0 x :: CVoidType0 ac :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CVoidType0 ac :: listaa) | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CVoidType0 ac :: listaa))
                | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CVoidType0 ac :: listaa)) | CBoolType0 _ => (NONE, CLongType0 x :: CVoidType0 ac :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CVoidType0 ac :: listaa)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CVoidType0 ac :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CVoidType0 ac :: listaa) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CVoidType0 ac :: listaa)
                | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CVoidType0 ac :: listaa) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CVoidType0 ac :: listaa) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CVoidType0 ac :: listaa)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CVoidType0 ac :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CCharType0 ac :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CCharType0 ac :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CCharType0 ac :: listaa) | CCharType0 _ => (NONE, CLongType0 x :: CCharType0 ac :: listaa)
                | CShortType0 _ => (NONE, CLongType0 x :: CCharType0 ac :: listaa) | CIntType0 _ => (NONE, CLongType0 x :: CCharType0 ac :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CCharType0 ac :: listaa)
                | CFloatType0 _ => (NONE, CLongType0 x :: CCharType0 ac :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CCharType0 ac :: listaa) | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CCharType0 ac :: listaa))
                | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CCharType0 ac :: listaa)) | CBoolType0 _ => (NONE, CLongType0 x :: CCharType0 ac :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CCharType0 ac :: listaa)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CCharType0 ac :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CCharType0 ac :: listaa) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CCharType0 ac :: listaa)
                | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CCharType0 ac :: listaa) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CCharType0 ac :: listaa) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CCharType0 ac :: listaa)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CCharType0 ac :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CShortType0 ac :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CShortType0 ac :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CShortType0 ac :: listaa) | CCharType0 _ => (NONE, CLongType0 x :: CShortType0 ac :: listaa)
                | CShortType0 _ => (NONE, CLongType0 x :: CShortType0 ac :: listaa) | CIntType0 _ => (NONE, CLongType0 x :: CShortType0 ac :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CShortType0 ac :: listaa)
                | CFloatType0 _ => (NONE, CLongType0 x :: CShortType0 ac :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CShortType0 ac :: listaa) | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CShortType0 ac :: listaa))
                | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CShortType0 ac :: listaa)) | CBoolType0 _ => (NONE, CLongType0 x :: CShortType0 ac :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CShortType0 ac :: listaa)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CShortType0 ac :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CShortType0 ac :: listaa) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CShortType0 ac :: listaa)
                | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CShortType0 ac :: listaa) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CShortType0 ac :: listaa) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CShortType0 ac :: listaa)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CShortType0 ac :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CIntType0 ac :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CIntType0 ac :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CIntType0 ac :: listaa) | CCharType0 _ => (NONE, CLongType0 x :: CIntType0 ac :: listaa)
                | CShortType0 _ => (NONE, CLongType0 x :: CIntType0 ac :: listaa) | CIntType0 _ => (NONE, CLongType0 x :: CIntType0 ac :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CIntType0 ac :: listaa)
                | CFloatType0 _ => (NONE, CLongType0 x :: CIntType0 ac :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CIntType0 ac :: listaa) | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CIntType0 ac :: listaa))
                | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CIntType0 ac :: listaa)) | CBoolType0 _ => (NONE, CLongType0 x :: CIntType0 ac :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CIntType0 ac :: listaa)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CIntType0 ac :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CIntType0 ac :: listaa) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CIntType0 ac :: listaa)
                | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CIntType0 ac :: listaa) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CIntType0 ac :: listaa) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CIntType0 ac :: listaa)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CIntType0 ac :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | [CLongType0 xa] =>
          let
            val (siga, l) =
              (case hd [CLongType0 x, CLongType0 xa] of CVoidType0 _ => (NONE, [CLongType0 x, CLongType0 xa]) | CCharType0 _ => (NONE, [CLongType0 x, CLongType0 xa]) | CShortType0 _ => (NONE, [CLongType0 x, CLongType0 xa])
                | CIntType0 _ => (NONE, [CLongType0 x, CLongType0 xa]) | CLongType0 _ => (NONE, [CLongType0 x, CLongType0 xa]) | CFloatType0 _ => (NONE, [CLongType0 x, CLongType0 xa])
                | CDoubleType0 _ => (NONE, [CLongType0 x, CLongType0 xa]) | CSignedType0 _ => (SOME Signed, tl [CLongType0 x, CLongType0 xa]) | CUnsigType0 _ => (SOME Unsigned, tl [CLongType0 x, CLongType0 xa])
                | CBoolType0 _ => (NONE, [CLongType0 x, CLongType0 xa]) | CComplexType0 _ => (NONE, [CLongType0 x, CLongType0 xa]) | CInt128Type0 _ => (NONE, [CLongType0 x, CLongType0 xa])
                | CSUType0 (_, _) => (NONE, [CLongType0 x, CLongType0 xa]) | CEnumType0 (_, _) => (NONE, [CLongType0 x, CLongType0 xa]) | CTypeDef0 (_, _) => (NONE, [CLongType0 x, CLongType0 xa])
                | CTypeOfExpr0 (_, _) => (NONE, [CLongType0 x, CLongType0 xa]) | CTypeOfType0 (_, _) => (NONE, [CLongType0 x, CLongType0 xa]) | CAtomicType0 (_, _) => (NONE, [CLongType0 x, CLongType0 xa]));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CVoidType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb))
                | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CVoidType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CCharType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb))
                | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CCharType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CShortType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb))
                | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CShortType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CIntType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb))
                | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CIntType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CLongType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb))
                | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CLongType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CFloatType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb))
                | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CFloatType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CDoubleType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb))
                | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CDoubleType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CSignedType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb))
                | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CSignedType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CUnsigType0 xb :: listb =>
          (case listb of [] => let
                                 val (siga, l) =
                                   (case hd [CLongType0 x, CLongType0 xa, CUnsigType0 xb] of CVoidType0 _ => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb]) | CCharType0 _ => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb])
                                     | CShortType0 _ => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb]) | CIntType0 _ => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb])
                                     | CLongType0 _ => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb]) | CFloatType0 _ => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb])
                                     | CDoubleType0 _ => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb]) | CSignedType0 _ => (SOME Signed, tl [CLongType0 x, CLongType0 xa, CUnsigType0 xb])
                                     | CUnsigType0 _ => (SOME Unsigned, tl [CLongType0 x, CLongType0 xa, CUnsigType0 xb]) | CBoolType0 _ => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb])
                                     | CComplexType0 _ => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb]) | CInt128Type0 _ => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb])
                                     | CSUType0 (_, _) => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb]) | CEnumType0 (_, _) => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb])
                                     | CTypeDef0 (_, _) => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb]) | CTypeOfExpr0 (_, _) => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb])
                                     | CTypeOfType0 (_, _) => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb]) | CAtomicType0 (_, _) => (NONE, [CLongType0 x, CLongType0 xa, CUnsigType0 xb]));
                               in
                                 (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong
                                                                    | [CFloatType0 _] => Float | [CDoubleType0 _] => Double))
                                                      (groupBy (fn a => fn b =>
                                                                 (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                                   | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                                   | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                                   | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                                   | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false
                                                                   | (CLongType0 _, CTypeOfType0 (_, _)) => false | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false
                                                                   | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false
                                                                   | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false
                                                                   | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                                        l)
                                                of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                                                | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                                   of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                                   | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
                               end
            | CVoidType0 ag :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa)) | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa)
                    | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa) | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa)
                    | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CVoidType0 ag :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CCharType0 ag :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa)) | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa)
                    | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa) | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa)
                    | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CCharType0 ag :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CShortType0 ag :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CShortType0 ag :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | [CIntType0 _] => Unsigned LongLong
            | CIntType0 xc :: ah :: listc =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CIntType0 xc :: ah :: listc));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CLongType0 ag :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa)) | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa)
                    | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa) | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa)
                    | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CLongType0 ag :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CFloatType0 ag :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CFloatType0 ag :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CDoubleType0 ag :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CDoubleType0 ag :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CSignedType0 ag :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSignedType0 ag :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CUnsigType0 ag :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CUnsigType0 ag :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CBoolType0 ag :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa)) | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa)
                    | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa) | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa)
                    | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CBoolType0 ag :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CComplexType0 ag :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CComplexType0 ag :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CInt128Type0 ag :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CInt128Type0 ag :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CSUType0 (cStructureUnion, ag) :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CSUType0 (cStructureUnion, ag) :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CEnumType0 (cEnumeration, ag) :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CEnumType0 (cEnumeration, ag) :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CTypeDef0 (ident, ag) :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa)
                    | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa)
                    | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa)
                    | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa)
                    | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeDef0 (ident, ag) :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CTypeOfExpr0 (cExpression, ag) :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfExpr0 (cExpression, ag) :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CTypeOfType0 (cDeclaration, ag) :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CTypeOfType0 (cDeclaration, ag) :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CAtomicType0 (cDeclaration, ag) :: listaa =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CUnsigType0 xb :: CAtomicType0 (cDeclaration, ag) :: listaa));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end)
        | CLongType0 xa :: CBoolType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb))
                | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CBoolType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CComplexType0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb))
                | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CComplexType0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CInt128Type0 ae :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb))
                | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CInt128Type0 ae :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb))
                | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)) | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CSUType0 (cStructureUnion, ae) :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb))
                | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)) | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CEnumType0 (cEnumeration, ae) :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CTypeDef0 (ident, ae) :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb))
                | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeDef0 (ident, ae) :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb))
                | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)) | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb))
                | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)) | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CCharType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CIntType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CFloatType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb))
                | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)) | CBoolType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CComplexType0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CInt128Type0 _ => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CSUType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CLongType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CFloatType0 ac :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CFloatType0 ac :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CFloatType0 ac :: listaa) | CCharType0 _ => (NONE, CLongType0 x :: CFloatType0 ac :: listaa)
                | CShortType0 _ => (NONE, CLongType0 x :: CFloatType0 ac :: listaa) | CIntType0 _ => (NONE, CLongType0 x :: CFloatType0 ac :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CFloatType0 ac :: listaa)
                | CFloatType0 _ => (NONE, CLongType0 x :: CFloatType0 ac :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CFloatType0 ac :: listaa) | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CFloatType0 ac :: listaa))
                | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CFloatType0 ac :: listaa)) | CBoolType0 _ => (NONE, CLongType0 x :: CFloatType0 ac :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CFloatType0 ac :: listaa)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CFloatType0 ac :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CFloatType0 ac :: listaa) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CFloatType0 ac :: listaa)
                | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CFloatType0 ac :: listaa) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CFloatType0 ac :: listaa) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CFloatType0 ac :: listaa)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CFloatType0 ac :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CDoubleType0 ac :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CDoubleType0 ac :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa) | CCharType0 _ => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa)
                | CShortType0 _ => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa) | CIntType0 _ => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa)
                | CFloatType0 _ => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa) | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CDoubleType0 ac :: listaa))
                | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CDoubleType0 ac :: listaa)) | CBoolType0 _ => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa)
                | CComplexType0 _ => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa) | CInt128Type0 _ => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa)
                | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa) | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CDoubleType0 ac :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CSignedType0 ac :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CSignedType0 ac :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CSignedType0 ac :: listaa) | CCharType0 _ => (NONE, CLongType0 x :: CSignedType0 ac :: listaa)
                | CShortType0 _ => (NONE, CLongType0 x :: CSignedType0 ac :: listaa) | CIntType0 _ => (NONE, CLongType0 x :: CSignedType0 ac :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CSignedType0 ac :: listaa)
                | CFloatType0 _ => (NONE, CLongType0 x :: CSignedType0 ac :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CSignedType0 ac :: listaa) | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CSignedType0 ac :: listaa))
                | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CSignedType0 ac :: listaa)) | CBoolType0 _ => (NONE, CLongType0 x :: CSignedType0 ac :: listaa)
                | CComplexType0 _ => (NONE, CLongType0 x :: CSignedType0 ac :: listaa) | CInt128Type0 _ => (NONE, CLongType0 x :: CSignedType0 ac :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CSignedType0 ac :: listaa)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CSignedType0 ac :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CSignedType0 ac :: listaa) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CSignedType0 ac :: listaa)
                | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CSignedType0 ac :: listaa) | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CSignedType0 ac :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CUnsigType0 xa :: listaa =>
          (case listaa of [] => let
                                  val (siga, l) =
                                    (case hd [CLongType0 x, CUnsigType0 xa] of CVoidType0 _ => (NONE, [CLongType0 x, CUnsigType0 xa]) | CCharType0 _ => (NONE, [CLongType0 x, CUnsigType0 xa])
                                      | CShortType0 _ => (NONE, [CLongType0 x, CUnsigType0 xa]) | CIntType0 _ => (NONE, [CLongType0 x, CUnsigType0 xa]) | CLongType0 _ => (NONE, [CLongType0 x, CUnsigType0 xa])
                                      | CFloatType0 _ => (NONE, [CLongType0 x, CUnsigType0 xa]) | CDoubleType0 _ => (NONE, [CLongType0 x, CUnsigType0 xa]) | CSignedType0 _ => (SOME Signed, tl [CLongType0 x, CUnsigType0 xa])
                                      | CUnsigType0 _ => (SOME Unsigned, tl [CLongType0 x, CUnsigType0 xa]) | CBoolType0 _ => (NONE, [CLongType0 x, CUnsigType0 xa]) | CComplexType0 _ => (NONE, [CLongType0 x, CUnsigType0 xa])
                                      | CInt128Type0 _ => (NONE, [CLongType0 x, CUnsigType0 xa]) | CSUType0 (_, _) => (NONE, [CLongType0 x, CUnsigType0 xa]) | CEnumType0 (_, _) => (NONE, [CLongType0 x, CUnsigType0 xa])
                                      | CTypeDef0 (_, _) => (NONE, [CLongType0 x, CUnsigType0 xa]) | CTypeOfExpr0 (_, _) => (NONE, [CLongType0 x, CUnsigType0 xa]) | CTypeOfType0 (_, _) => (NONE, [CLongType0 x, CUnsigType0 xa])
                                      | CAtomicType0 (_, _) => (NONE, [CLongType0 x, CUnsigType0 xa]));
                                in
                                  (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong
                                                                     | [CFloatType0 _] => Float | [CDoubleType0 _] => Double))
                                                       (groupBy (fn a => fn b =>
                                                                  (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                                    | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                                    | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                                    | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                                    | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false
                                                                    | (CLongType0 _, CTypeOfType0 (_, _)) => false | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false
                                                                    | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false
                                                                    | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false
                                                                    | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                                         l)
                                                 of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                                                 | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                                    of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                                    | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
                                end
            | CVoidType0 ae :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CVoidType0 ae :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CCharType0 ae :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CCharType0 ae :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CShortType0 ae :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CShortType0 ae :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | [CIntType0 _] => Unsigned Long
            | CIntType0 xb :: af :: listab =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab) | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab) | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CIntType0 xb :: af :: listab));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CLongType0 ae :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CLongType0 ae :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CFloatType0 ae :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CFloatType0 ae :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CDoubleType0 ae :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CDoubleType0 ae :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CSignedType0 ae :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CSignedType0 ae :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CUnsigType0 ae :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CUnsigType0 ae :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CBoolType0 ae :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CBoolType0 ae :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CComplexType0 ae :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CComplexType0 ae :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CInt128Type0 ae :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CInt128Type0 ae :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CSUType0 (cStructureUnion, ae) :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)) | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                    | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                    | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb) | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CSUType0 (cStructureUnion, ae) :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CEnumType0 (cEnumeration, ae) :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)) | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                    | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                    | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb) | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CEnumType0 (cEnumeration, ae) :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CTypeDef0 (ident, ae) :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb))
                    | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                    | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                    | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                    | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeDef0 (ident, ae) :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CTypeOfExpr0 (cExpression, ae) :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)) | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                    | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                    | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb) | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfExpr0 (cExpression, ae) :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CTypeOfType0 (cDeclaration, ae) :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)) | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                    | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                    | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CTypeOfType0 (cDeclaration, ae) :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end
            | CAtomicType0 (cDeclaration, ae) :: listb =>
              let
                val (siga, l) =
                  (case hd (CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) of CVoidType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                    | CCharType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CShortType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                    | CIntType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CLongType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                    | CFloatType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CDoubleType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                    | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb))
                    | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)) | CBoolType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                    | CComplexType0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CInt128Type0 _ => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                    | CSUType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                    | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                    | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb)
                    | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CUnsigType0 xa :: CAtomicType0 (cDeclaration, ae) :: listb));
              in
                (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                                   | [CDoubleType0 _] => Double))
                                     (groupBy (fn a => fn b =>
                                                (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                                  | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                                  | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                                  | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                                  | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                                  | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                                  | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false
                                                  | (CTypeDef0 (_, _), _) => false | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                       l)
                               of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                               | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
                  of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
                  | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
              end)
        | CBoolType0 ac :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CBoolType0 ac :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CBoolType0 ac :: listaa) | CCharType0 _ => (NONE, CLongType0 x :: CBoolType0 ac :: listaa)
                | CShortType0 _ => (NONE, CLongType0 x :: CBoolType0 ac :: listaa) | CIntType0 _ => (NONE, CLongType0 x :: CBoolType0 ac :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CBoolType0 ac :: listaa)
                | CFloatType0 _ => (NONE, CLongType0 x :: CBoolType0 ac :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CBoolType0 ac :: listaa) | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CBoolType0 ac :: listaa))
                | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CBoolType0 ac :: listaa)) | CBoolType0 _ => (NONE, CLongType0 x :: CBoolType0 ac :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CBoolType0 ac :: listaa)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CBoolType0 ac :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CBoolType0 ac :: listaa) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CBoolType0 ac :: listaa)
                | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CBoolType0 ac :: listaa) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CBoolType0 ac :: listaa) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CBoolType0 ac :: listaa)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CBoolType0 ac :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CComplexType0 ac :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CComplexType0 ac :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CComplexType0 ac :: listaa) | CCharType0 _ => (NONE, CLongType0 x :: CComplexType0 ac :: listaa)
                | CShortType0 _ => (NONE, CLongType0 x :: CComplexType0 ac :: listaa) | CIntType0 _ => (NONE, CLongType0 x :: CComplexType0 ac :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CComplexType0 ac :: listaa)
                | CFloatType0 _ => (NONE, CLongType0 x :: CComplexType0 ac :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CComplexType0 ac :: listaa)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CComplexType0 ac :: listaa)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CComplexType0 ac :: listaa))
                | CBoolType0 _ => (NONE, CLongType0 x :: CComplexType0 ac :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CComplexType0 ac :: listaa) | CInt128Type0 _ => (NONE, CLongType0 x :: CComplexType0 ac :: listaa)
                | CSUType0 (_, _) => (NONE, CLongType0 x :: CComplexType0 ac :: listaa) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CComplexType0 ac :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CComplexType0 ac :: listaa)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CComplexType0 ac :: listaa) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CComplexType0 ac :: listaa)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CComplexType0 ac :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CInt128Type0 ac :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CInt128Type0 ac :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa) | CCharType0 _ => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa)
                | CShortType0 _ => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa) | CIntType0 _ => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa)
                | CFloatType0 _ => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa) | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CInt128Type0 ac :: listaa))
                | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CInt128Type0 ac :: listaa)) | CBoolType0 _ => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa)
                | CComplexType0 _ => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa) | CInt128Type0 _ => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa)
                | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa) | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CInt128Type0 ac :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CSUType0 (cStructureUnion, ac) :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa)
                | CCharType0 _ => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa)
                | CIntType0 _ => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa)
                | CFloatType0 _ => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa))
                | CBoolType0 _ => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CSUType0 (cStructureUnion, ac) :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CEnumType0 (cEnumeration, ac) :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa)
                | CCharType0 _ => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa)
                | CIntType0 _ => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa)
                | CFloatType0 _ => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa))
                | CBoolType0 _ => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CEnumType0 (cEnumeration, ac) :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CTypeDef0 (ident, ac) :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CTypeDef0 (ident, ac) :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa) | CCharType0 _ => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa)
                | CShortType0 _ => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa) | CIntType0 _ => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa)
                | CLongType0 _ => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa) | CFloatType0 _ => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa)
                | CDoubleType0 _ => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa) | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CTypeDef0 (ident, ac) :: listaa))
                | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CTypeDef0 (ident, ac) :: listaa)) | CBoolType0 _ => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa)
                | CComplexType0 _ => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa) | CInt128Type0 _ => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa)
                | CSUType0 (_, _) => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa) | CEnumType0 (_, _) => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa)
                | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa) | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa)
                | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa) | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CTypeDef0 (ident, ac) :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CTypeOfExpr0 (cExpression, ac) :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa)
                | CCharType0 _ => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa)
                | CIntType0 _ => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa)
                | CFloatType0 _ => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa))
                | CBoolType0 _ => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CTypeOfExpr0 (cExpression, ac) :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CTypeOfType0 (cDeclaration, ac) :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa)
                | CCharType0 _ => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa)
                | CIntType0 _ => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa)
                | CFloatType0 _ => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa))
                | CBoolType0 _ => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CTypeOfType0 (cDeclaration, ac) :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end
        | CAtomicType0 (cDeclaration, ac) :: listaa =>
          let
            val (siga, l) =
              (case hd (CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa) of CVoidType0 _ => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa)
                | CCharType0 _ => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa) | CShortType0 _ => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa)
                | CIntType0 _ => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa) | CLongType0 _ => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa)
                | CFloatType0 _ => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa) | CDoubleType0 _ => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa)
                | CSignedType0 _ => (SOME Signed, tl (CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa)) | CUnsigType0 _ => (SOME Unsigned, tl (CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa))
                | CBoolType0 _ => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa) | CComplexType0 _ => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa)
                | CInt128Type0 _ => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa) | CSUType0 (_, _) => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa)
                | CEnumType0 (_, _) => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa) | CTypeDef0 (_, _) => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa)
                | CTypeOfExpr0 (_, _) => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa) | CTypeOfType0 (_, _) => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa)
                | CAtomicType0 (_, _) => (NONE, CLongType0 x :: CAtomicType0 (cDeclaration, ac) :: listaa));
          in
            (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                               | [CDoubleType0 _] => Double))
                                 (groupBy (fn a => fn b =>
                                            (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                              | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                              | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                              | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                              | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                              | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                              | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                              | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                                   l)
                           of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                           | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
              of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double
              | (NONE, Float) => Signed Float | (SOME sigb, ty) => sigb ty)
          end)
    | CFloatType0 aa :: lista =>
      let
        val (siga, l) =
          (case hd (CFloatType0 aa :: lista) of CVoidType0 _ => (NONE, CFloatType0 aa :: lista) | CCharType0 _ => (NONE, CFloatType0 aa :: lista) | CShortType0 _ => (NONE, CFloatType0 aa :: lista)
            | CIntType0 _ => (NONE, CFloatType0 aa :: lista) | CLongType0 _ => (NONE, CFloatType0 aa :: lista) | CFloatType0 _ => (NONE, CFloatType0 aa :: lista) | CDoubleType0 _ => (NONE, CFloatType0 aa :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CFloatType0 aa :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CFloatType0 aa :: lista)) | CBoolType0 _ => (NONE, CFloatType0 aa :: lista)
            | CComplexType0 _ => (NONE, CFloatType0 aa :: lista) | CInt128Type0 _ => (NONE, CFloatType0 aa :: lista) | CSUType0 (_, _) => (NONE, CFloatType0 aa :: lista) | CEnumType0 (_, _) => (NONE, CFloatType0 aa :: lista)
            | CTypeDef0 (_, _) => (NONE, CFloatType0 aa :: lista) | CTypeOfExpr0 (_, _) => (NONE, CFloatType0 aa :: lista) | CTypeOfType0 (_, _) => (NONE, CFloatType0 aa :: lista)
            | CAtomicType0 (_, _) => (NONE, CFloatType0 aa :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CDoubleType0 aa :: lista =>
      let
        val (siga, l) =
          (case hd (CDoubleType0 aa :: lista) of CVoidType0 _ => (NONE, CDoubleType0 aa :: lista) | CCharType0 _ => (NONE, CDoubleType0 aa :: lista) | CShortType0 _ => (NONE, CDoubleType0 aa :: lista)
            | CIntType0 _ => (NONE, CDoubleType0 aa :: lista) | CLongType0 _ => (NONE, CDoubleType0 aa :: lista) | CFloatType0 _ => (NONE, CDoubleType0 aa :: lista) | CDoubleType0 _ => (NONE, CDoubleType0 aa :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CDoubleType0 aa :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CDoubleType0 aa :: lista)) | CBoolType0 _ => (NONE, CDoubleType0 aa :: lista)
            | CComplexType0 _ => (NONE, CDoubleType0 aa :: lista) | CInt128Type0 _ => (NONE, CDoubleType0 aa :: lista) | CSUType0 (_, _) => (NONE, CDoubleType0 aa :: lista) | CEnumType0 (_, _) => (NONE, CDoubleType0 aa :: lista)
            | CTypeDef0 (_, _) => (NONE, CDoubleType0 aa :: lista) | CTypeOfExpr0 (_, _) => (NONE, CDoubleType0 aa :: lista) | CTypeOfType0 (_, _) => (NONE, CDoubleType0 aa :: lista)
            | CAtomicType0 (_, _) => (NONE, CDoubleType0 aa :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CSignedType0 aa :: lista =>
      let
        val (siga, l) =
          (case hd (CSignedType0 aa :: lista) of CVoidType0 _ => (NONE, CSignedType0 aa :: lista) | CCharType0 _ => (NONE, CSignedType0 aa :: lista) | CShortType0 _ => (NONE, CSignedType0 aa :: lista)
            | CIntType0 _ => (NONE, CSignedType0 aa :: lista) | CLongType0 _ => (NONE, CSignedType0 aa :: lista) | CFloatType0 _ => (NONE, CSignedType0 aa :: lista) | CDoubleType0 _ => (NONE, CSignedType0 aa :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CSignedType0 aa :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CSignedType0 aa :: lista)) | CBoolType0 _ => (NONE, CSignedType0 aa :: lista)
            | CComplexType0 _ => (NONE, CSignedType0 aa :: lista) | CInt128Type0 _ => (NONE, CSignedType0 aa :: lista) | CSUType0 (_, _) => (NONE, CSignedType0 aa :: lista) | CEnumType0 (_, _) => (NONE, CSignedType0 aa :: lista)
            | CTypeDef0 (_, _) => (NONE, CSignedType0 aa :: lista) | CTypeOfExpr0 (_, _) => (NONE, CSignedType0 aa :: lista) | CTypeOfType0 (_, _) => (NONE, CSignedType0 aa :: lista)
            | CAtomicType0 (_, _) => (NONE, CSignedType0 aa :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CUnsigType0 aa :: lista =>
      let
        val (siga, l) =
          (case hd (CUnsigType0 aa :: lista) of CVoidType0 _ => (NONE, CUnsigType0 aa :: lista) | CCharType0 _ => (NONE, CUnsigType0 aa :: lista) | CShortType0 _ => (NONE, CUnsigType0 aa :: lista)
            | CIntType0 _ => (NONE, CUnsigType0 aa :: lista) | CLongType0 _ => (NONE, CUnsigType0 aa :: lista) | CFloatType0 _ => (NONE, CUnsigType0 aa :: lista) | CDoubleType0 _ => (NONE, CUnsigType0 aa :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CUnsigType0 aa :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CUnsigType0 aa :: lista)) | CBoolType0 _ => (NONE, CUnsigType0 aa :: lista)
            | CComplexType0 _ => (NONE, CUnsigType0 aa :: lista) | CInt128Type0 _ => (NONE, CUnsigType0 aa :: lista) | CSUType0 (_, _) => (NONE, CUnsigType0 aa :: lista) | CEnumType0 (_, _) => (NONE, CUnsigType0 aa :: lista)
            | CTypeDef0 (_, _) => (NONE, CUnsigType0 aa :: lista) | CTypeOfExpr0 (_, _) => (NONE, CUnsigType0 aa :: lista) | CTypeOfType0 (_, _) => (NONE, CUnsigType0 aa :: lista)
            | CAtomicType0 (_, _) => (NONE, CUnsigType0 aa :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | [CBoolType0 _] => Bool
    | CBoolType0 x :: ab :: lista =>
      let
        val (siga, l) =
          (case hd (CBoolType0 x :: ab :: lista) of CVoidType0 _ => (NONE, CBoolType0 x :: ab :: lista) | CCharType0 _ => (NONE, CBoolType0 x :: ab :: lista) | CShortType0 _ => (NONE, CBoolType0 x :: ab :: lista)
            | CIntType0 _ => (NONE, CBoolType0 x :: ab :: lista) | CLongType0 _ => (NONE, CBoolType0 x :: ab :: lista) | CFloatType0 _ => (NONE, CBoolType0 x :: ab :: lista) | CDoubleType0 _ => (NONE, CBoolType0 x :: ab :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CBoolType0 x :: ab :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CBoolType0 x :: ab :: lista)) | CBoolType0 _ => (NONE, CBoolType0 x :: ab :: lista)
            | CComplexType0 _ => (NONE, CBoolType0 x :: ab :: lista) | CInt128Type0 _ => (NONE, CBoolType0 x :: ab :: lista) | CSUType0 (_, _) => (NONE, CBoolType0 x :: ab :: lista)
            | CEnumType0 (_, _) => (NONE, CBoolType0 x :: ab :: lista) | CTypeDef0 (_, _) => (NONE, CBoolType0 x :: ab :: lista) | CTypeOfExpr0 (_, _) => (NONE, CBoolType0 x :: ab :: lista)
            | CTypeOfType0 (_, _) => (NONE, CBoolType0 x :: ab :: lista) | CAtomicType0 (_, _) => (NONE, CBoolType0 x :: ab :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CComplexType0 aa :: lista =>
      let
        val (siga, l) =
          (case hd (CComplexType0 aa :: lista) of CVoidType0 _ => (NONE, CComplexType0 aa :: lista) | CCharType0 _ => (NONE, CComplexType0 aa :: lista) | CShortType0 _ => (NONE, CComplexType0 aa :: lista)
            | CIntType0 _ => (NONE, CComplexType0 aa :: lista) | CLongType0 _ => (NONE, CComplexType0 aa :: lista) | CFloatType0 _ => (NONE, CComplexType0 aa :: lista) | CDoubleType0 _ => (NONE, CComplexType0 aa :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CComplexType0 aa :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CComplexType0 aa :: lista)) | CBoolType0 _ => (NONE, CComplexType0 aa :: lista)
            | CComplexType0 _ => (NONE, CComplexType0 aa :: lista) | CInt128Type0 _ => (NONE, CComplexType0 aa :: lista) | CSUType0 (_, _) => (NONE, CComplexType0 aa :: lista) | CEnumType0 (_, _) => (NONE, CComplexType0 aa :: lista)
            | CTypeDef0 (_, _) => (NONE, CComplexType0 aa :: lista) | CTypeOfExpr0 (_, _) => (NONE, CComplexType0 aa :: lista) | CTypeOfType0 (_, _) => (NONE, CComplexType0 aa :: lista)
            | CAtomicType0 (_, _) => (NONE, CComplexType0 aa :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CInt128Type0 aa :: lista =>
      let
        val (siga, l) =
          (case hd (CInt128Type0 aa :: lista) of CVoidType0 _ => (NONE, CInt128Type0 aa :: lista) | CCharType0 _ => (NONE, CInt128Type0 aa :: lista) | CShortType0 _ => (NONE, CInt128Type0 aa :: lista)
            | CIntType0 _ => (NONE, CInt128Type0 aa :: lista) | CLongType0 _ => (NONE, CInt128Type0 aa :: lista) | CFloatType0 _ => (NONE, CInt128Type0 aa :: lista) | CDoubleType0 _ => (NONE, CInt128Type0 aa :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CInt128Type0 aa :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CInt128Type0 aa :: lista)) | CBoolType0 _ => (NONE, CInt128Type0 aa :: lista)
            | CComplexType0 _ => (NONE, CInt128Type0 aa :: lista) | CInt128Type0 _ => (NONE, CInt128Type0 aa :: lista) | CSUType0 (_, _) => (NONE, CInt128Type0 aa :: lista) | CEnumType0 (_, _) => (NONE, CInt128Type0 aa :: lista)
            | CTypeDef0 (_, _) => (NONE, CInt128Type0 aa :: lista) | CTypeOfExpr0 (_, _) => (NONE, CInt128Type0 aa :: lista) | CTypeOfType0 (_, _) => (NONE, CInt128Type0 aa :: lista)
            | CAtomicType0 (_, _) => (NONE, CInt128Type0 aa :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | [CSUType0 (CStruct0 (tag, ide, _, _, _), _)] => decl_spec_ty_tag tag let
                                                                             val Some a = ide;
                                                                           in
                                                                             ident_struct_type a
                                                                           end
    | CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista =>
      let
        val (siga, l) =
          (case hd (CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista) of CVoidType0 _ => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista)
            | CCharType0 _ => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista) | CShortType0 _ => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista)
            | CIntType0 _ => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista) | CLongType0 _ => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista)
            | CFloatType0 _ => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista) | CDoubleType0 _ => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista))
            | CBoolType0 _ => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista) | CComplexType0 _ => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista)
            | CInt128Type0 _ => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista) | CSUType0 (_, _) => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista)
            | CEnumType0 (_, _) => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista) | CTypeDef0 (_, _) => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista)
            | CTypeOfExpr0 (_, _) => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista) | CTypeOfType0 (_, _) => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista)
            | CAtomicType0 (_, _) => (NONE, CSUType0 (CStruct0 (tag, ide, x, xa, xb), xc) :: ad :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | [CEnumType0 (CEnum0 (ide, _, _, _), _)] => EnumTy (ident_option ide)
    | CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista =>
      let
        val (siga, l) =
          (case hd (CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista) of CVoidType0 _ => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista)
            | CCharType0 _ => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista) | CShortType0 _ => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista)
            | CIntType0 _ => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista) | CLongType0 _ => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista)
            | CFloatType0 _ => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista) | CDoubleType0 _ => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista)
            | CSignedType0 _ => (SOME Signed, tl (CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista))
            | CBoolType0 _ => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista) | CComplexType0 _ => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista)
            | CInt128Type0 _ => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista) | CSUType0 (_, _) => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista)
            | CEnumType0 (_, _) => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista) | CTypeDef0 (_, _) => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista)
            | CTypeOfExpr0 (_, _) => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista) | CTypeOfType0 (_, _) => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista)
            | CAtomicType0 (_, _) => (NONE, CEnumType0 (CEnum0 (ide, x, xa, xb), xc) :: ad :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | [CTypeDef0 (i, _)] => identb i
    | CTypeDef0 (i, x) :: ab :: lista =>
      let
        val (siga, l) =
          (case hd (CTypeDef0 (i, x) :: ab :: lista) of CVoidType0 _ => (NONE, CTypeDef0 (i, x) :: ab :: lista) | CCharType0 _ => (NONE, CTypeDef0 (i, x) :: ab :: lista) | CShortType0 _ => (NONE, CTypeDef0 (i, x) :: ab :: lista)
            | CIntType0 _ => (NONE, CTypeDef0 (i, x) :: ab :: lista) | CLongType0 _ => (NONE, CTypeDef0 (i, x) :: ab :: lista) | CFloatType0 _ => (NONE, CTypeDef0 (i, x) :: ab :: lista)
            | CDoubleType0 _ => (NONE, CTypeDef0 (i, x) :: ab :: lista) | CSignedType0 _ => (SOME Signed, tl (CTypeDef0 (i, x) :: ab :: lista)) | CUnsigType0 _ => (SOME Unsigned, tl (CTypeDef0 (i, x) :: ab :: lista))
            | CBoolType0 _ => (NONE, CTypeDef0 (i, x) :: ab :: lista) | CComplexType0 _ => (NONE, CTypeDef0 (i, x) :: ab :: lista) | CInt128Type0 _ => (NONE, CTypeDef0 (i, x) :: ab :: lista)
            | CSUType0 (_, _) => (NONE, CTypeDef0 (i, x) :: ab :: lista) | CEnumType0 (_, _) => (NONE, CTypeDef0 (i, x) :: ab :: lista) | CTypeDef0 (_, _) => (NONE, CTypeDef0 (i, x) :: ab :: lista)
            | CTypeOfExpr0 (_, _) => (NONE, CTypeDef0 (i, x) :: ab :: lista) | CTypeOfType0 (_, _) => (NONE, CTypeDef0 (i, x) :: ab :: lista) | CAtomicType0 (_, _) => (NONE, CTypeDef0 (i, x) :: ab :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CTypeOfExpr0 (cExpression, aa) :: lista =>
      let
        val (siga, l) =
          (case hd (CTypeOfExpr0 (cExpression, aa) :: lista) of CVoidType0 _ => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista) | CCharType0 _ => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista)
            | CShortType0 _ => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista) | CIntType0 _ => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista) | CLongType0 _ => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista)
            | CFloatType0 _ => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista) | CDoubleType0 _ => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista) | CSignedType0 _ => (SOME Signed, tl (CTypeOfExpr0 (cExpression, aa) :: lista))
            | CUnsigType0 _ => (SOME Unsigned, tl (CTypeOfExpr0 (cExpression, aa) :: lista)) | CBoolType0 _ => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista) | CComplexType0 _ => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista)
            | CInt128Type0 _ => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista) | CSUType0 (_, _) => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista) | CEnumType0 (_, _) => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista)
            | CTypeDef0 (_, _) => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista) | CTypeOfExpr0 (_, _) => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista) | CTypeOfType0 (_, _) => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista)
            | CAtomicType0 (_, _) => (NONE, CTypeOfExpr0 (cExpression, aa) :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CTypeOfType0 (cDeclaration, aa) :: lista =>
      let
        val (siga, l) =
          (case hd (CTypeOfType0 (cDeclaration, aa) :: lista) of CVoidType0 _ => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista) | CCharType0 _ => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista)
            | CShortType0 _ => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista) | CIntType0 _ => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista) | CLongType0 _ => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista)
            | CFloatType0 _ => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista) | CDoubleType0 _ => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista) | CSignedType0 _ => (SOME Signed, tl (CTypeOfType0 (cDeclaration, aa) :: lista))
            | CUnsigType0 _ => (SOME Unsigned, tl (CTypeOfType0 (cDeclaration, aa) :: lista)) | CBoolType0 _ => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista) | CComplexType0 _ => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista)
            | CInt128Type0 _ => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista) | CSUType0 (_, _) => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista) | CEnumType0 (_, _) => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista)
            | CTypeDef0 (_, _) => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista) | CTypeOfExpr0 (_, _) => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista) | CTypeOfType0 (_, _) => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista)
            | CAtomicType0 (_, _) => (NONE, CTypeOfType0 (cDeclaration, aa) :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end
    | CAtomicType0 (cDeclaration, aa) :: lista =>
      let
        val (siga, l) =
          (case hd (CAtomicType0 (cDeclaration, aa) :: lista) of CVoidType0 _ => (NONE, CAtomicType0 (cDeclaration, aa) :: lista) | CCharType0 _ => (NONE, CAtomicType0 (cDeclaration, aa) :: lista)
            | CShortType0 _ => (NONE, CAtomicType0 (cDeclaration, aa) :: lista) | CIntType0 _ => (NONE, CAtomicType0 (cDeclaration, aa) :: lista) | CLongType0 _ => (NONE, CAtomicType0 (cDeclaration, aa) :: lista)
            | CFloatType0 _ => (NONE, CAtomicType0 (cDeclaration, aa) :: lista) | CDoubleType0 _ => (NONE, CAtomicType0 (cDeclaration, aa) :: lista) | CSignedType0 _ => (SOME Signed, tl (CAtomicType0 (cDeclaration, aa) :: lista))
            | CUnsigType0 _ => (SOME Unsigned, tl (CAtomicType0 (cDeclaration, aa) :: lista)) | CBoolType0 _ => (NONE, CAtomicType0 (cDeclaration, aa) :: lista) | CComplexType0 _ => (NONE, CAtomicType0 (cDeclaration, aa) :: lista)
            | CInt128Type0 _ => (NONE, CAtomicType0 (cDeclaration, aa) :: lista) | CSUType0 (_, _) => (NONE, CAtomicType0 (cDeclaration, aa) :: lista) | CEnumType0 (_, _) => (NONE, CAtomicType0 (cDeclaration, aa) :: lista)
            | CTypeDef0 (_, _) => (NONE, CAtomicType0 (cDeclaration, aa) :: lista) | CTypeOfExpr0 (_, _) => (NONE, CAtomicType0 (cDeclaration, aa) :: lista) | CTypeOfType0 (_, _) => (NONE, CAtomicType0 (cDeclaration, aa) :: lista)
            | CAtomicType0 (_, _) => (NONE, CAtomicType0 (cDeclaration, aa) :: lista));
      in
        (case (siga, (case mapa (fn a => (case a of [CCharType0 _] => Charb | [CShortType0 _] => Short | [CIntType0 _] => Inta | [CLongType0 _] => Long | [CLongType0 _, CLongType0 _] => LongLong | [CFloatType0 _] => Float
                                           | [CDoubleType0 _] => Double))
                             (groupBy (fn a => fn b =>
                                        (case (a, b) of (CVoidType0 _, _) => false | (CCharType0 _, _) => false | (CShortType0 _, _) => false | (CIntType0 _, _) => false | (CLongType0 _, CVoidType0 _) => false
                                          | (CLongType0 _, CCharType0 _) => false | (CLongType0 _, CShortType0 _) => false | (CLongType0 _, CIntType0 _) => false | (CLongType0 _, CLongType0 _) => true
                                          | (CLongType0 _, CFloatType0 _) => false | (CLongType0 _, CDoubleType0 _) => false | (CLongType0 _, CSignedType0 _) => false | (CLongType0 _, CUnsigType0 _) => false
                                          | (CLongType0 _, CBoolType0 _) => false | (CLongType0 _, CComplexType0 _) => false | (CLongType0 _, CInt128Type0 _) => false | (CLongType0 _, CSUType0 (_, _)) => false
                                          | (CLongType0 _, CEnumType0 (_, _)) => false | (CLongType0 _, CTypeDef0 (_, _)) => false | (CLongType0 _, CTypeOfExpr0 (_, _)) => false | (CLongType0 _, CTypeOfType0 (_, _)) => false
                                          | (CLongType0 _, CAtomicType0 (_, _)) => false | (CFloatType0 _, _) => false | (CDoubleType0 _, _) => false | (CSignedType0 _, _) => false | (CUnsigType0 _, _) => false
                                          | (CBoolType0 _, _) => false | (CComplexType0 _, _) => false | (CInt128Type0 _, _) => false | (CSUType0 (_, _), _) => false | (CEnumType0 (_, _), _) => false | (CTypeDef0 (_, _), _) => false
                                          | (CTypeOfExpr0 (_, _), _) => false | (CTypeOfType0 (_, _), _) => false | (CAtomicType0 (_, _), _) => false))
                               l)
                       of [] => Inta | [Charb] => Charb | [Short] => Short | [Short, Inta] => Short | [Inta] => Inta | [Long] => Long | [Long, Inta] => Long | [Long, Double] => Double | [LongLong] => LongLong
                       | [LongLong, Inta] => LongLong | [Double] => Double | [Float] => Float))
          of (NONE, Charb) => PlainChar | (NONE, Short) => Signed Short | (NONE, Inta) => Signed Inta | (NONE, Long) => Signed Long | (NONE, LongLong) => Signed LongLong | (NONE, Double) => Signed Double | (NONE, Float) => Signed Float
          | (SOME sigb, ty) => sigb ty)
      end);

fun ident_struct_const x = (fn Ident0 (s, _, _) => pref_ident (flattena [s, SS_base (ST "_C")])) x;

fun meta_of_logic x = ((String.implode o List.map (fn k => if 0 <= k andalso k < 128 then (Char.chr o IntInf.toInt) k else raise Fail "Non-ASCII character in literal")) o to_list) x;

fun not_yet_supported x = (warning o meta_of_logic) x;

fun map_prod f g (a, b) = (f a, g b);

val bogus : sourcePos = Ta ((~1 : IntInf.int), SS_base (ST "<bogus>"), (~1 : IntInf.int));

fun comp2 f g = (fn x => fn y => f (g x y));

fun wrap x = comp2 (fn a => Tb (x, a)) (fn a => fn b => T (a, b));

fun bogwrap x = wrap x bogus bogus;

fun ebogwrap x = (E o bogwrap) x;

fun of_boola A_ true = one (one_zero_neq_one A_)
  | of_boola A_ false = zero (zero_zero_neq_one A_);

fun integer_of_char (Chara (b0, b1, b2, b3, b4, b5, b6, b7)) =
  ((((((of_boola zero_neq_one_integer b7 * (2 : IntInf.int) + of_boola zero_neq_one_integer b6) * (2 : IntInf.int) + of_boola zero_neq_one_integer b5) * (2 : IntInf.int) + of_boola zero_neq_one_integer b4) * (2 : IntInf.int) +
      of_boola zero_neq_one_integer b3) *
      (2 : IntInf.int) +
     of_boola zero_neq_one_integer b2) *
     (2 : IntInf.int) +
    of_boola zero_neq_one_integer b1) *
    (2 : IntInf.int) +
    of_boola zero_neq_one_integer b0;

fun show_intFlag x = (fn a => (case a of FlagUnsigned0 => SS_base (ST "u") | FlagLong0 => SS_base (ST "l") | FlagLongLong0 => SS_base (ST "ll") | FlagImag0 => SS_base (ST "i"))) x;

fun apsnd f (x, y) = (x, f y);

fun divmod_integer k l =
  (if k = (0 : IntInf.int) then ((0 : IntInf.int), (0 : IntInf.int))
    else (if (0 : IntInf.int) < l then (if (0 : IntInf.int) < k then Integer.div_mod (abs k) (abs l) else let
                                                                                                            val (r, s) = Integer.div_mod (abs k) (abs l);
                                                                                                          in
                                                                                                            (if s = (0 : IntInf.int) then (~ r, (0 : IntInf.int)) else (~ r - (1 : IntInf.int), l - s))
                                                                                                          end)
           else (if l = (0 : IntInf.int) then ((0 : IntInf.int), k)
                  else apsnd (fn a => ~ a) (if k < (0 : IntInf.int) then Integer.div_mod (abs k) (abs l) else let
                                                                                                                val (r, s) = Integer.div_mod (abs k) (abs l);
                                                                                                              in
                                                                                                                (if s = (0 : IntInf.int) then (~ r, (0 : IntInf.int)) else (~ r - (1 : IntInf.int), ~ l - s))
                                                                                                              end))));

fun snd (x1, x2) = x2;

fun modulo_integer k l = snd (divmod_integer k l);

fun modulo_int k l = Int_of_integer (modulo_integer (integer_of_int k) (integer_of_int l));

fun power A_ a n = (if equal_nata n zero_nata then one (one_power A_) else times (times_power A_) a (power A_ a (minus_nat n one_nat)));

fun word_of_int A_ k = Word (modulo_int k (power power_int (Int_of_integer (2 : IntInf.int)) (len_of A_ Type)));

fun foldr f [] = id
  | foldr f (x :: xs) = f x o foldr f xs;

fun concat xss = foldr (fn a => fn b => a @ b) xss [];

fun fst (x1, x2) = x1;

fun divide_integer k l = fst (divmod_integer k l);

fun divide_int k l = Int_of_integer (divide_integer (integer_of_int k) (integer_of_int l));

fun bin_rest w = divide_int w (Int_of_integer (2 : IntInf.int));

fun equal_int k l = integer_of_int k = integer_of_int l;

fun bin_last w = equal_int (modulo_int w (Int_of_integer (2 : IntInf.int))) one_inta;

fun bin_to_bl_aux n w bl = (if equal_nata n zero_nata then bl else bin_to_bl_aux (minus_nat n one_nat) (bin_rest w) (bin_last w :: bl));

fun bin_to_bl n w = bin_to_bl_aux n w [];

fun uint A_ (Word x) = x;

fun to_bl A_ w = bin_to_bl (len_of A_ Type) (uint A_ w);

fun constant x =
  (bogwrap o (fn a => (case a of CIntConst0 (CInteger0 (i, repr, Flags0 flags), _) =>
                                NUMCONST (i, flattena (concat (rev (mapa (fn aa => (case aa of (xa, true) => [show_intFlag xa] | (_, false) => []))
                                                                     (zip [FlagImag0, FlagLongLong0, FlagLong0, FlagUnsigned0]
                                                                       (to_bl (len0_bit0 (len0_bit0 len0_num1)) (word_of_int (len0_bit0 (len0_bit0 len0_num1)) (Int_of_integer flags))))))),
                                           (case repr of DecRepr0 => DEC | HexRepr0 => HEX | OctalRepr0 => OCT))
                        | CCharConst0 (CChar0 (c, _), _) => NUMCONST (integer_of_char c, SS_base (ST ""), DEC) | CFloatConst0 (_, _) => let
                    val _ = not_yet_supported (flattena [SS_base (ST "Float not yet supported (String returned)")]);
                  in
                    STRING_LIT (SS_base (ST ""))
                  end
                        | CStrConst0 (CString0 (str, _), _) => STRING_LIT str)))
    x;

fun binaryOp x =
  (fn a => (case a of CMulOp0 => Times | CDivOp0 => Divides | CRmdOp0 => Modulus | CAddOp0 => Plus | CSubOp0 => Minus | CShlOp0 => LShift | CShrOp0 => RShift | CLeOp0 => Lt | CGrOp0 => Gt | CLeqOp0 => Leq | CGeqOp0 => Geq
             | CEqOp0 => Equals | CNeqOp0 => NotEquals | CAndOp0 => BitwiseAnd | CXorOp0 => BitwiseXOr | COrOp0 => BitwiseOr | CLndOp0 => LogAnd | CLorOp0 => LogOr))
    x;

fun unaryOp x = (fn a => (case a of CAdrOp0 => Addr | CMinOp0 => Negate | CCompOp0 => BitNegate | CNegOp0 => Not)) x;

fun deriv_decl_spec dDs = deriv_decl_spec0 dDs o decl_spec_ty
and expression0 e =
  (case e of CCond0 (e1, Some e2, e3, _) => CondExp (expression e1, expression e2, expression e3) | CBinary0 (bino, e1, e2, _) => BinOp (binaryOp bino, expression e1, expression e2)
    | CCast0 (CDecl0 (l, l_arg, _), ea, _) =>
      TypeCast (bogwrap (deriv_decl_spec (case l_arg of [] => [] | ((None, _), _) :: _ => [] | [((Some (CDeclr0 (_, dDs, _, _, _)), _), _)] => dDs | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => []) l), expression ea)
    | CUnary0 (CPreIncOp0, ea, _) => UnOp (unaryOp CPreIncOp0, expression ea) | CUnary0 (CPreDecOp0, ea, _) => UnOp (unaryOp CPreDecOp0, expression ea) | CUnary0 (CPostIncOp0, ea, _) => UnOp (unaryOp CPostIncOp0, expression ea)
    | CUnary0 (CPostDecOp0, ea, _) => UnOp (unaryOp CPostDecOp0, expression ea) | CUnary0 (CAdrOp0, ea, _) => UnOp (unaryOp CAdrOp0, expression ea) | CUnary0 (CIndOp0, ea, _) => Deref (expression ea)
    | CUnary0 (CPlusOp0, ea, _) => UnOp (unaryOp CPlusOp0, expression ea) | CUnary0 (CMinOp0, ea, _) => UnOp (unaryOp CMinOp0, expression ea) | CUnary0 (CCompOp0, ea, _) => UnOp (unaryOp CCompOp0, expression ea)
    | CUnary0 (CNegOp0, ea, _) => UnOp (unaryOp CNegOp0, expression ea) | CSizeofExpr0 (ea, _) => Sizeof (expression ea) | CSizeofType0 (CDecl0 (l, _, _), _) => SizeofTy (bogwrap (decl_spec_ty l))
    | CIndex0 (e1, e2, _) => ArrayDeref (expression e1, expression e2)
    | CCall0 (ea, l, _) =>
      (case (case ea of CComma0 (_, _) => NONE | CAssign0 (_, _, _, _) => NONE | CCond0 (_, _, _, _) => NONE | CBinary0 (_, _, _, _) => NONE | CCast0 (_, _, _) => NONE | CUnary0 (_, _, _) => NONE | CSizeofExpr0 (_, _) => NONE
              | CSizeofType0 (_, _) => NONE | CAlignofExpr0 (_, _) => NONE | CAlignofType0 (_, _) => NONE | CComplexReal0 (_, _) => NONE | CComplexImag0 (_, _) => NONE | CIndex0 (_, _, _) => NONE | CCall0 (_, _, _) => NONE
              | CMember0 (_, _, _, _) => NONE | CVar0 (Ident0 (s, _, _), _) => (if equal_abr_stringa s (SS_base (ST "__builtin_expect")) then SOME let
                               val [x, _] = l;
                             in
                               x
                             end
                                                                                 else NONE)
              | CConst0 _ => NONE | CCompoundLit0 (_, _, _) => NONE | CGenericSelection0 (_, _, _) => NONE | CStatExpr0 (_, _) => NONE | CLabAddrExpr0 (_, _) => NONE | CBuiltinExpr0 _ => NONE)
        of NONE => EFnCall (expression ea, mapa expression l) | SOME a => expression0 a)
    | CMember0 (ea, i, deref, _) => StructDot ((if deref then ebogwrap o Deref else id) (expression ea), ident_struct_const i) | CVar0 (i, _) => Vara (ident i, Unsynchronized_ref NONE) | CConst0 c => Constant (constant c)
    | CCompoundLit0 (CDecl0 (l1, _, _), l2, _) => CompLiteral (decl_spec_ty l1, initializerList l2))
and expression x = (ebogwrap o expression0) x
and partDesignator e =
  (case e of CArrDesig0 (ea, _) => DesignE (expression ea) | CMemberDesig0 (i, _) => DesignFld (ident_struct_const i)
    | CRangeDesig0 (_, _, _) => let
                                  val _ = not_yet_supported (SS_base (ST "CRangeDesig not yet supported (DesignFld returned)"));
                                in
                                  DesignFld (SS_base (ST ""))
                                end)
and initializerList l = mapa (map_prod (mapa partDesignator) initializer) l
and initializer0 f e = (case e of CInitExpr0 (ea, _) => InitE (expression (f ea)) | CInitList0 (l, _) => InitList (initializerList l))
and initializer e = initializer0 id e
and deriv_decl_spec0 dDs =
  foldr (fn a => (case a of CPtrDeclr0 (_, _) => Ptr | CArrDeclr0 ([], sz, _) => (fn t => Array (t, (case sz of CNoArrSize0 false => NONE | CArrSize0 (false, expr) => SOME (expression expr))))
                   | CFunDeclr0 (Right (arg, _), _, _) => (fn t => Function (t, function_definition_params0 (fn CDecl0 (l_decl_spec, _, _) => decl_spec_ty l_decl_spec) arg))))
    dDs;

fun function_definition_params f_name = function_definition_params0 (fn CDecl0 (l_decl_spec, [((Some (CDeclr0 (Some i, dDs, _, _, _)), _), _)], _) => (deriv_decl_spec dDs l_decl_spec, f_name (ident i)));

fun p_first_of_NodeInfo x = (fn a => (case a of OnlyPos0 (pos, _) => (pos, (1 : IntInf.int)) | NodeInfo0 (pos, _, _) => (pos, (1 : IntInf.int)))) x;

fun p_last_of_NodeInfo x = (fn a => (case a of OnlyPos0 (_, len) => len | NodeInfo0 (_, len, _) => len)) x;

fun pos_of_CFunDef x = (fn CFunDef0 (_, _, _, _, pos) => pos) x;

fun pos_of_CStat x =
  (fn a => (case a of CLabel0 (_, _, _, pos) => pos | CCase0 (_, _, pos) => pos | CDefault0 (_, pos) => pos | CExpr0 (_, pos) => pos | CCompound0 (_, _, pos) => pos | CIf0 (_, _, _, pos) => pos | CSwitch0 (_, _, pos) => pos
             | CWhile0 (_, _, _, pos) => pos | CFor0 (_, _, _, _, pos) => pos | CGoto0 (_, pos) => pos | CCont0 pos => pos | CBreak0 pos => pos | CReturn0 (_, pos) => pos | CAsm0 (_, pos) => pos))
    x;

fun pos_of_CDecl x = (fn CDecl0 (_, _, pos) => pos) x;

fun pos_of_CBlockItem x = (fn a => (case a of CBlockStmt0 aa => pos_of_CStat aa | CBlockDecl0 aa => pos_of_CDecl aa | CNestedFunDef0 aa => pos_of_CFunDef aa)) x;

fun map_comment_type f (Invariant x1) = Invariant x1
  | map_comment_type f (Fnspeca x2) = Fnspeca x2
  | map_comment_type f (Relspeca x3) = Relspeca x3
  | map_comment_type f (Modifies x4) = Modifies x4
  | map_comment_type f Dont_translate = Dont_translate
  | map_comment_type f (Auxupda x6) = Auxupda x6
  | map_comment_type f (Ghostupda x7) = Ghostupda x7
  | map_comment_type f (Speca x8) = Speca x8
  | map_comment_type f (End_spec x9) = End_spec x9
  | map_comment_type f (Calls x10) = Calls x10
  | map_comment_type f (Owned_by x11) = Owned_by x11
  | map_comment_type f (OTHER x12) = OTHER (f x12);

fun catch_error m f = (case m of Inl a => f a | Inr a => Inr a);

fun or f1 f2 ts = catch_error (f1 ts) (fn _ => f2 ts);

fun returna x = (fn ts => Inr (x, ts));

fun bindc m f = (case m of Inl a => Inl a | Inr a => f a);

fun bindd m f ts = bindc (m ts) (fn (a, b) => f a b);

fun many_c_a_t_c_h_a_l_l_aux l f = or (bindd f (fn v => many_c_a_t_c_h_a_l_l_aux (v :: l) f)) (returna (rev l));

fun many_c_a_t_c_h_a_l_l x = many_c_a_t_c_h_a_l_l_aux [] x;

fun map_sum f1 f2 (Inl a) = Inl (f1 a)
  | map_sum f1 f2 (Inr a) = Inr (f2 a);

fun bind2 m f = map_sum id (map_prod f id) m;

fun bind3 scan f xs = bind2 (scan xs) f;

fun bit_cut_integer k = (if k = (0 : IntInf.int) then ((0 : IntInf.int), false) else let
                                                                                       val (r, s) = Integer.div_mod (abs k) (abs (2 : IntInf.int));
                                                                                     in
                                                                                       ((if (0 : IntInf.int) < k then r else ~ r - s), s = (1 : IntInf.int))
                                                                                     end);

fun char_of_integer k = let
                          val (q0, b0) = bit_cut_integer k;
                          val (q1, b1) = bit_cut_integer q0;
                          val (q2, b2) = bit_cut_integer q1;
                          val (q3, b3) = bit_cut_integer q2;
                          val (q4, b4) = bit_cut_integer q3;
                          val (q5, b5) = bit_cut_integer q4;
                          val (q6, b6) = bit_cut_integer q5;
                          val a = bit_cut_integer q6;
                          val (_, aa) = a;
                        in
                          Chara (b0, b1, b2, b3, b4, b5, b6, aa)
                        end;

fun explode s = mapa char_of_integer ((List.map (fn c => let val k = Char.ord c in if k < 128 then IntInf.fromInt k else raise Fail "Non-ASCII character in literal" end)  o String.explode) s);

fun scan_upto_b_i_n_d enda ts = or (bind3 enda (fn a => ([], a))) (fn a => (case a of [] => Inl (explode "did not find the end-marker") | t :: aa => bindd (scan_upto_b_i_n_d enda) (fn (res1, res2) => returna (t :: res1, res2)) aa)) ts;

fun errorb e = (fn _ => Inl e);

fun oneof_b_i_n_d x = (fn a => (case a of [] => errorb (explode "did not find a matching element") | xa :: xs => fold (fn x2 => fn x1 => or x1 x2) xs xa)) x;

fun bind_k scan f = bind3 scan (fn _ => f);

fun shows_prec_list A_ p xs = shows_list A_ xs;

fun shows_quote s = shows_prec_char zero_nata (Chara (true, true, true, false, false, true, false, false)) o s o shows_prec_char zero_nata (Chara (true, true, true, false, false, true, false, false));

fun take n [] = []
  | take n (x :: xs) = (if equal_nata n zero_nata then [] else x :: take (minus_nat n one_nat) xs);

fun err_expecting A_ msg ts =
  Inl ([Chara (true, false, true, false, false, true, true, false), Chara (false, false, false, true, true, true, true, false), Chara (false, false, false, false, true, true, true, false),
         Chara (true, false, true, false, false, true, true, false), Chara (true, true, false, false, false, true, true, false), Chara (false, false, true, false, true, true, true, false),
         Chara (true, false, false, true, false, true, true, false), Chara (false, true, true, true, false, true, true, false), Chara (true, true, true, false, false, true, true, false),
         Chara (false, false, false, false, false, true, false, false)] @
        msg @ [Chara (false, false, true, true, false, true, false, false), Chara (false, false, false, false, false, true, false, false), Chara (false, true, false, false, false, true, true, false),
                Chara (true, false, true, false, true, true, true, false), Chara (false, false, true, false, true, true, true, false), Chara (false, false, false, false, false, true, false, false),
                Chara (false, true, true, false, false, true, true, false), Chara (true, true, true, true, false, true, true, false), Chara (true, false, true, false, true, true, true, false),
                Chara (false, true, true, true, false, true, true, false), Chara (false, false, true, false, false, true, true, false), Chara (false, true, false, true, true, true, false, false),
                Chara (false, false, false, false, false, true, false, false)] @
                shows_quote (shows_prec_list A_ zero_nata (take (nat_of_integer (30 : IntInf.int)) ts)) []);

fun exactly_aux (A1_, A2_) s i (x :: xs) (y :: ys) = (if eq A1_ x y then exactly_aux (A1_, A2_) s i xs ys else err_expecting A2_ (explode "\"" @ s @ explode "\"") i)
  | exactly_aux (A1_, A2_) s i [] xs = Inr (s, xs)
  | exactly_aux (A1_, A2_) s i (x :: xs) [] = err_expecting A2_ (explode "\"" @ s @ explode "\"") i;

fun exactly s x = exactly_aux (equal_char, show_char) s x s x;

fun many p (t :: ts) = (if p t then bindc (many p ts) (fn (rs, tsa) => Inr (t :: rs, tsa)) else Inr ([], t :: ts))
  | many p [] = Inr ([], []);

fun many1 p = (fn a => (case a of [] => Inl (explode "did not find an element") | t :: ts => (if p t then bindc (many p ts) (fn (rs, tsa) => Inr (t :: rs, tsa)) else Inl (explode "did not find a first matching element"))));

fun member A_ [] y = false
  | member A_ (x :: xs) y = eq A_ x y orelse member A_ xs y;

fun manyof1 cs = many1 (member equal_char cs);

fun stars1 x = manyof1 (explode "*") x;

fun end_comment x = bindd stars1 (fn _ => exactly (explode "/")) x;

fun parse_id_m_a_y_b_e l_token =
  scan_upto_b_i_n_d
    (oneof_b_i_n_d
      (concat [bind_k end_comment (SOME (explode "end of comment")) :: mapa (fn s => bind_k (exactly s) (SOME (explode "encountering next token"))) l_token,
                [bind_k (manyof1 [Chara (false, false, false, false, false, true, false, false), Chara (false, true, false, true, false, false, false, false), Chara (true, false, false, true, false, false, false, false),
                                   Chara (true, false, true, true, false, false, false, false)])
                   NONE]]));

fun parse_id_o_n_e l_token = bindd (parse_id_m_a_y_b_e l_token) (fn a => (case a of ([], NONE) => returna [] | ([], SOME aa) => errorb aa | (aa :: lista, _) => returna (aa :: lista)));

fun many_m_a_x_aux l f = bindd f (fn v => let
                                            val la = v :: l;
                                          in
                                            or (many_m_a_x_aux la f) (returna (rev la))
                                          end);

fun many_m_a_x x = many_m_a_x_aux [] x;

fun parse_id_list l_token =
  many_c_a_t_c_h_a_l_l
    (bindd (bindd (many (member equal_char
                          [Chara (false, false, false, false, false, true, false, false), Chara (false, true, false, true, false, false, false, false), Chara (true, false, false, true, false, false, false, false),
                            Chara (true, false, true, true, false, false, false, false)]))
             (fn _ => returna ()))
      (fn _ => or (bind_k (exactly (explode "[*]")) NONE) (bind3 (parse_id_o_n_e l_token) SOME)));

fun in_safe_monad f s = let
                          val Inr sa = f s;
                        in
                          sa
                        end;

fun parse_str_aux l = bindd (scan_upto_b_i_n_d (or (bind_k (exactly (explode "\092\"")) (fn s => parse_str_aux (explode "\"" :: s :: l))) (bind_k (exactly (explode "\"")) (fn s => returna (concat (rev (s :: l))))))) (fn (s, f) => f s);

fun parse_str x = bindd (exactly (explode "\"")) (fn _ => parse_str_aux []) x;

fun shows_sep s sep [] = shows_string []
  | shows_sep s sep [x] = s x
  | shows_sep s sep (x :: v :: va) = s x o sep o shows_sep s sep (v :: va);

fun null [] = true
  | null (x :: xs) = false;

fun shows_list_gen showsx e l s r xs = (if null xs then shows_string e else shows_string l o shows_sep showsx (shows_string s) xs o shows_string r);

fun showsp_list s p xs =
  shows_list_gen (s zero_nata) [Chara (true, true, false, true, true, false, true, false), Chara (true, false, true, true, true, false, true, false)] [Chara (true, true, false, true, true, false, true, false)]
    [Chara (false, false, true, true, false, true, false, false), Chara (false, false, false, false, false, true, false, false)] [Chara (true, false, true, true, true, false, true, false)] xs;

fun shows_list_list A_ xss = showsp_list (shows_prec_list A_) zero_nata xss;

fun gen_length n (x :: xs) = gen_length (suc n) xs
  | gen_length n [] = n;

fun size_list x = gen_length zero_nata x;

fun trim x = dropWhile (member equal_char
                         [Chara (false, false, false, false, false, true, false, false), Chara (false, true, false, true, false, false, false, false), Chara (true, false, false, true, false, false, false, false),
                           Chara (true, false, true, true, false, false, false, false)])
               x;

fun drop n [] = []
  | drop n (x :: xs) = (if equal_nata n zero_nata then x :: xs else drop (minus_nat n one_nat) xs);

fun oneof_aux allowed (x :: xs) ts = (if equal_lista equal_char (mapa snd (zip x ts)) x then Inr (x, trim (drop (size_list x) ts)) else oneof_aux allowed xs ts)
  | oneof_aux allowed [] ts =
    err_expecting show_char
      ([Chara (true, true, true, true, false, true, true, false), Chara (false, true, true, true, false, true, true, false), Chara (true, false, true, false, false, true, true, false),
         Chara (false, false, false, false, false, true, false, false), Chara (true, true, true, true, false, true, true, false), Chara (false, true, true, false, false, true, true, false),
         Chara (false, false, false, false, false, true, false, false)] @
        shows_list_list show_char allowed [])
      ts;

fun oneof xs = oneof_aux xs xs;

fun eoi A_ [] = Inr ((), [])
  | eoi A_ (v :: va) =
    err_expecting A_
      [Chara (true, false, true, false, false, true, true, false), Chara (false, true, true, true, false, true, true, false), Chara (false, false, true, false, false, true, true, false),
        Chara (false, false, false, false, false, true, false, false), Chara (true, true, true, true, false, true, true, false), Chara (false, true, true, false, false, true, true, false),
        Chara (false, false, false, false, false, true, false, false), Chara (true, false, false, true, false, true, true, false), Chara (false, true, true, true, false, true, true, false),
        Chara (false, false, false, false, true, true, true, false), Chara (true, false, true, false, true, true, true, false), Chara (false, false, true, false, true, true, true, false)]
      (v :: va);

fun parse_commenta x =
  bindd (exactly (explode "/"))
    (fn _ => bindd stars1 (fn _ => bindd (many_c_a_t_c_h_a_l_l
                                           let
                                             val colon = (fn f => bindd f (fn _ => bindd (bindd (many (member equal_char
                                                                                                        [Chara (false, false, false, false, false, true, false, false), Chara (false, true, false, true, false, false, false, false),
                                                                                                          Chara (true, false, false, true, false, false, false, false), Chara (true, false, true, true, false, false, false, false)]))
                                                                                           (fn _ => returna ()))
                                                                                     (fn _ => exactly (explode ":"))));
                                             val colon_s = colon o exactly;
                                             val str = (fn f => bindd f (fn _ => bindd (bindd (many (member equal_char
                                                                                                      [Chara (false, false, false, false, false, true, false, false), Chara (false, true, false, true, false, false, false, false),
                                                                                                        Chara (true, false, false, true, false, false, false, false), Chara (true, false, true, true, false, false, false, false)]))
                                                                                         (fn _ => returna ()))
                                                                                   (fn _ => parse_str)));
                                           in
                                             bindd (bindd (many (member equal_char
                                                                  [Chara (false, false, false, false, false, true, false, false), Chara (false, true, false, true, false, false, false, false),
                                                                    Chara (true, false, false, true, false, false, false, false), Chara (true, false, true, true, false, false, false, false)]))
                                                     (fn _ => returna ()))
                                               (fn _ => or (bind3 (app_rev (app_rev (oneof [explode "INVARIANT", explode "INV"]) colon) str) Invariant)
                                                          (or (oneof_b_i_n_d
                                                                let
                                                                  val fnspec = explode "FNSPEC";
                                                                  val relspec = explode "RELSPEC";
                                                                  val modifies = explode "MODIFIES";
                                                                  val dONT_TRANSLATE = explode "DONT_TRANSLATE";
                                                                in
                                                                  [bind3 (bindd (exactly fnspec)
                                                                           (fn _ => many_m_a_x (bindd (bindd (many (member equal_char
                                                                                                                     [Chara (false, false, false, false, false, true, false, false),
 Chara (false, true, false, true, false, false, false, false), Chara (true, false, false, true, false, false, false, false), Chara (true, false, true, true, false, false, false, false)]))
                                                                                                        (fn _ => returna ()))
                                                                                                 (fn _ => bindd (scan_upto_b_i_n_d
                                                                                                                  (bindd (bindd
     (many (member equal_char
             [Chara (false, false, false, false, false, true, false, false), Chara (false, true, false, true, false, false, false, false), Chara (true, false, false, true, false, false, false, false),
               Chara (true, false, true, true, false, false, false, false)]))
     (fn _ => returna ()))
                                                                                                                    (fn _ => exactly (explode ":"))))
                                                                                                            (fn (s1, _) =>
                                                                                                              bindd (bindd
(many (member equal_char
        [Chara (false, false, false, false, false, true, false, false), Chara (false, true, false, true, false, false, false, false), Chara (true, false, false, true, false, false, false, false),
          Chara (true, false, true, true, false, false, false, false)]))
(fn _ => returna ()))
                                                                                                                (fn _ => bindd parse_str (fn s2 => returna (s1, s2))))))))
                                                                     Fnspeca,
                                                                    bind3 (app_rev (exactly relspec) str) Relspeca, bind3 (bindd (colon_s modifies) (fn _ => parse_id_list [fnspec, relspec, modifies, dONT_TRANSLATE])) Modifies,
                                                                    bind_k (exactly dONT_TRANSLATE) Dont_translate]
                                                                end)
                                                            (or (bind3 (app_rev (colon_s (explode "AUXUPD")) str) Auxupda)
                                                              (or (bind3 (app_rev (colon_s (explode "GHOSTUPD")) str) Ghostupda)
                                                                (or (bind3 (bind3 (app_rev (colon_s (explode "SPEC")) str)
                                                                             (in_safe_monad (or (bindd (scan_upto_b_i_n_d (exactly (explode "."))) (returna o fst)) (fn ts => returna ts (explode "")))))
                                                                      Speca)
                                                                  (or (bind3 (app_rev (colon_s (explode "END-SPEC")) str) End_spec)
                                                                    (or (bind3 (bindd (exactly (explode "CALLS")) (fn _ => parse_id_list [])) Calls)
                                                                      (bind3 (bindd (exactly (explode "OWNED_BY"))
                                                                               (fn _ => bindd (bindd (many (member equal_char
                                                                                                             [Chara (false, false, false, false, false, true, false, false), Chara (false, true, false, true, false, false, false, false),
                                                                                                               Chara (true, false, false, true, false, false, false, false), Chara (true, false, true, true, false, false, false, false)]))
                                                                                                (fn _ => returna ()))
                                                                                          (fn _ => parse_id_o_n_e [])))
                                                                        Owned_by))))))))
                                           end)
                                     (fn cmd => bindd (scan_upto_b_i_n_d
                                                        (bindd (bindd (many (member equal_char
                                                                              [Chara (false, false, false, false, false, true, false, false), Chara (false, true, false, true, false, false, false, false),
                                                                                Chara (true, false, false, true, false, false, false, false), Chara (true, false, true, true, false, false, false, false)]))
                                                                 (fn _ => returna ()))
                                                          (fn _ => end_comment)))
                                                  (fn (remain, _) => bindd (eoi show_char) (fn _ => returna (if null remain then cmd else cmd @ [OTHER remain]))))))
    x;

fun string_implode x = SS_base (STa (mapa integer_of_char x));

fun errora x = (error o meta_of_logic) x;

fun parse_comment x =
  (fn a => (case a of Commenta (_, s, SingleLine) => [OTHER s]
             | Commenta (_, s, MultiLine) =>
               (case parse_commenta (mapa char_of_integer (to_list s)) of Inl sa => errora (SS_base (STa (mapa integer_of_char sa))) | Inr (l, []) => mapa (map_comment_type string_implode) l
                 | Inr (_, _ :: _) => errora (SS_base (ST "the remaining stream is not empty")))))
    x;

fun sbogwrap x = (Stmt o bogwrap) x;

fun filter_statement l =
  app_rev (app_rev l (mapa (map_filter let
                                         val inl = (fn s => fn f => app_rev (app_rev (app_rev (f (SS_base (STa (mapa integer_of_char s)))) (BI_Stmt o sbogwrap)) Inl) SOME);
                                         val inr = (fn s => app_rev (app_rev s Inr) SOME);
                                       in
                                         (fn a => (case a of Invariant _ => NONE | Fnspeca _ => NONE | Relspeca _ => NONE | Modifies _ => NONE | Dont_translate => NONE | Auxupda s => inl s Auxupd | Ghostupda s => inl s Ghostupd
                                                    | Speca (s1, s2) => inr (Inl (SS_base (STa (mapa integer_of_char s1)), SS_base (STa (mapa integer_of_char s2)))) | End_spec s => inr (Inr (SS_base (STa (mapa integer_of_char s))))
                                                    | Calls _ => NONE | Owned_by _ => NONE | OTHER _ => NONE))
                                       end o
                             parse_comment)))
    concat;

fun impl_of (Alist x) = x;

fun map_of A_ ((l, v) :: ps) k = (if eq A_ l k then SOME v else map_of A_ ps k)
  | map_of A_ [] k = NONE;

fun lookup A_ xa = map_of A_ (impl_of xa);

fun lookupa A_ = lookup A_;

fun get_column A_ (B1_, B2_) rbt pos = fold (fn (c, len) => fn ca => (if less B2_ c ca then plusa B1_ ca len else ca)) (case lookupa A_ rbt pos of NONE => [] | SOME l_comm => l_comm);

fun pos_in_interval_haskell rbt =
  (fn a => (case a of ((Position0 (_, f1, l1, c1), p1), (Position0 (_, f2, l2, c2), p2)) =>
                     (fn aa => (case aa of Position0 (_, ff, ll, cc) =>
                                          let
                                            val b1 = equal_abr_stringa ff f1;
                                            val b2 = equal_abr_stringa ff f2;
                                          in
                                            (b1 orelse b2) andalso
                                              ((if b1 then l1 < ll orelse l1 = ll andalso get_column (equal_prod equal_abr_string equal_integer) (plus_integer, ord_integer) rbt (f1, l1) c1 + p1 <= cc + (1 : IntInf.int)
                                                 else true) andalso
                                                (if b2 then ll < l2 orelse ll = l2 andalso cc + (1 : IntInf.int) <= get_column (equal_prod equal_abr_string equal_integer) (plus_integer, ord_integer) rbt (f2, l2) c2 + p2 else true))
                                          end
                                 | NoPosition0 => false | BuiltinPosition0 => false | InternalPosition0 => false))
             | ((Position0 (_, _, _, _), _), (NoPosition0, _)) => (fn _ => false) | ((Position0 (_, _, _, _), _), (BuiltinPosition0, _)) => (fn _ => false) | ((Position0 (_, _, _, _), _), (InternalPosition0, _)) => (fn _ => false)
             | ((NoPosition0, _), _) => (fn _ => false) | ((BuiltinPosition0, _), _) => (fn _ => false) | ((InternalPosition0, _), _) => (fn _ => false)));

fun pos_in_interval_ml uu =
  (fn a => (case a of ((Position0 (off1, _, _, _), p1), (Position0 (off2, _, _, _), p2)) =>
                     (fn aa => (case aa of Position0 (off, _, _, _) => off1 + p1 <= off andalso off <= off2 + p2 | NoPosition0 => false | BuiltinPosition0 => false | InternalPosition0 => false))
             | ((Position0 (_, _, _, _), _), (NoPosition0, _)) => (fn _ => false) | ((Position0 (_, _, _, _), _), (BuiltinPosition0, _)) => (fn _ => false) | ((Position0 (_, _, _, _), _), (InternalPosition0, _)) => (fn _ => false)
             | ((NoPosition0, _), _) => (fn _ => false) | ((BuiltinPosition0, _), _) => (fn _ => false) | ((InternalPosition0, _), _) => (fn _ => false)));

fun pos_in_interval x = (case current_parsing_style of Style_Haskell => pos_in_interval_haskell | Style_ML => pos_in_interval_ml) x;

fun partition p [] = ([], [])
  | partition p (x :: xs) = let
                              val (yes, no) = partition p xs;
                            in
                              (if p x then (x :: yes, no) else (yes, x :: no))
                            end;

fun comment_interval x = (fn (l, rbt) => fn interv => app_rev (app_rev l (partition (fn Commenta (pos, _, _) => pos_in_interval rbt interv pos))) fst) x;

fun return x acc = (acc, x);

fun bindb m f acc = let
                      val (acca, x) = m acc;
                    in
                      f x acca
                    end;

fun foldM_o f = (fn a => (case a of None => return None | Some e => bindb (f e) (fn ea => return (Some ea))));

fun unsupported s = let
                      val p = OnlyPos0 (NoPosition0, (NoPosition0, (0 : IntInf.int)));
                    in
                      return let
                               val _ = not_yet_supported (flattena [SS_base (ST "Statements in expression not yet supported "), s, SS_base (ST " (empty variable returned)")]);
                             in
                               CVar0 (Ident0 (SS_base (ST ""), (0 : IntInf.int), p), p)
                             end
                    end;

fun foldM f [] = return []
  | foldM f (x :: xs) = bindb (f x) (fn xa => bindb (foldM f xs) (fn xsa => return (xa :: xsa)));

fun stmt_out_of_expr e =
  (case e of CComma0 (l, _) => bindb (foldM stmt_out_of_expr l) (fn _ => unsupported (SS_base (ST "CComma")))
    | CAssign0 (_, e1, e2, _) => bindb (stmt_out_of_expr e1) (fn _ => bindb (stmt_out_of_expr e2) (fn _ => unsupported (SS_base (ST "CAssign"))))
    | CCond0 (e1, o_e2, e3, pos) => bindb (stmt_out_of_expr e1) (fn e1a => bindb (foldM_o stmt_out_of_expr o_e2) (fn o_e2a => bindb (stmt_out_of_expr e3) (fn e3a => return (CCond0 (e1a, o_e2a, e3a, pos)))))
    | CBinary0 (bin, e1, e2, pos) => bindb (stmt_out_of_expr e1) (fn e1a => bindb (stmt_out_of_expr e2) (fn e2a => return (CBinary0 (bin, e1a, e2a, pos))))
    | CCast0 (d, ea, pos) => bindb (stmt_out_of_expr ea) (fn eb => return (CCast0 (d, eb, pos)))
    | CUnary0 (una, ea, pos) =>
      bindb (stmt_out_of_expr ea)
        (fn eb => (case (case una of CPreIncOp0 => SOME (SS_base (ST "CPreIncOp")) | CPreDecOp0 => SOME (SS_base (ST "CPreDecOp")) | CPostIncOp0 => SOME (SS_base (ST "CPostIncOp")) | CPostDecOp0 => SOME (SS_base (ST "CPostDecOp"))
                          | CAdrOp0 => NONE | CIndOp0 => NONE | CPlusOp0 => NONE | CMinOp0 => NONE | CCompOp0 => NONE | CNegOp0 => NONE)
                    of NONE => return (CUnary0 (una, eb, pos)) | SOME s => unsupported (flattena [s, SS_base (ST " |> CUnary")])))
    | CSizeofExpr0 (cExpression, a) => return (CSizeofExpr0 (cExpression, a)) | CSizeofType0 (cDeclaration, a) => return (CSizeofType0 (cDeclaration, a)) | CAlignofExpr0 (cExpression, a) => return (CAlignofExpr0 (cExpression, a))
    | CAlignofType0 (_, _) => unsupported (SS_base (ST "CAlignofType")) | CComplexReal0 (cExpression, a) => return (CComplexReal0 (cExpression, a)) | CComplexImag0 (cExpression, a) => return (CComplexImag0 (cExpression, a))
    | CIndex0 (e1, e2, pos) => bindb (stmt_out_of_expr e2) (fn e2a => bindb (stmt_out_of_expr e1) (fn e1a => return (CIndex0 (e1a, e2a, pos))))
    | CCall0 (ea, l, pos) => bindb (stmt_out_of_expr ea) (fn eb => bindb (foldM stmt_out_of_expr l) (fn la => return (CCall0 (eb, la, pos)))) | CMember0 (cExpression, ident, boola, a) => return (CMember0 (cExpression, ident, boola, a))
    | CVar0 (ident, a) => return (CVar0 (ident, a)) | CConst0 cConstant => return (CConst0 cConstant) | CCompoundLit0 (cDeclaration, lista, a) => return (CCompoundLit0 (cDeclaration, lista, a))
    | CGenericSelection0 (cExpression, lista, a) => return (CGenericSelection0 (cExpression, lista, a)) | CStatExpr0 (_, _) => unsupported (SS_base (ST "CStatExpr")) | CLabAddrExpr0 (ident, a) => return (CLabAddrExpr0 (ident, a))
    | CBuiltinExpr0 _ => unsupported (SS_base (ST "CBuiltinExpr")));

fun stmt_out_of_expra x = app_rev (stmt_out_of_expr x ()) snd;

fun map_optiona f NONE = NONE
  | map_optiona f (SOME x2) = SOME (f x2);

fun maps f [] = []
  | maps f (x :: xs) = f x @ maps f xs;

fun filter_gen f1 f2 l = (case maps (map_filter (map_optiona string_implode o f1) o parse_comment) l of [] => NONE | [x] => SOME (f2 x));

fun filter_owned_by x =
  filter_gen (fn a => (case a of Invariant _ => NONE | Fnspeca _ => NONE | Relspeca _ => NONE | Modifies _ => NONE | Dont_translate => NONE | Auxupda _ => NONE | Ghostupda _ => NONE | Speca _ => NONE | End_spec _ => NONE
                        | Calls _ => NONE | Owned_by aa => SOME aa | OTHER _ => NONE))
    OWNED_BY x;

fun tree_of_decl_spec s =
  let
    val CStruct0 (tag, n, opt, l, a) = s;
    val l_opt = (case opt of None => [] | Some la => la);
  in
    Struct_tree (ident_option n, (tag, (l_opt, (l, a))),
                  mapa (fn CDecl0 (l1, l2, _) =>
                         (case map_filter (fn aa => (case aa of CStorageSpec0 _ => NONE
                                                      | CTypeSpec0 ab =>
                                                        (case ab of CVoidType0 _ => NONE | CCharType0 _ => NONE | CShortType0 _ => NONE | CIntType0 _ => NONE | CLongType0 _ => NONE | CFloatType0 _ => NONE | CDoubleType0 _ => NONE
                                                          | CSignedType0 _ => NONE | CUnsigType0 _ => NONE | CBoolType0 _ => NONE | CComplexType0 _ => NONE | CInt128Type0 _ => NONE | CSUType0 (CStruct0 (_, _, None, _, _), _) => NONE
                                                          | CSUType0 (CStruct0 (taga, na, Some l0, la, ac), _) => SOME (CStruct0 (taga, na, Some l0, la, ac), (taga, l2)) | CEnumType0 (_, _) => NONE | CTypeDef0 (_, _) => NONE
                                                          | CTypeOfExpr0 (_, _) => NONE | CTypeOfType0 (_, _) => NONE | CAtomicType0 (_, _) => NONE)
                                                      | CTypeQual0 _ => NONE | CFunSpec0 _ => NONE | CAlignSpec0 _ => NONE))
                                 l1
                           of [] => Inr (l1, l2) | [x] => Inl (map_prod tree_of_decl_spec id x) | _ :: _ :: _ => Inr (l1, l2)))
                    l_opt)
  end;

fun fresh_ident x = (SS_base o ST o fresh_ident0) x;

fun concat_map x = comp2 concat mapa x;

fun struct_conv a =
  let
    val Struct_tree (n, na, child) = a;
    val nb = (case n of NONE => flattena [SS_base (ST "ISA_anon_struct|"), fresh_ident ()] | SOME aa => ident_struct_type0 aa);
  in
    (nb, (case child of [] => [Struct_leaf (Inl (nb, na))]
           | _ :: _ => let
                         val l = mapa (map_sum (map_prod struct_conv id) id) child;
                       in
                         Struct_root (nb, na, mapa (fn aa => (case aa of Inl ((x, _), nc) => Inl (x, nc) | Inr ab => Inr ab)) l) :: concat_map (fn aa => (case aa of Inl ((_, la), _) => la | Inr b => [Struct_leaf (Inr b)])) l
                       end))
  end;

fun list_ex p [] = false
  | list_ex p (x :: xs) = p x orelse list_ex p xs;

fun extract p (x :: xs) = (if p x then SOME ([], (x, xs)) else (case extract p xs of NONE => NONE | SOME (ys, (y, zs)) => SOME (x :: ys, (y, zs))))
  | extract p [] = NONE;

fun decl_spec0 l_decl_spec =
  (fn (l_arg, pos_arg) =>
    (case map_filter (fn a => (case a of CStorageSpec0 _ => NONE | CTypeSpec0 (CVoidType0 _) => NONE | CTypeSpec0 (CCharType0 _) => NONE | CTypeSpec0 (CShortType0 _) => NONE | CTypeSpec0 (CIntType0 _) => NONE
                                | CTypeSpec0 (CLongType0 _) => NONE | CTypeSpec0 (CFloatType0 _) => NONE | CTypeSpec0 (CDoubleType0 _) => NONE | CTypeSpec0 (CSignedType0 _) => NONE | CTypeSpec0 (CUnsigType0 _) => NONE
                                | CTypeSpec0 (CBoolType0 _) => NONE | CTypeSpec0 (CComplexType0 _) => NONE | CTypeSpec0 (CInt128Type0 _) => NONE | CTypeSpec0 (CSUType0 (_, _)) => NONE
                                | CTypeSpec0 (CEnumType0 (CEnum0 (_, None, _, _), _)) => NONE | CTypeSpec0 (CEnumType0 (CEnum0 (_, Some [], _, _), _)) => NONE
                                | CTypeSpec0 (CEnumType0 (CEnum0 (n, Some (x :: xs), _, _), _)) => SOME (EnumDecl0 (bogwrap (ident_option n), mapa (fn (i, e) => (ident i, map_option expression e)) (x :: xs)))
                                | CTypeSpec0 (CTypeDef0 (_, _)) => NONE | CTypeSpec0 (CTypeOfExpr0 (_, _)) => NONE | CTypeSpec0 (CTypeOfType0 (_, _)) => NONE | CTypeSpec0 (CAtomicType0 (_, _)) => NONE | CTypeQual0 _ => NONE
                                | CFunSpec0 _ => NONE | CAlignSpec0 _ => NONE))
            l_decl_spec
      of [] => [] | x :: _ => [x]) @
      let
        val a = (case map_filter (fn a => (case a of CStorageSpec0 _ => NONE
                                            | CTypeSpec0 aa =>
                                              (case aa of CVoidType0 _ => NONE | CCharType0 _ => NONE | CShortType0 _ => NONE | CIntType0 _ => NONE | CLongType0 _ => NONE | CFloatType0 _ => NONE | CDoubleType0 _ => NONE
                                                | CSignedType0 _ => NONE | CUnsigType0 _ => NONE | CBoolType0 _ => NONE | CComplexType0 _ => NONE | CInt128Type0 _ => NONE
                                                | CSUType0 (CStruct0 (tag, n, opt, l, ab), _) => map_option (fn _ => (CStruct0 (tag, n, opt, l, ab), tag)) opt | CEnumType0 (_, _) => NONE | CTypeDef0 (_, _) => NONE
                                                | CTypeOfExpr0 (_, _) => NONE | CTypeOfType0 (_, _) => NONE | CAtomicType0 (_, _) => NONE)
                                            | CTypeQual0 _ => NONE | CFunSpec0 _ => NONE | CAlignSpec0 _ => NONE))
                        l_decl_spec
                  of [] => (NONE, [])
                  | (s, tag) :: _ =>
                    map_prod (SOME o decl_spec_ty_tag tag)
                      (map_filter (fn a => (case a of Struct_root (sa, n, l) => SOME (StructDecl0_root (sa, (n, l))) | Struct_leaf (Inl d) => SOME (StructDecl0_child d) | Struct_leaf (Inr _) => NONE)))
                      (struct_conv (tree_of_decl_spec s)));
        val (struct_name, aa) = a;
      in
        (if list_ex (fn ab => (case ab of CStorageSpec0 (CAuto0 _) => false | CStorageSpec0 (CRegister0 _) => false | CStorageSpec0 (CStatic0 _) => false | CStorageSpec0 (CExtern0 _) => false | CStorageSpec0 (CTypedef0 _) => true
                                | CStorageSpec0 (CThread0 _) => false | CTypeSpec0 _ => false | CTypeQual0 _ => false | CFunSpec0 _ => false | CAlignSpec0 _ => false))
              l_decl_spec
          then mapa (fn ((Some (CDeclr0 (n, dDs, _, _, _)), _), _) => TypeDecl0 (n, (struct_name, dDs))) l_arg
          else app_rev (foldr (fn ((Some (CDeclr0 (n, dDs, _, gcc_attr, pos)), init), _) => fn (acc, pos2) =>
                                let
                                  val pos1 = p_first_of_NodeInfo pos;
                                in
                                  ((case extract (fn ab => (case ab of CPtrDeclr0 (_, _) => false | CArrDeclr0 (_, _, _) => false | CFunDeclr0 (_, _, _) => true)) dDs
                                     of NONE => VarDecl0 (n, (struct_name, (dDs, (init, (pos1, (pos2, gcc_attr)))))) | SOME ab => let
              val (dDs0, ac) = ab;
              val (CFunDeclr0 (l_arga, l_attr, ad), dDs1) = ac;
            in
              ExtFnDecl0 (n, (dDs0, ((l_arga, (l_attr, ad)), (dDs1, gcc_attr))))
            end) ::
                                     acc,
                                    pos1)
                                end)
                         l_arg ([], pos_arg))
                 fst) @
          aa
      end);

fun identa x = (fn Ident0 (s, _, _) => pref_ident (if equal_abr_stringa s (SS_base (ST "const")) then flattena [SS_base (ST "__"), s, SS_base (ST "__")] else s)) x;

fun attrs0 x = (fn a => (case a of CAttr0 (i, [], _) => GCC_AttribID (identa i) | CAttr0 (i, aa :: lista, _) => GCC_AttribFn (ident i, mapa expression (aa :: lista)))) x;

val empty : ('a, 'b) alist = Alist [];

val emptya : ('a, 'b) alist = empty;

fun update A_ k v [] = [(k, v)]
  | update A_ k v (p :: ps) = (if eq A_ (fst p) k then (k, v) :: ps else p :: update A_ k v ps);

fun updatea A_ xc xd xe = Alist (update A_ xc xd (impl_of xe));

fun insert A_ = updatea A_;

fun union_loada A_ = fold (fn x => fn (_, (acc, rbt)) => (false, (case lookupa A_ rbt x of NONE => (x :: acc, insert A_ x () rbt) | SOME _ => (acc, rbt))));

fun entries x = impl_of x;

fun is_emptya l = null (entries l);

fun keys_emptya f = (fn (b, (acc, rbt)) => (if b andalso is_emptya rbt then [] else [f (rev acc)]));

fun bulkload A_ l = fold (fn (a, b) => insert A_ a b) l emptya;

fun folda f = fold (fn (a, b) => f a b) o entries;

fun union A_ l1 l2 = folda (insert A_) l2 l1;

fun union_load A_ l = map_prod (fn _ => false) (union A_ (bulkload A_ (mapa (fn x => (x, ())) l)));

fun keys x = (mapa fst o impl_of) x;

fun keys_empty f = (fn (b, rbt) => (if b andalso is_emptya rbt then [] else [f (keys rbt)]));

fun collapse_mod_attribs l =
  let
    val (mods, (attribs, specs)) =
      fold (fn x => fn (mods, (attribs, specs)) =>
             (case x of Fnspec _ => (mods, (attribs, x :: specs)) | Relspec _ => (mods, (attribs, x :: specs)) | Fn_modifies la => (union_load equal_abr_string la mods, (attribs, specs))
               | Didnt_translate => (mods, (attribs, x :: specs)) | Gcc_attribs la => (mods, (union_loada equal_gcc_attribute la attribs, specs))))
        l ((true, emptya), ((true, ([], emptya)), []));
  in
    keys_empty Fn_modifies mods @ keys_emptya Gcc_attribs attribs @ specs
  end;

fun filter_fnspec x =
  (concat o mapa (map_filter (fn a => (case a of Invariant _ => NONE
                                        | Fnspeca l =>
                                          app_rev (app_rev (app_rev (app_rev (app_rev l (mapa (fn (s1, s2) => let
                                                                                                                val (s1a, s2a) = map_prod string_implode string_implode (s1, s2);
                                                                                                              in
                                                                                                                flattena [s1a, SS_base (ST ": \""), s2a, SS_base (ST "\"")]
                                                                                                              end)))
                                                                      (fn aa => String_concatWith (SS_base (ST "\n"), aa)))
                                                             bogwrap)
                                                    Fnspec)
                                            SOME
                                        | Relspeca s => app_rev (app_rev (app_rev (flattena [SS_base (ST "\""), SS_base (STa (mapa integer_of_char s)), SS_base (ST "\"")]) bogwrap) Relspec) SOME
                                        | Modifies l => app_rev (app_rev (app_rev l (mapa (fn aa => (case aa of NONE => SS_base (ST "phantom_machine_state") | SOME s => SS_base (STa (mapa integer_of_char s)))))) Fn_modifies) SOME
                                        | Dont_translate => app_rev Didnt_translate SOME | Auxupda _ => NONE | Ghostupda _ => NONE | Speca _ => NONE | End_spec _ => NONE | Calls _ => NONE | Owned_by _ => NONE | OTHER _ => NONE)) o
                   parse_comment))
    x;

fun attrs l_decl_spec dDs gcc_attr pos_rbt =
  let
    val l = concat [map_filter (fn a => (case a of CStorageSpec0 _ => NONE | CTypeSpec0 _ => NONE | CTypeQual0 (CConstQual0 _) => NONE | CTypeQual0 (CVolatQual0 _) => NONE | CTypeQual0 (CRestrQual0 _) => NONE
                                          | CTypeQual0 (CAtomicQual0 _) => NONE | CTypeQual0 (CAttrQual0 x) => SOME (attrs0 x) | CTypeQual0 (CNullableQual0 _) => NONE | CTypeQual0 (CNonnullQual0 _) => NONE
                                          | CFunSpec0 (CInlineQual0 _) => NONE | CFunSpec0 (CNoreturnQual0 _) => SOME (GCC_AttribID (SS_base (ST "noreturn"))) | CAlignSpec0 _ => NONE))
                      (rev l_decl_spec),
                     mapa attrs0 (concat_map let
                                               val f_attr = map_filter (fn a => (case a of CConstQual0 _ => NONE | CVolatQual0 _ => NONE | CRestrQual0 _ => NONE | CAtomicQual0 _ => NONE | CAttrQual0 aa => SOME aa
                                                                                  | CNullableQual0 _ => NONE | CNonnullQual0 _ => NONE));
                                             in
                                               (fn a => (case a of CPtrDeclr0 (l, _) => f_attr l | CArrDeclr0 (l, _, _) => f_attr l | CFunDeclr0 (_, l, _) => l))
                                             end
                                    dDs @
                                   gcc_attr)];
    val fnspec = (case pos_rbt of ((_, NONE), _) => [] | ((rbt, SOME pos1), pos2) => filter_fnspec (comment_interval rbt (pos1, pos2)));
  in
    collapse_mod_attribs (if null l then fnspec else Gcc_attribs l :: fnspec)
  end;

fun decl_spec l_decl_spec l_arg pos_rbt =
  mapa let
         val mk_id = (fn Some i => bogwrap (ident i));
         val f_struct_ty = (fn dDs => fn a => (case a of NONE => deriv_decl_spec dDs l_decl_spec | SOME aa => deriv_decl_spec0 dDs aa));
       in
         (fn a => (case a of VarDecl0 (n, (struct_name, (dDs, (init, (pos1, (pos2, gcc_attr)))))) =>
                            VarDecl (f_struct_ty dDs struct_name,
                                      (mk_id n, (map_filter (fn aa => (case aa of CStorageSpec0 (CAuto0 _) => NONE | CStorageSpec0 (CRegister0 _) => SOME SC_REGISTER | CStorageSpec0 (CStatic0 _) => SOME SC_STATIC
                                                                        | CStorageSpec0 (CExtern0 _) => SOME SC_EXTERN | CStorageSpec0 (CTypedef0 _) => NONE | CStorageSpec0 (CThread0 _) => NONE | CTypeSpec0 _ => NONE
                                                                        | CTypeQual0 _ => NONE | CFunSpec0 _ => NONE | CAlignSpec0 _ => NONE))
                                                   l_decl_spec,
                                                  (map_option (initializer0 stmt_out_of_expra) init, let
                                                                                                       val l = rev (mapa attrs0 gcc_attr);
                                                                                                     in
                                                                                                       (case filter_owned_by (comment_interval let
                           val ((rbt, _), _) = pos_rbt;
                         in
                           rbt
                         end
         (pos1, pos2))
                                                                                                         of NONE => l | SOME x => x :: l)
                                                                                                     end))))
                    | StructDecl0_root (n, (_, l)) =>
                      StructDecl (bogwrap n, maps (fn aa => (case aa of Inl ab => let
                                                                                    val (s, ac) = ab;
                                                                                    val (tag, ad) = ac;
                                                                                  in
                                                                                    mapa (fn ((Some (CDeclr0 (Some i, dDs, _, _, _)), _), _) => (deriv_decl_spec0 dDs (decl_spec_ty_tag tag s), bogwrap (ident_struct_const i))) ad
                                                                                  end
                                                              | Inr ab => let
                                                                            val (l_decl_speca, ac) = ab;
                                                                          in
                                                                            mapa (fn ad => (case ad of ((None, None), Some e) =>
                                                                                                      let
                                                                                                        val (b, msg) =
                                                                                                          (case decl_spec_ty l_decl_speca of Signed _ => (true, SS_base (ST "Signed")) | Unsigned _ => (false, SS_base (ST "Unsigned"))
                                                                                                            | Bool => (false, SS_base (ST "Unsigned (default)")) | PlainChar => (false, SS_base (ST "Unsigned (default)"))
                                                                                                            | StructTy _ => (false, SS_base (ST "Unsigned (default)")) | UnionTy _ => (false, SS_base (ST "Unsigned (default)"))
                                                                                                            | EnumTy _ => (false, SS_base (ST "Unsigned (default)")) | Ptr _ => (false, SS_base (ST "Unsigned (default)"))
                                                                                                            | Array (_, _) => (false, SS_base (ST "Unsigned (default)")) | Bitfield (_, _) => (false, SS_base (ST "Unsigned (default)"))
                                                                                                            | Identa _ => (false, SS_base (ST "Unsigned (default)")) | Function (_, _) => (false, SS_base (ST "Unsigned (default)"))
                                                                                                            | Void => (false, SS_base (ST "Unsigned (default)")));
                                                                                                        val _ = not_yet_supported (flattena [SS_base (ST "Anonymous bitfield ("), msg, SS_base (ST " returned) not yet supported")]);
                                                                                                      in
                                                                                                        (Bitfield (b, expression e), bogwrap (SS_base (ST "")))
                                                                                                      end
                                                                                             | ((Some (CDeclr0 (Some i, dDs, _, _, _)), _), _) => (deriv_decl_spec dDs l_decl_speca, bogwrap (ident_struct_const i))))
                                                                              ac
                                                                          end))
                                               l)
                    | StructDecl0_child (n, (_, (l_child, (_, _)))) =>
                      StructDecl (bogwrap n, maps (fn CDecl0 (l_decl_speca, l_prod, _) => mapa (fn ((Some (CDeclr0 (Some i, dDs, _, _, _)), _), _) => (deriv_decl_spec dDs l_decl_speca, bogwrap (ident i))) l_prod) l_child)
                    | TypeDecl0 (n, (struct_name, dDs)) => TypeDecl [(f_struct_ty dDs struct_name, mk_id n)]
                    | ExtFnDecl0 aa =>
                      let
                        val (Some i, (dDs0, ab)) = aa;
                        val ((l_arga, ac), aaa) = ab;
                        val (l_attr, ad) = ac;
                        val (dDs1, gcc_attr) = aaa;
                      in
                        ExtFnDecl (deriv_decl_spec dDs1 l_decl_spec, bogwrap (ident i),
                                    (case l_arga of Left ae => mapa (fn x => (identb x, NONE)) ae
                                      | Right ae =>
                                        (case ae of ([], true) => let
                                                                    val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                  in
                                                                    []
                                                                  end
                                          | ([], false) =>
                                            mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                   let
                                                     val (n, dDs) =
                                                       (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                         | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                   in
                                                     (deriv_decl_spec dDs l_decl_speca, n)
                                                   end)
                                              []
                                          | (aab :: lista, af) =>
                                            (case aab of CDecl0 ([], list2, xa) =>
                                                        (case af of true => let
                                                                              val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                            in
                                                                              []
                                                                            end
                                                          | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                            let
                                                                              val (n, dDs) =
                                                                                (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                                  | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                            in
                                                                              (deriv_decl_spec dDs l_decl_speca, n)
                                                                            end)
                                                                       (CDecl0 ([], list2, xa) :: lista))
                                              | CDecl0 (aba :: listb, list2, xa) =>
                                                (case aba of CStorageSpec0 cStorageSpecifier =>
                                                            (case af of true => let
                                                                                  val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                                in
                                                                                  []
                                                                                end
                                                              | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                                let
                                                                                  val (n, dDs) =
                                                                                    (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                                      | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                                in
                                                                                  (deriv_decl_spec dDs l_decl_speca, n)
                                                                                end)
                                                                           (CDecl0 (CStorageSpec0 cStorageSpecifier :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CVoidType0 x) =>
                                                    (case listb of [] => (case list2 of [] => (case lista of [] => (case af of true =>
        let
          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
        in
          []
        end
                                                                                                                     | false => [])
                                                                                                | ada :: listaa =>
                                                                                                  (case af of true => let
  val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
in
  []
end
                                                                                                    | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
let
  val (n, dDs) = (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs) | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
in
  (deriv_decl_spec dDs l_decl_speca, n)
end)
                                                                                                                 (CDecl0 ([CTypeSpec0 (CVoidType0 x)], [], xa) :: ada :: listaa)))
                                                                           | ada :: listba =>
                                                                             (case af of true => let
                                                                                                   val _ = not_yet_supported
                                                                                                             (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                                                 in
                                                                                                   []
                                                                                                 end
                                                                               | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                                                 let
                                                                                                   val (n, dDs) =
                                                                                                     (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, [])
                                                                                                       | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                                                       | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                                                 in
                                                                                                   (deriv_decl_spec dDs l_decl_speca, n)
                                                                                                 end)
                                                                                            (CDecl0 ([CTypeSpec0 (CVoidType0 x)], ada :: listba, xa) :: lista)))
                                                      | ada :: listc =>
                                                        (case af of true => let
                                                                              val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                            in
                                                                              []
                                                                            end
                                                          | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                            let
                                                                              val (n, dDs) =
                                                                                (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                                  | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                            in
                                                                              (deriv_decl_spec dDs l_decl_speca, n)
                                                                            end)
                                                                       (CDecl0 (CTypeSpec0 (CVoidType0 x) :: ada :: listc, list2, xa) :: lista)))
                                                  | CTypeSpec0 (CCharType0 abb) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CCharType0 abb) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CShortType0 abb) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CShortType0 abb) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CIntType0 abb) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CIntType0 abb) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CLongType0 abb) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CLongType0 abb) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CFloatType0 abb) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CFloatType0 abb) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CDoubleType0 abb) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CDoubleType0 abb) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CSignedType0 abb) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CSignedType0 abb) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CUnsigType0 abb) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CUnsigType0 abb) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CBoolType0 abb) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CBoolType0 abb) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CComplexType0 abb) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CComplexType0 abb) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CInt128Type0 abb) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CInt128Type0 abb) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CSUType0 (cStructureUnion, abb)) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CSUType0 (cStructureUnion, abb)) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CEnumType0 (cEnumeration, abb)) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CEnumType0 (cEnumeration, abb)) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CTypeDef0 (identa, abb)) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CTypeDef0 (identa, abb)) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CTypeOfExpr0 (cExpression, abb)) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CTypeOfExpr0 (cExpression, abb)) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CTypeOfType0 (cDeclaration, abb)) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CTypeOfType0 (cDeclaration, abb)) :: listb, list2, xa) :: lista))
                                                  | CTypeSpec0 (CAtomicType0 (cDeclaration, abb)) =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeSpec0 (CAtomicType0 (cDeclaration, abb)) :: listb, list2, xa) :: lista))
                                                  | CTypeQual0 cTypeQualifier =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CTypeQual0 cTypeQualifier :: listb, list2, xa) :: lista))
                                                  | CFunSpec0 cFunctionSpecifier =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CFunSpec0 cFunctionSpecifier :: listb, list2, xa) :: lista))
                                                  | CAlignSpec0 cAlignmentSpecifier =>
                                                    (case af of true => let
                                                                          val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                        in
                                                                          []
                                                                        end
                                                      | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                        let
                                                                          val (n, dDs) =
                                                                            (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                              | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                        in
                                                                          (deriv_decl_spec dDs l_decl_speca, n)
                                                                        end)
                                                                   (CDecl0 (CAlignSpec0 cAlignmentSpecifier :: listb, list2, xa) :: lista)))
                                              | CStaticAssert0 (cExpression, cStringLiteral, aac) =>
                                                (case af of true => let
                                                                      val _ = not_yet_supported (flattena [SS_base (ST "Variadic function not yet supported in "), ident i, SS_base (ST " (empty list returned)")]);
                                                                    in
                                                                      []
                                                                    end
                                                  | false => mapa (fn CDecl0 (l_decl_speca, l_name, _) =>
                                                                    let
                                                                      val (n, dDs) =
                                                                        (case l_name of [] => (NONE, []) | ((None, _), _) :: _ => (NONE, []) | [((Some (CDeclr0 (n, dDs, _, _, _)), _), _)] => (ident_option n, dDs)
                                                                          | ((Some (CDeclr0 (_, _, _, _, _)), _), _) :: _ :: _ => (NONE, []));
                                                                    in
                                                                      (deriv_decl_spec dDs l_decl_speca, n)
                                                                    end)
                                                               (CStaticAssert0 (cExpression, cStringLiteral, aac) :: lista))))),
                                    attrs l_decl_spec (dDs0 @ CFunDeclr0 (l_arga, l_attr, ad) :: dDs1) gcc_attr pos_rbt)
                      end
                    | EnumDecl0 (n, l) => EnumDecl (n, mapa (map_prod bogwrap id) l)))
       end
    (decl_spec0 l_decl_spec l_arg);

fun declaration pos_rbt f_decl = (fn CDecl0 (l_decl_spec, l_arg, pos) => mapa (f_decl o bogwrap) (decl_spec l_decl_spec (l_arg, p_last_of_NodeInfo pos) (pos_rbt, p_first_of_NodeInfo pos)));

fun equal_CAssignOp CXorAssOp0 COrAssOp0 = false
  | equal_CAssignOp COrAssOp0 CXorAssOp0 = false
  | equal_CAssignOp CAndAssOp0 COrAssOp0 = false
  | equal_CAssignOp COrAssOp0 CAndAssOp0 = false
  | equal_CAssignOp CAndAssOp0 CXorAssOp0 = false
  | equal_CAssignOp CXorAssOp0 CAndAssOp0 = false
  | equal_CAssignOp CShrAssOp0 COrAssOp0 = false
  | equal_CAssignOp COrAssOp0 CShrAssOp0 = false
  | equal_CAssignOp CShrAssOp0 CXorAssOp0 = false
  | equal_CAssignOp CXorAssOp0 CShrAssOp0 = false
  | equal_CAssignOp CShrAssOp0 CAndAssOp0 = false
  | equal_CAssignOp CAndAssOp0 CShrAssOp0 = false
  | equal_CAssignOp CShlAssOp0 COrAssOp0 = false
  | equal_CAssignOp COrAssOp0 CShlAssOp0 = false
  | equal_CAssignOp CShlAssOp0 CXorAssOp0 = false
  | equal_CAssignOp CXorAssOp0 CShlAssOp0 = false
  | equal_CAssignOp CShlAssOp0 CAndAssOp0 = false
  | equal_CAssignOp CAndAssOp0 CShlAssOp0 = false
  | equal_CAssignOp CShlAssOp0 CShrAssOp0 = false
  | equal_CAssignOp CShrAssOp0 CShlAssOp0 = false
  | equal_CAssignOp CSubAssOp0 COrAssOp0 = false
  | equal_CAssignOp COrAssOp0 CSubAssOp0 = false
  | equal_CAssignOp CSubAssOp0 CXorAssOp0 = false
  | equal_CAssignOp CXorAssOp0 CSubAssOp0 = false
  | equal_CAssignOp CSubAssOp0 CAndAssOp0 = false
  | equal_CAssignOp CAndAssOp0 CSubAssOp0 = false
  | equal_CAssignOp CSubAssOp0 CShrAssOp0 = false
  | equal_CAssignOp CShrAssOp0 CSubAssOp0 = false
  | equal_CAssignOp CSubAssOp0 CShlAssOp0 = false
  | equal_CAssignOp CShlAssOp0 CSubAssOp0 = false
  | equal_CAssignOp CAddAssOp0 COrAssOp0 = false
  | equal_CAssignOp COrAssOp0 CAddAssOp0 = false
  | equal_CAssignOp CAddAssOp0 CXorAssOp0 = false
  | equal_CAssignOp CXorAssOp0 CAddAssOp0 = false
  | equal_CAssignOp CAddAssOp0 CAndAssOp0 = false
  | equal_CAssignOp CAndAssOp0 CAddAssOp0 = false
  | equal_CAssignOp CAddAssOp0 CShrAssOp0 = false
  | equal_CAssignOp CShrAssOp0 CAddAssOp0 = false
  | equal_CAssignOp CAddAssOp0 CShlAssOp0 = false
  | equal_CAssignOp CShlAssOp0 CAddAssOp0 = false
  | equal_CAssignOp CAddAssOp0 CSubAssOp0 = false
  | equal_CAssignOp CSubAssOp0 CAddAssOp0 = false
  | equal_CAssignOp CRmdAssOp0 COrAssOp0 = false
  | equal_CAssignOp COrAssOp0 CRmdAssOp0 = false
  | equal_CAssignOp CRmdAssOp0 CXorAssOp0 = false
  | equal_CAssignOp CXorAssOp0 CRmdAssOp0 = false
  | equal_CAssignOp CRmdAssOp0 CAndAssOp0 = false
  | equal_CAssignOp CAndAssOp0 CRmdAssOp0 = false
  | equal_CAssignOp CRmdAssOp0 CShrAssOp0 = false
  | equal_CAssignOp CShrAssOp0 CRmdAssOp0 = false
  | equal_CAssignOp CRmdAssOp0 CShlAssOp0 = false
  | equal_CAssignOp CShlAssOp0 CRmdAssOp0 = false
  | equal_CAssignOp CRmdAssOp0 CSubAssOp0 = false
  | equal_CAssignOp CSubAssOp0 CRmdAssOp0 = false
  | equal_CAssignOp CRmdAssOp0 CAddAssOp0 = false
  | equal_CAssignOp CAddAssOp0 CRmdAssOp0 = false
  | equal_CAssignOp CDivAssOp0 COrAssOp0 = false
  | equal_CAssignOp COrAssOp0 CDivAssOp0 = false
  | equal_CAssignOp CDivAssOp0 CXorAssOp0 = false
  | equal_CAssignOp CXorAssOp0 CDivAssOp0 = false
  | equal_CAssignOp CDivAssOp0 CAndAssOp0 = false
  | equal_CAssignOp CAndAssOp0 CDivAssOp0 = false
  | equal_CAssignOp CDivAssOp0 CShrAssOp0 = false
  | equal_CAssignOp CShrAssOp0 CDivAssOp0 = false
  | equal_CAssignOp CDivAssOp0 CShlAssOp0 = false
  | equal_CAssignOp CShlAssOp0 CDivAssOp0 = false
  | equal_CAssignOp CDivAssOp0 CSubAssOp0 = false
  | equal_CAssignOp CSubAssOp0 CDivAssOp0 = false
  | equal_CAssignOp CDivAssOp0 CAddAssOp0 = false
  | equal_CAssignOp CAddAssOp0 CDivAssOp0 = false
  | equal_CAssignOp CDivAssOp0 CRmdAssOp0 = false
  | equal_CAssignOp CRmdAssOp0 CDivAssOp0 = false
  | equal_CAssignOp CMulAssOp0 COrAssOp0 = false
  | equal_CAssignOp COrAssOp0 CMulAssOp0 = false
  | equal_CAssignOp CMulAssOp0 CXorAssOp0 = false
  | equal_CAssignOp CXorAssOp0 CMulAssOp0 = false
  | equal_CAssignOp CMulAssOp0 CAndAssOp0 = false
  | equal_CAssignOp CAndAssOp0 CMulAssOp0 = false
  | equal_CAssignOp CMulAssOp0 CShrAssOp0 = false
  | equal_CAssignOp CShrAssOp0 CMulAssOp0 = false
  | equal_CAssignOp CMulAssOp0 CShlAssOp0 = false
  | equal_CAssignOp CShlAssOp0 CMulAssOp0 = false
  | equal_CAssignOp CMulAssOp0 CSubAssOp0 = false
  | equal_CAssignOp CSubAssOp0 CMulAssOp0 = false
  | equal_CAssignOp CMulAssOp0 CAddAssOp0 = false
  | equal_CAssignOp CAddAssOp0 CMulAssOp0 = false
  | equal_CAssignOp CMulAssOp0 CRmdAssOp0 = false
  | equal_CAssignOp CRmdAssOp0 CMulAssOp0 = false
  | equal_CAssignOp CMulAssOp0 CDivAssOp0 = false
  | equal_CAssignOp CDivAssOp0 CMulAssOp0 = false
  | equal_CAssignOp CAssignOp0 COrAssOp0 = false
  | equal_CAssignOp COrAssOp0 CAssignOp0 = false
  | equal_CAssignOp CAssignOp0 CXorAssOp0 = false
  | equal_CAssignOp CXorAssOp0 CAssignOp0 = false
  | equal_CAssignOp CAssignOp0 CAndAssOp0 = false
  | equal_CAssignOp CAndAssOp0 CAssignOp0 = false
  | equal_CAssignOp CAssignOp0 CShrAssOp0 = false
  | equal_CAssignOp CShrAssOp0 CAssignOp0 = false
  | equal_CAssignOp CAssignOp0 CShlAssOp0 = false
  | equal_CAssignOp CShlAssOp0 CAssignOp0 = false
  | equal_CAssignOp CAssignOp0 CSubAssOp0 = false
  | equal_CAssignOp CSubAssOp0 CAssignOp0 = false
  | equal_CAssignOp CAssignOp0 CAddAssOp0 = false
  | equal_CAssignOp CAddAssOp0 CAssignOp0 = false
  | equal_CAssignOp CAssignOp0 CRmdAssOp0 = false
  | equal_CAssignOp CRmdAssOp0 CAssignOp0 = false
  | equal_CAssignOp CAssignOp0 CDivAssOp0 = false
  | equal_CAssignOp CDivAssOp0 CAssignOp0 = false
  | equal_CAssignOp CAssignOp0 CMulAssOp0 = false
  | equal_CAssignOp CMulAssOp0 CAssignOp0 = false
  | equal_CAssignOp COrAssOp0 COrAssOp0 = true
  | equal_CAssignOp CXorAssOp0 CXorAssOp0 = true
  | equal_CAssignOp CAndAssOp0 CAndAssOp0 = true
  | equal_CAssignOp CShrAssOp0 CShrAssOp0 = true
  | equal_CAssignOp CShlAssOp0 CShlAssOp0 = true
  | equal_CAssignOp CSubAssOp0 CSubAssOp0 = true
  | equal_CAssignOp CAddAssOp0 CAddAssOp0 = true
  | equal_CAssignOp CRmdAssOp0 CRmdAssOp0 = true
  | equal_CAssignOp CDivAssOp0 CDivAssOp0 = true
  | equal_CAssignOp CMulAssOp0 CMulAssOp0 = true
  | equal_CAssignOp CAssignOp0 CAssignOp0 = true;

fun statement_of_expression_CAssign_fun e =
  (case e of CComma0 (_, _) => false | CAssign0 (_, _, _, _) => false | CCond0 (_, _, _, _) => false | CBinary0 (_, _, _, _) => false | CCast0 (_, _, _) => false | CUnary0 (_, _, _) => false | CSizeofExpr0 (_, _) => false
    | CSizeofType0 (_, _) => false | CAlignofExpr0 (_, _) => false | CAlignofType0 (_, _) => false | CComplexReal0 (_, _) => false | CComplexImag0 (_, _) => false | CIndex0 (_, _, _) => false | CCall0 (_, _, _) => false
    | CMember0 (_, _, true, _) => false | CMember0 (ea, _, false, _) => statement_of_expression_CAssign_fun ea | CVar0 (_, _) => true | CConst0 _ => false | CCompoundLit0 (_, _, _) => false | CGenericSelection0 (_, _, _) => false
    | CStatExpr0 (_, _) => false | CLabAddrExpr0 (_, _) => false | CBuiltinExpr0 _ => false);

fun binoptype_of_CAssignOp x =
  (fn a => (case a of CAssignOp0 => NONE | CMulAssOp0 => SOME Times | CDivAssOp0 => SOME Divides | CRmdAssOp0 => SOME Modulus | CAddAssOp0 => SOME Plus | CSubAssOp0 => SOME Minus | CShlAssOp0 => SOME LShift | CShrAssOp0 => SOME RShift
             | CAndAssOp0 => SOME BitwiseAnd | CXorAssOp0 => SOME BitwiseXOr | COrAssOp0 => SOME BitwiseOr))
    x;

fun statement_of_expression_CAssign ass_op e1 e2 =
  let
    val e1a = stmt_out_of_expra e1;
    val e2a = stmt_out_of_expra e2;
  in
    (case (case e2a of CComma0 (_, _) => NONE | CAssign0 (_, _, _, _) => NONE | CCond0 (_, _, _, _) => NONE | CBinary0 (_, _, _, _) => NONE | CCast0 (_, _, _) => NONE | CUnary0 (_, _, _) => NONE | CSizeofExpr0 (_, _) => NONE
            | CSizeofType0 (_, _) => NONE | CAlignofExpr0 (_, _) => NONE | CAlignofType0 (_, _) => NONE | CComplexReal0 (_, _) => NONE | CComplexImag0 (_, _) => NONE | CIndex0 (_, _, _) => NONE
            | CCall0 (f, l_arg, _) => (if statement_of_expression_CAssign_fun e1a andalso equal_CAssignOp ass_op CAssignOp0 then SOME (AssignFnCall (SOME (expression e1a), expression f, mapa expression l_arg)) else NONE)
            | CMember0 (_, _, _, _) => NONE | CVar0 (_, _) => NONE | CConst0 _ => NONE | CCompoundLit0 (_, _, _) => NONE | CGenericSelection0 (_, _, _) => NONE | CStatExpr0 (_, _) => NONE | CLabAddrExpr0 (_, _) => NONE
            | CBuiltinExpr0 _ => NONE)
      of NONE => let
                   val e1b = expression e1a;
                   val e2b = expression e2a;
                 in
                   Assign (e1b, (case binoptype_of_CAssignOp ass_op of NONE => e2b | SOME ass_opa => ebogwrap (BinOp (ass_opa, e1b, e2b))))
                 end
      | SOME s => s)
  end;

fun list_all p [] = true
  | list_all p (x :: xs) = p x andalso list_all p xs;

fun expr_int i = ebogwrap (Constant (bogwrap (NUMCONST (i, SS_base (ST ""), DEC))));

fun statement_node_of_expression e =
  let
    val var_const =
      (fn l => (if list_all (fn a => (case a of CComma0 (_, _) => false | CAssign0 (_, _, _, _) => false | CCond0 (_, _, _, _) => false | CBinary0 (_, _, _, _) => false | CCast0 (_, _, _) => false | CUnary0 (_, _, _) => false
                                       | CSizeofExpr0 (_, _) => false | CSizeofType0 (_, _) => false | CAlignofExpr0 (_, _) => false | CAlignofType0 (_, _) => false | CComplexReal0 (_, _) => false | CComplexImag0 (_, _) => false
                                       | CIndex0 (_, _, _) => false | CCall0 (_, _, _) => false | CMember0 (_, _, _, _) => false | CVar0 (_, _) => true | CConst0 _ => true | CCompoundLit0 (_, _, _) => false
                                       | CGenericSelection0 (_, _, _) => false | CStatExpr0 (_, _) => false | CLabAddrExpr0 (_, _) => false | CBuiltinExpr0 _ => false))
                     l
                 then EmptyStmt else errora (SS_base (ST "not yet supported"))));
  in
    (fn a => (case a of CComma0 (l, _) => Block (mapa (BI_Stmt o sbogwrap o statement_node_of_expression) l) | CAssign0 (ass_op, e1, e2, _) => statement_of_expression_CAssign ass_op e1 e2 | CBinary0 (_, e1, e2, _) => var_const [e1, e2]
               | CCast0 (_, CComma0 (lista, aa), _) => var_const [CComma0 (lista, aa)] | CCast0 (_, CAssign0 (cAssignOp, cExpression1, cExpression2, aa), _) => var_const [CAssign0 (cAssignOp, cExpression1, cExpression2, aa)]
               | CCast0 (_, CCond0 (cExpression1, optiona, cExpression2, aa), _) => var_const [CCond0 (cExpression1, optiona, cExpression2, aa)]
               | CCast0 (_, CBinary0 (cBinaryOp, cExpression1, cExpression2, aa), _) => var_const [CBinary0 (cBinaryOp, cExpression1, cExpression2, aa)]
               | CCast0 (_, CCast0 (cDeclaration, cExpression, aa), _) => var_const [CCast0 (cDeclaration, cExpression, aa)] | CCast0 (_, CUnary0 (cUnaryOp, cExpression, aa), _) => var_const [CUnary0 (cUnaryOp, cExpression, aa)]
               | CCast0 (_, CSizeofExpr0 (cExpression, aa), _) => var_const [CSizeofExpr0 (cExpression, aa)] | CCast0 (_, CSizeofType0 (cDeclaration, aa), _) => var_const [CSizeofType0 (cDeclaration, aa)]
               | CCast0 (_, CAlignofExpr0 (cExpression, aa), _) => var_const [CAlignofExpr0 (cExpression, aa)] | CCast0 (_, CAlignofType0 (cDeclaration, aa), _) => var_const [CAlignofType0 (cDeclaration, aa)]
               | CCast0 (_, CComplexReal0 (cExpression, aa), _) => var_const [CComplexReal0 (cExpression, aa)] | CCast0 (_, CComplexImag0 (cExpression, aa), _) => var_const [CComplexImag0 (cExpression, aa)]
               | CCast0 (_, CIndex0 (cExpression1, cExpression2, aa), _) => var_const [CIndex0 (cExpression1, cExpression2, aa)]
               | CCast0 (_, CCall0 (f, l_arg, _), _) => AssignFnCall (NONE, expression (stmt_out_of_expra f), mapa (expression o stmt_out_of_expra) l_arg)
               | CCast0 (_, CMember0 (cExpression, ident, boola, aa), _) => var_const [CMember0 (cExpression, ident, boola, aa)] | CCast0 (_, CVar0 (ident, aa), _) => var_const [CVar0 (ident, aa)]
               | CCast0 (_, CConst0 cConstant, _) => var_const [CConst0 cConstant] | CCast0 (_, CCompoundLit0 (cDeclaration, lista, aa), _) => var_const [CCompoundLit0 (cDeclaration, lista, aa)]
               | CCast0 (_, CGenericSelection0 (cExpression, lista, aa), _) => var_const [CGenericSelection0 (cExpression, lista, aa)] | CCast0 (_, CStatExpr0 (cStatement, aa), _) => var_const [CStatExpr0 (cStatement, aa)]
               | CCast0 (_, CLabAddrExpr0 (ident, aa), _) => var_const [CLabAddrExpr0 (ident, aa)] | CCast0 (_, CBuiltinExpr0 cBuiltinThing, _) => var_const [CBuiltinExpr0 cBuiltinThing]
               | CUnary0 (ass_op, expr, _) => let
                                                val (pre_post, oper) = (case ass_op of CPreIncOp0 => (false, Plus) | CPreDecOp0 => (false, Minus) | CPostIncOp0 => (true, Plus) | CPostDecOp0 => (true, Minus));
                                                val expra = expression expr;
                                              in
                                                (if pre_post then Assign (expra, ebogwrap (BinOp (oper, expra, expr_int (1 : IntInf.int)))) else Assign (expra, ebogwrap (BinOp (oper, expra, expr_int (1 : IntInf.int)))))
                                              end
               | CCall0 (f, l_arg, _) => AssignFnCall (NONE, expression (stmt_out_of_expra f), mapa (expression o stmt_out_of_expra) l_arg)))
  end
    e;

fun filter_auxupd x =
  filter_gen (fn a => (case a of Invariant _ => NONE | Fnspeca _ => NONE | Relspeca _ => NONE | Modifies _ => NONE | Dont_translate => NONE | Auxupda aa => SOME aa | Ghostupda _ => NONE | Speca _ => NONE | End_spec _ => NONE
                        | Calls _ => NONE | Owned_by _ => NONE | OTHER _ => NONE))
    Auxupd x;

fun pos_of_CBuiltin x = (fn a => (case a of CBuiltinVaArg0 (_, _, pos) => pos | CBuiltinOffsetOf0 (_, _, pos) => pos)) x;

fun pos_of_CConst x = (fn a => (case a of CIntConst0 (_, pos) => pos | CCharConst0 (_, pos) => pos | CFloatConst0 (_, pos) => pos | CStrConst0 (_, pos) => pos)) x;

fun pos_of_CExpr x =
  (fn a => (case a of CComma0 (_, pos) => pos | CAssign0 (_, _, _, pos) => pos | CCond0 (_, _, _, pos) => pos | CBinary0 (_, _, _, pos) => pos | CCast0 (_, _, pos) => pos | CUnary0 (_, _, pos) => pos | CSizeofExpr0 (_, pos) => pos
             | CSizeofType0 (_, pos) => pos | CAlignofType0 (_, pos) => pos | CIndex0 (_, _, pos) => pos | CCall0 (_, _, pos) => pos | CMember0 (_, _, _, pos) => pos | CVar0 (_, pos) => pos | CConst0 aa => pos_of_CConst aa
             | CCompoundLit0 (_, _, pos) => pos | CStatExpr0 (_, pos) => pos | CBuiltinExpr0 aa => pos_of_CBuiltin aa))
    x;

fun statement_node_of_expressiona x =
  (fn a => (case a of None => (fn _ => EmptyStmt)
             | Some e => let
                           val stmt = statement_node_of_expression e;
                         in
                           (fn aa => (case aa of NONE => stmt
                                       | SOME (pos_stat, rbt) =>
                                         (case filter_auxupd (comment_interval rbt (p_last_of_NodeInfo (pos_of_CExpr e), p_first_of_NodeInfo pos_stat)) of NONE => stmt
                                           | SOME s2 => let
                                                          val f = (fn l1 => fn l2 => Block (l1 @ mapa (BI_Stmt o sbogwrap) l2));
                                                        in
                                                          (case stmt of Assign (expr1, expr2) => f [] [Assign (expr1, expr2), s2] | AssignFnCall (optiona, expr, lista) => f [] [AssignFnCall (optiona, expr, lista), s2]
                                                            | Chaos expr => f [] [Chaos expr, s2] | EmbFnCall (expr1, expr2, lista) => f [] [EmbFnCall (expr1, expr2, lista), s2] | Block l => f l [s2]
                                                            | While (expr, optiona, statement) => f [] [While (expr, optiona, statement), s2] | Trap (trappable, statement) => f [] [Trap (trappable, statement), s2]
                                                            | Return optiona => f [] [Return optiona, s2] | ReturnFnCall (expr, lista) => f [] [ReturnFnCall (expr, lista), s2] | Break => f [] [Break, s2]
                                                            | Continue => f [] [Continue, s2] | IfStmt (expr, statement1, statement2) => f [] [IfStmt (expr, statement1, statement2), s2]
                                                            | Switch (expr, lista) => f [] [Switch (expr, lista), s2] | EmptyStmt => f [] [EmptyStmt, s2] | Auxupd abr_string => f [] [Auxupd abr_string, s2]
                                                            | Ghostupd abr_string => f [] [Ghostupd abr_string, s2] | Spec prod => f [] [Spec prod, s2] | AsmStmt (boola, asmblock) => f [] [AsmStmt (boola, asmblock), s2]
                                                            | LocalInit expr => f [] [LocalInit expr, s2])
                                                        end)))
                         end))
    x;

fun remove_last_break s =
  (case s of CCompound0 (_, [], _) => NONE
    | CCompound0 (l0, x :: xs, a) =>
      (case (case rev (x :: xs)
              of [] => dropWhile (fn aa => (case aa of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                             | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                             | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                             | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                             | CNestedFunDef0 _ => false))
                         []
              | CBlockStmt0 aa :: l =>
                (case aa of CLabel0 (ident, cStatementa, listb, aaa) =>
                           dropWhile (fn ab => (case ab of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                                 | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                                 | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                                 | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                                 | CNestedFunDef0 _ => false))
                             (CBlockStmt0 (CLabel0 (ident, cStatementa, listb, aaa)) :: l)
                  | CCase0 (cExpression, cStatementa, aaa) =>
                    dropWhile (fn ab => (case ab of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                          | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                          | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                          | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                          | CNestedFunDef0 _ => false))
                      (CBlockStmt0 (CCase0 (cExpression, cStatementa, aaa)) :: l)
                  | CCases0 (cExpression1, cExpression2, cStatementa, aaa) =>
                    dropWhile (fn ab => (case ab of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                          | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                          | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                          | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                          | CNestedFunDef0 _ => false))
                      (CBlockStmt0 (CCases0 (cExpression1, cExpression2, cStatementa, aaa)) :: l)
                  | CDefault0 (cStatementa, aaa) =>
                    dropWhile (fn ab => (case ab of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                          | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                          | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                          | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                          | CNestedFunDef0 _ => false))
                      (CBlockStmt0 (CDefault0 (cStatementa, aaa)) :: l)
                  | CExpr0 (optiona, aaa) =>
                    dropWhile (fn ab => (case ab of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                          | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                          | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                          | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                          | CNestedFunDef0 _ => false))
                      (CBlockStmt0 (CExpr0 (optiona, aaa)) :: l)
                  | CCompound0 (l0a, la, ab) => (case remove_last_break (CCompound0 (l0a, la, ab)) of NONE => l | SOME xa => CBlockStmt0 xa :: l)
                  | CIf0 (cExpression, cStatementa, optiona, aaa) =>
                    dropWhile (fn ab => (case ab of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                          | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                          | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                          | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                          | CNestedFunDef0 _ => false))
                      (CBlockStmt0 (CIf0 (cExpression, cStatementa, optiona, aaa)) :: l)
                  | CSwitch0 (cExpression, cStatementa, aaa) =>
                    dropWhile (fn ab => (case ab of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                          | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                          | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                          | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                          | CNestedFunDef0 _ => false))
                      (CBlockStmt0 (CSwitch0 (cExpression, cStatementa, aaa)) :: l)
                  | CWhile0 (cExpression, cStatementa, boola, aaa) =>
                    dropWhile (fn ab => (case ab of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                          | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                          | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                          | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                          | CNestedFunDef0 _ => false))
                      (CBlockStmt0 (CWhile0 (cExpression, cStatementa, boola, aaa)) :: l)
                  | CFor0 (either, option1, option2, cStatementa, aaa) =>
                    dropWhile (fn ab => (case ab of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                          | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                          | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                          | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                          | CNestedFunDef0 _ => false))
                      (CBlockStmt0 (CFor0 (either, option1, option2, cStatementa, aaa)) :: l)
                  | CGoto0 (ident, aaa) =>
                    dropWhile (fn ab => (case ab of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                          | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                          | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                          | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                          | CNestedFunDef0 _ => false))
                      (CBlockStmt0 (CGoto0 (ident, aaa)) :: l)
                  | CGotoPtr0 (cExpression, aaa) =>
                    dropWhile (fn ab => (case ab of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                          | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                          | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                          | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                          | CNestedFunDef0 _ => false))
                      (CBlockStmt0 (CGotoPtr0 (cExpression, aaa)) :: l)
                  | CCont0 aaa =>
                    dropWhile (fn ab => (case ab of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                          | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                          | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                          | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                          | CNestedFunDef0 _ => false))
                      (CBlockStmt0 (CCont0 aaa) :: l)
                  | CBreak0 aaa =>
                    dropWhile (fn ab => (case ab of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                          | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                          | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                          | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                          | CNestedFunDef0 _ => false))
                      (CBlockStmt0 (CBreak0 aaa) :: l)
                  | CReturn0 (optiona, aaa) =>
                    dropWhile (fn ab => (case ab of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                          | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                          | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                          | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                          | CNestedFunDef0 _ => false))
                      (CBlockStmt0 (CReturn0 (optiona, aaa)) :: l)
                  | CAsm0 (cAssemblyStatement, aaa) =>
                    dropWhile (fn ab => (case ab of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                          | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                          | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                          | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                          | CNestedFunDef0 _ => false))
                      (CBlockStmt0 (CAsm0 (cAssemblyStatement, aaa)) :: l))
              | CBlockDecl0 cDeclaration :: l =>
                dropWhile (fn aa => (case aa of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                      | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                      | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                      | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                      | CNestedFunDef0 _ => false))
                  (CBlockDecl0 cDeclaration :: l)
              | CNestedFunDef0 cFunctionDef :: l =>
                dropWhile (fn aa => (case aa of CBlockStmt0 (CLabel0 (_, _, _, _)) => false | CBlockStmt0 (CCase0 (_, _, _)) => false | CBlockStmt0 (CCases0 (_, _, _, _)) => false | CBlockStmt0 (CDefault0 (_, _)) => false
                                      | CBlockStmt0 (CExpr0 (_, _)) => false | CBlockStmt0 (CCompound0 (_, _, _)) => false | CBlockStmt0 (CIf0 (_, _, _, _)) => false | CBlockStmt0 (CSwitch0 (_, _, _)) => false
                                      | CBlockStmt0 (CWhile0 (_, _, _, _)) => false | CBlockStmt0 (CFor0 (_, _, _, _, _)) => false | CBlockStmt0 (CGoto0 (_, _)) => false | CBlockStmt0 (CGotoPtr0 (_, _)) => false
                                      | CBlockStmt0 (CCont0 _) => false | CBlockStmt0 (CBreak0 _) => true | CBlockStmt0 (CReturn0 (_, _)) => false | CBlockStmt0 (CAsm0 (_, _)) => false | CBlockDecl0 _ => false
                                      | CNestedFunDef0 _ => false))
                  (CNestedFunDef0 cFunctionDef :: l))
        of [] => NONE | aa :: lista => SOME (CCompound0 (l0, rev (aa :: lista), a)))
    | CBreak0 _ => NONE);

fun statement0_case l s =
  (case s of CLabel0 (_, _, _, _) => (false, (rev l, s)) | CCase0 (e, sa, _) => statement0_case (e :: l) sa | CCases0 (_, _, _, _) => (false, (rev l, s)) | CDefault0 (sa, _) => (true, (rev l, sa)) | CExpr0 (_, _) => (false, (rev l, s))
    | CCompound0 (_, _, _) => (false, (rev l, s)) | CIf0 (_, _, _, _) => (false, (rev l, s)) | CSwitch0 (_, _, _) => (false, (rev l, s)) | CWhile0 (_, _, _, _) => (false, (rev l, s)) | CFor0 (_, _, _, _, _) => (false, (rev l, s))
    | CGoto0 (_, _) => (false, (rev l, s)) | CGotoPtr0 (_, _) => (false, (rev l, s)) | CCont0 _ => (false, (rev l, s)) | CBreak0 _ => (false, (rev l, s)) | CReturn0 (_, _) => (false, (rev l, s)) | CAsm0 (_, _) => (false, (rev l, s)));

fun statement_Switch statement0 block_item_list0 expr l n_info =
  Trap (BreakT, sbogwrap (Switch (expression expr,
                                   let
                                     val (l_def, l_case) =
                                       app_rev (app_rev (app_rev (app_rev (app_rev l (mapa (fn CBlockStmt0 s => s)))
                                                                   (groupBy (fn _ => fn a =>
                                                                              (case a of CLabel0 (_, _, _, _) => true | CCase0 (_, _, _) => false | CCases0 (_, _, _, _) => true | CDefault0 (_, _) => false | CExpr0 (_, _) => true
                                                                                | CCompound0 (_, _, _) => true | CIf0 (_, _, _, _) => true | CSwitch0 (_, _, _) => true | CWhile0 (_, _, _, _) => true | CFor0 (_, _, _, _, _) => true
                                                                                | CGoto0 (_, _) => true | CGotoPtr0 (_, _) => true | CCont0 _ => true | CBreak0 _ => true | CReturn0 (_, _) => true | CAsm0 (_, _) => true))))
                                                          (fn la => foldr (fn x :: xs => fn (acc, pos2) =>
                                                                            let
                                                                              val pos1 = p_first_of_NodeInfo (pos_of_CStat x);
                                                                            in
                                                                              (map_prod (fn a => (case a of [] => [NONE] | aa :: lista => mapa (SOME o expression) (aa :: lista)))
                                                                                 (fn xa => (case remove_last_break (CCompound0 ([], mapa CBlockStmt0 (xa :: xs), n_info)) of NONE => []
                                                                                             | SOME (CCompound0 (_, lb, _)) => block_item_list0 lb (pos1, pos2)))
                                                                                 (case statement0_case [] x of (true, (_, s)) => ([], s) | (false, (lb, s)) => (lb, s)) ::
                                                                                 acc,
                                                                                pos1)
                                                                            end)
                                                                      la ([], p_last_of_NodeInfo n_info)))
                                                 fst)
                                         (partition (fn a => (case a of ([], _) => false | ([NONE], _) => true | (NONE :: _ :: _, _) => false | (SOME _ :: _, _) => false)));
                                   in
                                     l_case @ (if null l_def then [([NONE], [BI_Stmt (sbogwrap EmptyStmt)])] else l_def)
                                   end)));

fun filter_invariant x =
  filter_gen (fn a => (case a of Invariant aa => SOME aa | Fnspeca _ => NONE | Relspeca _ => NONE | Modifies _ => NONE | Dont_translate => NONE | Auxupda _ => NONE | Ghostupda _ => NONE | Speca _ => NONE | End_spec _ => NONE
                        | Calls _ => NONE | Owned_by _ => NONE | OTHER _ => NONE))
    bogwrap x;

fun statement_While expr =
  (fn (stat, pos_stat) => fn is_do => fn (pos, rbt) =>
    Trap (BreakT, sbogwrap let
                             val body = sbogwrap (Trap (ContinueT, stat));
                             val loop = While (expression (stmt_out_of_expra expr),
                                                filter_invariant (comment_interval rbt ((if is_do then p_first_of_NodeInfo pos else p_last_of_NodeInfo (pos_of_CExpr expr)), p_first_of_NodeInfo pos_stat)), body);
                           in
                             (if is_do then Block (mapa BI_Stmt [body, sbogwrap loop]) else loop)
                           end));

fun stringLiteral x = (fn CStrLit0 (CString0 (s, _), _) => replace_integersa (fn xa => (if xa = (10 : IntInf.int) then SS_base (ST "\092n") else SS_base (STa [xa]))) s) x;

fun assemblyOperand x = mapa (fn CAsmOperand0 (o_i, s, e, _) => (ident_option o_i, (stringLiteral s, expression e))) x;

fun statement_For exp_decl o_expr2 o_expr3 =
  (fn (stat, pos_stat) => fn (pos, rbt) =>
    let
      val of_expr = (fn f => fn o_expr => mapa (BI_Stmt o sbogwrap) (f [statement_node_of_expressiona o_expr (SOME (pos_stat, rbt))]));
    in
      Block ((case exp_decl of Left a => of_expr id a | Right a => declaration (rbt, NONE) BI_Decl a) @
              [BI_Stmt (sbogwrap (Trap (BreakT, sbogwrap (While ((case o_expr2 of None => expr_int (1 : IntInf.int) | Some expr => expression (stmt_out_of_expra expr)),
                                                                  filter_invariant
                                                                    (comment_interval rbt
                                                                      (let
                                                                         val p_last = p_last_of_NodeInfo o pos_of_CExpr;
                                                                       in
                                                                         (case o_expr3
                                                                           of None => (case o_expr2
                                                                                        of None => (case exp_decl of Left a => (case a of None => p_first_of_NodeInfo pos | Some aa => p_last aa)
                                                                                                     | Right d => p_last_of_NodeInfo (pos_of_CDecl d))
                                                                                        | Some a => p_last a)
                                                                           | Some a => p_last a)
                                                                       end,
                                                                        p_first_of_NodeInfo pos_stat)),
                                                                  sbogwrap (Block (of_expr (fn a => Trap (ContinueT, stat) :: a) o_expr3)))))))])
    end);

fun statement_If statement0 expr stat1 o_stat2 = IfStmt (expression expr, statement0 stat1, (case o_stat2 of None => sbogwrap EmptyStmt | Some a => statement0 a));

fun group_spec_aux1 l x =
  (case x of [] => concat (rev l) | Inl xa :: xs => group_spec_aux1 (xa :: l) xs | Inr [Inl x1] :: xs => let
                                                                                                           val Inl l_body :: Inr [Inr x2] :: xsa = xs;
                                                                                                         in
                                                                                                           group_spec_aux2 l x1 l_body x2 xsa
                                                                                                         end
    | Inr [Inl x1, Inr x2] :: xs => group_spec_aux2 l x1 [] x2 xs)
and group_spec_aux2 l x1 l_body x2 xs = group_spec_aux1 ([BI_Stmt (sbogwrap (Spec (x1, (mapa (fn BI_Stmt s => s) l_body, x2))))] :: l) xs;

fun group_spec l =
  app_rev (app_rev (app_rev l (groupBy (fn a => fn b => (case (a, b) of (Inl _, Inl _) => true | (Inl _, Inr _) => false | (Inr _, Inl _) => false | (Inr _, Inr _) => true))))
            (mapa (fn a => (case a of Inl x :: xs => Inl (x :: mapa (fn Inl xa => xa) xs) | Inr x :: xs => Inr (x :: mapa (fn Inr xa => xa) xs)))))
    (group_spec_aux1 []);

fun block_item_list0a rbt l pos = block_item_list0 rbt l (p_first_of_NodeInfo pos, p_last_of_NodeInfo pos)
and statement0 rbt s =
  (sbogwrap o (fn a => (case a of CLabel0 (_, _, _, _) => let
                                                            val _ = not_yet_supported (SS_base (ST "CLabel not yet supported (Break returned)"));
                                                          in
                                                            Break
                                                          end
                         | CExpr0 (e, _) => statement_node_of_expressiona e NONE | CCompound0 ([], l, pos) => Block (block_item_list0a rbt l pos)
                         | CIf0 (expr, stat1, o_stat2, _) => statement_If (statement0 rbt) (stmt_out_of_expra expr) stat1 o_stat2
                         | CSwitch0 (expr, CCompound0 ([], l, n_info), _) => statement_Switch (statement0 rbt) (block_item_list0 rbt) expr l n_info
                         | CWhile0 (expr, stat, is_do, pos) => statement_While expr (statement0 rbt stat, pos_of_CStat stat) is_do (pos, rbt)
                         | CFor0 (exp_decl, o_expr2, o_expr3, stat, pos) => statement_For exp_decl o_expr2 o_expr3 (statement0 rbt stat, pos_of_CStat stat) (pos, rbt)
                         | CGoto0 (_, _) => let
                                              val _ = not_yet_supported (SS_base (ST "CGoto not yet supported (Break returned)"));
                                            in
                                              Break
                                            end
                         | CCont0 _ => Continue | CBreak0 _ => Break | CReturn0 (None, _) => Return (map_option (expression o stmt_out_of_expra) None)
                         | CReturn0 (Some (CComma0 (lista, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CComma0 (lista, ab))))
                         | CReturn0 (Some (CAssign0 (cAssignOp, cExpression1, cExpression2, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CAssign0 (cAssignOp, cExpression1, cExpression2, ab))))
                         | CReturn0 (Some (CCond0 (cExpression1, optiona, cExpression2, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CCond0 (cExpression1, optiona, cExpression2, ab))))
                         | CReturn0 (Some (CBinary0 (cBinaryOp, cExpression1, cExpression2, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CBinary0 (cBinaryOp, cExpression1, cExpression2, ab))))
                         | CReturn0 (Some (CCast0 (cDeclaration, cExpression, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CCast0 (cDeclaration, cExpression, ab))))
                         | CReturn0 (Some (CUnary0 (cUnaryOp, cExpression, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CUnary0 (cUnaryOp, cExpression, ab))))
                         | CReturn0 (Some (CSizeofExpr0 (cExpression, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CSizeofExpr0 (cExpression, ab))))
                         | CReturn0 (Some (CSizeofType0 (cDeclaration, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CSizeofType0 (cDeclaration, ab))))
                         | CReturn0 (Some (CAlignofExpr0 (cExpression, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CAlignofExpr0 (cExpression, ab))))
                         | CReturn0 (Some (CAlignofType0 (cDeclaration, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CAlignofType0 (cDeclaration, ab))))
                         | CReturn0 (Some (CComplexReal0 (cExpression, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CComplexReal0 (cExpression, ab))))
                         | CReturn0 (Some (CComplexImag0 (cExpression, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CComplexImag0 (cExpression, ab))))
                         | CReturn0 (Some (CIndex0 (cExpression1, cExpression2, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CIndex0 (cExpression1, cExpression2, ab))))
                         | CReturn0 (Some (CCall0 (f, l_arg, _)), _) => ReturnFnCall (expression f, mapa expression l_arg)
                         | CReturn0 (Some (CMember0 (cExpression, identa, boola, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CMember0 (cExpression, identa, boola, ab))))
                         | CReturn0 (Some (CVar0 (identa, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CVar0 (identa, ab))))
                         | CReturn0 (Some (CConst0 cConstant), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CConst0 cConstant)))
                         | CReturn0 (Some (CCompoundLit0 (cDeclaration, lista, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CCompoundLit0 (cDeclaration, lista, ab))))
                         | CReturn0 (Some (CGenericSelection0 (cExpression, lista, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CGenericSelection0 (cExpression, lista, ab))))
                         | CReturn0 (Some (CStatExpr0 (cStatement, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CStatExpr0 (cStatement, ab))))
                         | CReturn0 (Some (CLabAddrExpr0 (identa, ab)), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CLabAddrExpr0 (identa, ab))))
                         | CReturn0 (Some (CBuiltinExpr0 cBuiltinThing), _) => Return (map_option (expression o stmt_out_of_expra) (Some (CBuiltinExpr0 cBuiltinThing)))
                         | CAsm0 (CAsmStmt0 (Some (CVolatQual0 _), sa, l1, l2, l3, _), _) => AsmStmt (true, Asmblock (stringLiteral sa, assemblyOperand l1, assemblyOperand l2, mapa stringLiteral l3)))))
    s
and block_item_list0 rbt l =
  (fn (pos1, pos2) =>
    app_rev (app_rev let
                       val (acc, pos1a) =
                         fold (fn x => fn (acc, pos1a) =>
                                let
                                  val n = pos_of_CBlockItem x;
                                in
                                  (mapa Inl (case x of CBlockStmt0 s => [BI_Stmt (statement0 rbt s)] | CBlockDecl0 a => declaration (rbt, NONE) BI_Decl a
                                              | CNestedFunDef0 _ => let
                                                                      val _ = not_yet_supported (SS_base (ST "CNestedFunDef not yet supported (empty list returned)"));
                                                                    in
                                                                      []
                                                                    end) ::
                                     filter_statement (comment_interval rbt (pos1a, p_first_of_NodeInfo n)) :: acc,
                                    p_last_of_NodeInfo n)
                                end)
                           l ([], pos1);
                     in
                       app_rev (filter_statement (comment_interval rbt (pos1a, pos2)) :: acc) rev
                     end
              concat)
      group_spec);

fun comp3 f g = (fn x => fn y => fn z => f (g x y z));

fun block_item_list x = comp3 bogwrap block_item_list0a x;

fun function_definition x =
  (fn (rbt, pos_init) => fn a =>
    (case a of CFunDef0 (_, CDeclr0 (None, _, _, _, _), _, _, _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CLabel0 (_, _, _, _), _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CCase0 (_, _, _), _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CCases0 (_, _, _, _), _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CDefault0 (_, _), _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CExpr0 (_, _), _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (l_decl_spec, CDeclr0 (Some i, dDs_root, _, _, _), [], CCompound0 ([], l_stmt, pos_stmt), pos) =>
        let
          val CFunDeclr0 (Right (arg, _), _, _) :: dDs = dDs_root;
          val l_fnspec = attrs l_decl_spec dDs_root [] ((rbt, pos_init), p_first_of_NodeInfo pos);
          val rettype = let
                          val ret_ty = decl_spec_ty l_decl_spec;
                        in
                          (case dDs of [] => ret_ty | [CPtrDeclr0 (_, _)] => Ptr ret_ty)
                        end;
          val name = bogwrap (ident i);
        in
          (if list_ex (fn aa => (case aa of Fnspec _ => false | Relspec _ => false | Fn_modifies _ => false | Didnt_translate => true | Gcc_attribs _ => false)) l_fnspec
            then Decl (bogwrap (ExtFnDecl (rettype, name, function_definition_params SOME arg, l_fnspec))) else FnDefn ((rettype, name), function_definition_params bogwrap arg, l_fnspec, block_item_list rbt l_stmt pos_stmt))
        end
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CCompound0 (_ :: _, _, _), _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CIf0 (_, _, _, _), _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CSwitch0 (_, _, _), _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CWhile0 (_, _, _, _), _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CFor0 (_, _, _, _, _), _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CGoto0 (_, _), _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CGotoPtr0 (_, _), _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CCont0 _, _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CBreak0 _, _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CReturn0 (_, _), _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), [], CAsm0 (_, _), _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))
      | CFunDef0 (_, CDeclr0 (Some _, _, _, _, _), _ :: _, _, _) => errora (SS_base (ST "Not yet covered: This case means the parsing has actually visited the 'function_declarator_old' branch, see Parser.y ."))))
    x;

fun external_declaration pos_init =
  (fn a => (case a of CDeclExt0 aa => declaration pos_init Decl aa | CFDefExt0 f => [function_definition pos_init f]
             | CAsmExt0 (_, _) => let
                                    val _ = not_yet_supported (SS_base (ST "Assembly declaration not yet supported (empty list returned)"));
                                  in
                                    []
                                  end));

fun pos_of_CExtDecl x = (fn a => (case a of CDeclExt0 aa => pos_of_CDecl aa | CFDefExt0 aa => pos_of_CFunDef aa | CAsmExt0 (_, pos) => pos)) x;

fun mapc A_ f = bulkload A_ o mapa (fn (k, v) => (k, f k v)) o entries;

fun translation_unit x =
  (fn (CTranslUnit0 (l, pos), (l_comm, _)) =>
    let
      val (l_comma, rbt) =
        (case current_parsing_style
          of Style_Haskell =>
            (mapa (fn Commenta (Position0 (pp, ff, ll, cc), ss, fmt) => Commenta (Position0 (pp, (if equal_abr_stringa ff (SS_base (ST "")) then let
                             val (Position0 (_, ffa, _, _), _) = p_first_of_NodeInfo pos;
                           in
                             ffa
                           end
                                                                                                   else ff),
                                                                                              ll, cc),
                                                                                   ss, fmt))
               l_comm,
              app_rev (fold (fn Commenta (Position0 (_, ff, ll, cc), ss, _) => fn rbt =>
                              let
                                val k = (ff, ll);
                              in
                                insert (equal_prod equal_abr_string equal_integer) k
                                  let
                                    val rbta = (case lookupa (equal_prod equal_abr_string equal_integer) rbt k of NONE => emptya | SOME rbta => rbta);
                                  in
                                    (case lookupa equal_integer rbta cc of NONE => insert equal_integer cc ss rbta | SOME ssa => (if equal_abr_stringa ss ssa then rbta else errora (SS_base (ST "encountered different comments"))))
                                  end
                                  rbt
                              end)
                        l_comm emptya)
                (mapc (equal_prod equal_abr_string equal_integer) (fn _ => mapa (map_prod id (integer_of_nat o length)) o entries)))
          | Style_ML => (l_comm, emptya));
      val (_, (_, la)) =
        fold (fn fna => fn (pos1, (l_commb, acc)) => let
                                                       val pos2 = p_last_of_NodeInfo (pos_of_CExtDecl fna);
                                                       val f_take = (fn Commenta (posa, _, _) => pos_in_interval rbt (pos1, pos2) posa);
                                                       val (l_take, l_drop) = partition f_take l_commb;
                                                     in
                                                       (pos2, (l_drop, external_declaration ((l_take, rbt), SOME pos1) fna :: acc))
                                                     end)
          l ((Position0 ((0 : IntInf.int), SS_base (ST ""), (1 : IntInf.int), (1 : IntInf.int)), (1 : IntInf.int)), (l_comma, []));
    in
      concat (rev la)
    end)
    x;

fun main x = translation_unit x;

fun txta s = txt (fn _ => fn _ => s);

fun succ (A1_, A2_) x = plusa A2_ x (one A1_);

fun flip x = (fn (a, b) => (b, a)) x;

fun find uu [] = NONE
  | find p (x :: xs) = (if p x then SOME x else find p xs);

fun last (x :: xs) = (if null xs then x else last xs);

fun minus_int k l = Int_of_integer (integer_of_int k - integer_of_int l);

fun less_int k l = integer_of_int k < integer_of_int l;

fun upto_aux i j js = (if less_int j i then js else upto_aux i (minus_int j one_inta) (j :: js));

fun uptoa i j = upto_aux i j [];

fun txtb x = (txta o flattena) x;

fun modulo_nat m n = Nat (modulo_integer (integer_of_nat m) (integer_of_nat n));

fun divide_nat m n = Nat (divide_integer (integer_of_nat m) (integer_of_nat n));

fun nat_to_digit10_aux l n = (if less_nat n (nat_of_integer (10 : IntInf.int)) then n :: l else nat_to_digit10_aux (modulo_nat n (nat_of_integer (10 : IntInf.int)) :: l) (divide_nat n (nat_of_integer (10 : IntInf.int))));

fun nat_to_digit10 n = let
                         val nat_raw_to_str = map (integer_of_nat o plus_nat (nat_of_integer (48 : IntInf.int)));
                       in
                         SS_base (STa (nat_raw_to_str (nat_to_digit10_aux [] n)))
                       end;

fun add_0 n =
  let
    val na = nat_of_integer n;
  in
    flattenb (flattena (map (fn _ => SS_base (ST "0"))
                         (upt zero_nata (if less_nat na (nat_of_integer (10 : IntInf.int)) then nat_of_integer (2 : IntInf.int) else (if less_nat na (nat_of_integer (100 : IntInf.int)) then one_nat else zero_nata)))))
      (nat_to_digit10 na)
  end;

fun l_fold f = let
                 val f_locale = (fn loc_data => fn l => f (Embedding_fun_simple (fn a => fn b => let
                                                                                                   val ba = loc_data a b;
                                                                                                   val (loc_dataa, bb) = ba;
                                                                                                   val aa = fold (fn f0 => fn (la, bc) => let
                      val aa = f0 a bc;
                      val (x, ab) = aa;
                    in
                      (x :: la, ab)
                    end)
                                                                                                              l ([], bb);
                                                                                                   val (la, ab) = aa;
                                                                                                 in
                                                                                                   ([META_semi_theories (Theories_locale (loc_dataa, rev la))], ab)
                                                                                                 end)));
               in
                 (fn a => (case a of Embed_theories aa => fold f aa | Embed_locale (l_th1, loc_data, l_loc, l_th2) => fold f l_th2 o f_locale loc_data l_loc o fold f l_th1))
               end;

fun txt_a s = txt (fn _ => fn a => (case a of Gen_only_design => SS_base (ST "") | Gen_only_analysis => flattena s | Gen_default => flattena s));

fun fun_upd A_ f a b = (fn x => (if eq A_ x a then b else f x));

fun bind f0 f l = let
                    val la = map f0 l;
                  in
                    (if list_ex (fn a => (case a of NONE => true | SOME _ => false)) la then NONE else SOME (f (map_filter id la)))
                  end;

fun mapi f l = rev (fst (foldl (fn (la, cpt) => fn x => (f cpt x :: la, succ (one_natural, plus_natural) cpt)) ([], Code_Numeral.zero_natural) l));

fun flatten l = foldl (fn acc => fn la => foldl (fn acca => fn x => x :: acca) acc (rev la)) [] (rev l);

fun mapsa f x = flatten (map f x);

fun enumerate n (x :: xs) = (n, x) :: enumerate (suc n) xs
  | enumerate n [] = [];

fun split l = (map fst l, map snd l);

fun takea reverse lg l = reverse (snd (split (takeWhile (fn (n, _) => less_nat n lg) (enumerate zero_nata (reverse l)))));

fun uptob i j = let
                  val to_i = (fn n => Int_of_integer (Code_Numeral.integer_of_natural n));
                in
                  map (Code_Numeral.natural_of_integer o integer_of_int) (uptoa (to_i i) (to_i j))
                end;

fun mk_dot s1 s2 = flattena [SS_base (ST "."), s1, s2];

fun filter p [] = []
  | filter p (x :: xs) = (if p x then x :: filter p xs else filter p xs);

fun binda NONE f = NONE
  | binda (SOME x) f = f x;

fun start_mapa f x accu = (f x, accu);

fun sectionb x = i Theory_section x;

fun section_aux n s = start_mapa (fn _ => [sectionb (Section (n, s))]);

fun section x = section_aux Code_Numeral.zero_natural x;

fun txt_aa s = txt (fn n_thy => fn a => (case a of Gen_only_design => SS_base (ST "") | Gen_only_analysis => flattena (s n_thy) | Gen_default => flattena (s n_thy)));

fun txt_d s = txt (fn n_thy => fn a => (case a of Gen_only_design => flattena (s n_thy) | Gen_only_analysis => SS_base (ST "") | Gen_default => SS_base (ST "")));

fun text_raw x = i Theory_text_raw x;

fun txt_raw f = Embedding_fun_simple (start_mapf text_raw o (fn _ => fn n_thy => fn design_analysis => [Text_raw (f n_thy design_analysis)]));

fun assoc A_ x1 l = fold (fn (x2, v) => fn a => (case a of NONE => (if eq A_ x1 x2 then SOME v else NONE) | SOME aa => SOME aa)) l NONE;

fun n_lists n xs = (if equal_nata n zero_nata then [[]] else maps (fn ys => mapa (fn y => y :: ys) xs) (n_lists (minus_nat n one_nat) xs));

fun sectiona x = (Embedding_fun_simple o section) x;

fun equal_ocl_ctxt_prefix OclCtxtPre OclCtxtPost = false
  | equal_ocl_ctxt_prefix OclCtxtPost OclCtxtPre = false
  | equal_ocl_ctxt_prefix OclCtxtPost OclCtxtPost = true
  | equal_ocl_ctxt_prefix OclCtxtPre OclCtxtPre = true;

fun d_output_sorry_dirty
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = d_output_sorry_dirty;

fun d_input_class
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = d_input_class;

fun ctxt_fun_name (Ocl_ctxt_pre_post_ext (ctxt_fun_name, ctxt_fun_ty, ctxt_expr, more)) = ctxt_fun_name;

fun split_at f l = let
                     val fa = (fn x => not (f x));
                   in
                     (takeWhile fa l, (case dropWhile fa l of [] => (NONE, []) | x :: a => (SOME x, a)))
                   end;

fun print_ctxt_to_ocl_gen_split s = (case split_at (fn sa => sa = (46 : IntInf.int)) (to_list s) of (_, (NONE, _)) => NONE | (_, (SOME _, sa)) => SOME sa);

fun term_parenthesis x = Term_paren (SS_base (ST "("), SS_base (ST ")"), x);

fun term_warning_parenthesis x = term_parenthesis x;

fun ctxt_fun_ty (Ocl_ctxt_pre_post_ext (ctxt_fun_name, ctxt_fun_ty, ctxt_expr, more)) = ctxt_fun_ty;

fun fold_pair_var f t accu =
  (case t of OclTy_base_void => SOME accu | OclTy_base_boolean => SOME accu | OclTy_base_integer => SOME accu | OclTy_base_unlimitednatural => SOME accu | OclTy_base_real => SOME accu | OclTy_base_string => SOME accu
    | OclTy_object _ => SOME accu | OclTy_collection (_, ta) => fold_pair_var f ta accu | OclTy_pair (t1, t2) => binda (fold_pair_var f t1 accu) (fold_pair_var f t2) | OclTy_binding (NONE, ta) => fold_pair_var f ta accu
    | OclTy_binding (SOME v, ta) => fold_pair_var f ta (f (v, ta) accu) | OclTy_arrow (_, _) => NONE | OclTy_class_syn _ => SOME accu | OclTy_enum _ => SOME accu | OclTy_raw _ => SOME accu);

fun ctxt_fun_ty_arg ctxt =
  let
    val SOME a = fold_pair_var (fn a => fn b => a :: b)
                   (case ctxt_fun_ty ctxt of OclTy_base_void => OclTy_base_void | OclTy_base_boolean => OclTy_base_boolean | OclTy_base_integer => OclTy_base_integer | OclTy_base_unlimitednatural => OclTy_base_unlimitednatural
                     | OclTy_base_real => OclTy_base_real | OclTy_base_string => OclTy_base_string | OclTy_object a => OclTy_object a | OclTy_collection (a, b) => OclTy_collection (a, b) | OclTy_pair (a, b) => OclTy_pair (a, b)
                     | OclTy_binding a => OclTy_binding a | OclTy_arrow (t, _) => t | OclTy_class_syn a => OclTy_class_syn a | OclTy_enum a => OclTy_enum a | OclTy_raw a => OclTy_raw a)
                   [];
  in
    rev a
  end;

val var_result : abr_string = SS_base (ST "result");

val var_self : abr_string = SS_base (ST "self");

fun make_ctxt_free_var pref ctxt = var_self :: flatten [map fst (ctxt_fun_ty_arg ctxt), (if equal_ocl_ctxt_prefix pref OclCtxtPre then [] else [var_result])];

fun interpretation x = i Theory_interpretation x;

fun term_lambdas s = (fn a => Term_bind (SS_base (ST "\092<lambda>"), Term_basic s, a));

fun term_lambda x = term_lambdas [x];

fun term_applys0 e l = term_parenthesis (Term_apply (e, map term_parenthesis l));

fun term_app e = term_applys0 (Term_basic [e]);

val sorry : semi_command_final = Command_sorry;

fun is_none (SOME x) = false
  | is_none NONE = true;

fun print_ctxt_pre_post_interp x =
  (fn (sorrya, dirty) => fn name => fn ctxt => fn e_name => fn e_pre => fn e_post =>
    let
      val _ = (fn f => fn xa => term_app f [xa]);
      val _ = (fn s => Term_basic [s]);
      val f = (fn (pref, a) => foldr term_lambda (make_ctxt_free_var pref ctxt) a);
      val lg = size_list (ctxt_fun_ty_arg ctxt);
    in
      (if (equal_optiona equal_generation_lemma_mode sorrya (SOME Gen_sorry) orelse is_none sorrya andalso dirty) andalso less_eq_nat lg (nat_of_integer (3 : IntInf.int))
        then SOME (interpretation (Interpretation (name, flattenb (SS_base (ST "contract")) (nat_to_digit10 lg), [e_name, f e_pre, f e_post], sorry))) else NONE)
    end)
    x;

fun isup s = flattenb (SS_base (ST "__")) s;

fun print_ctxt_const_name attr_n var_at_when_hol name = flattenb (flattena [SS_base (ST "dot"), isup attr_n, var_at_when_hol]) (case name of NONE => SS_base (ST "") | SOME a => flattenb (SS_base (ST "_")) a);

fun hol_definition s = flattena [s, SS_base (ST "_def")];

fun print_ctxt_pre_post_name attr_n var_at_when_hol name = hol_definition (print_ctxt_const_name attr_n var_at_when_hol name);

fun d_ocl_accessor
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = d_ocl_accessor;

fun take_first x = takea id x;

fun take_last x = takea rev x;

fun print_ctxt_is_name_at_gen var s = let
                                        val vara = to_list var;
                                        val sa = to_list s;
                                        val _ :: _ = vara;
                                        val lg_var = size_list vara;
                                      in
                                        (if equal_lista equal_integer (take_last lg_var sa) vara then SOME (SS_base (STa (take_first (minus_nat (size_list sa) lg_var) sa))) else NONE)
                                      end;

val var_at_when_hol_pre : abr_string = SS_base (ST "at_pre");

fun print_ctxt_is_name_at_pre x = print_ctxt_is_name_at_gen var_at_when_hol_pre x;

val var_at_when_hol_post : abr_string = SS_base (ST "");

fun print_ctxt_is_name_at_post x = let
                                     val [] = to_list var_at_when_hol_post;
                                   in
                                     (fn s => (case print_ctxt_is_name_at_pre s of NONE => SOME s | SOME _ => NONE))
                                   end
                                     x;

fun to_lista x = (fn a => (case a of ST aa => (List.map (fn c => let val k = Char.ord c in if k < 128 then IntInf.fromInt k else raise Fail "Non-ASCII character in literal" end)  o String.explode) aa | STa l => l)) x;

fun fold_Const f accu expr = (case expr of Consta (s, _) => f accu s | Free (_, _) => accu | Var (_, _) => accu | Bound _ => accu | Absa (_, _, a) => fold_Const f accu a | Appa (term1, a) => fold_Const f (fold_Const f accu term1) a);

fun map_Const f expr =
  (case expr of Consta (s, ty) => Consta (f s ty, ty) | Free (a, b) => Free (a, b) | Var (a, b) => Var (a, b) | Bound a => Bound a | Absa (s, ty, term) => Absa (s, ty, map_Const f term)
    | Appa (term1, term2) => Appa (map_Const f term1, map_Const f term2));

fun print_ctxt_to_ocl_gen l_access f var =
  let
    val l_ex = (fn s => list_ex (case print_ctxt_to_ocl_gen_split s of NONE => (fn _ => false) | SOME sa => (fn n => equal_lista equal_integer (to_lista n) sa)) l_access);
  in
    (fn T_pure (t, o_s) =>
      T_pure (map_Const (fn s => fn _ => (if l_ex s then (case f s of NONE => s | SOME sa => flattenb sa var) else s)) t, (if fold_Const (fn b => fn s => b orelse l_ex s andalso not (is_none (f s))) false t then NONE else o_s)))
  end;

fun print_ctxt_to_ocl_pre env = print_ctxt_to_ocl_gen (snd (d_ocl_accessor env)) print_ctxt_is_name_at_post var_at_when_hol_pre;

fun nat_of_natural x = (nat_of_integer o Code_Numeral.integer_of_natural) x;

fun natural_to_digit10 x = (nat_to_digit10 o nat_of_natural) x;

val var_at_when_ocl_post : abr_string = SS_base (ST "");

fun term_postunary e1 e2 = Term_apply (e1, [e2]);

fun fold_Free f accu expr = (case expr of Consta (_, _) => accu | Free (s, _) => f accu s | Var (_, _) => accu | Bound _ => accu | Absa (_, _, a) => fold_Free f accu a | Appa (term1, a) => fold_Free f (fold_Free f accu term1) a);

fun stringa x = SML_string x;

fun binop x = (fn a => fn b => SML_binop (x, a, b));

fun binop_l s l = let
                    val x :: xs = rev l;
                  in
                    fold (fn xa => binop xa s) xs x
                  end;

fun paren x = (fn a => fn b => SML_paren (x, a, b));

fun basic x = SML_basic x;

fun lista l = (case l of [] => basic [SS_base (ST "[]")] | _ :: _ => paren (SS_base (ST "[")) (SS_base (ST "]")) (binop_l (SS_base (ST ",")) l));

fun listb f l = lista (map f l);

fun parenthesis x = paren (SS_base (ST "(")) (SS_base (ST ")")) x;

fun pair e1 e2 = parenthesis (binop e1 (SS_base (ST ",")) e2);

fun apply x = (fn a => SML_apply (x, a));

fun app s = apply (basic [s]);

fun app0 s1 s2 = SML_top [SML_val_fun (NONE, app s1 s2)];

fun raise_ml l_out s =
  SMLa (app0 (SS_base (ST "Ty'.check"))
         [listb (fn (rep, sa) => pair (basic [flattena [SS_base (ST "META."), (case rep of Warning => SS_base (ST "Warning") | Error => SS_base (ST "Error") | Writeln => SS_base (ST "Writeln"))]]) (stringa sa)) l_out, stringa s]);

fun ml x = i Theory_ML x;

fun raise_ml_unbound f_msg ctxt =
  [(fn _ => [ml (raise_ml let
                            val l = flatten (mapi (fn n => fn (msg, T_pure (t, _)) => let
                                                                                        val l = rev (fold_Free (fn l => fn s => (Error, flattena [f_msg n msg, SS_base (ST ": unbound value "), s]) :: l) [] t);
                                                                                      in
                                                                                        (if null l then [(Writeln, f_msg n msg)] else l)
                                                                                      end)
                                              ctxt);
                          in
                            (if list_ex (fn a => (case a of (Warning, _) => false | (Error, _) => true | (Writeln, _) => false)) l then l else [])
                          end
                  (SS_base (ST " error(s)")))])];

fun term_lambdas0 x = (fn a => Term_bind (SS_base (ST "\092<lambda>"), x, a));

fun axiomatization x = i Theory_axiomatization x;

fun overloadinga n ty = (fn a => fn b => Overloading (n, Term_annot (Term_basic [n], ty), a, b));

fun ty_obj_to_string x = (fn OclTyObj (OclTyCore_pre s, _) => s) x;

fun ctxt_ty (Ocl_ctxt_ext (ctxt_param, ctxt_ty, ctxt_clause, more)) = ctxt_ty;

fun term_binop x = (fn a => fn b => Term_rewrite (x, a, b));

fun term_binopa s l = let
                        val x :: xs = rev l;
                      in
                        fold (fn xa => term_binop xa s) xs x
                      end;

fun term_annot e s = Term_annot (e, Typ_base s);

fun wrap_oclty x = flattenb (SS_base (ST "\092<cdot>")) x;

fun term_annot_ocl e s = term_annot e (wrap_oclty s);

fun overloading x = i Theory_overloading x;

fun cross_abs_aux f l x =
  let
    val (xa, e) = x;
  in
    (if equal_nata xa zero_nata then Term_term (l, e)
      else (case e of Consta (abr_string, typ) => Term_term (l, Consta (abr_string, typ)) | Free (abr_string, typ) => Term_term (l, Free (abr_string, typ)) | Var (prod, typ) => Term_term (l, Var (prod, typ))
             | Bound natural => Term_term (l, Bound natural) | Absa (s, _, t) => f s (cross_abs_aux f (s :: l) (minus_nat xa one_nat, t)) | Appa (term1, term2) => Term_term (l, Appa (term1, term2))))
  end;

fun cross_abs f n l = cross_abs_aux f [] (n, l);

fun ty_arrow x = (fn a => Typ_apply_bin (SS_base (ST "\092<Rightarrow>"), x, a));

fun ty_arrowb x = ty_arrow x (Typ_base (SS_base (ST "_")));

fun ctxt_expr (Ocl_ctxt_pre_post_ext (ctxt_fun_name, ctxt_fun_ty, ctxt_expr, more)) = ctxt_expr;

fun ctxt_clause (Ocl_ctxt_ext (ctxt_param, ctxt_ty, ctxt_clause, more)) = ctxt_clause;

fun fold_pre_post f ctxt =
  fold (fn a => (case a of Ctxt_pp ctxta => f (rev (fold (fn aa => (case aa of T_pp (pref, OclProp_ctxt (n, e)) => (fn ab => (pref, (n, e)) :: ab) | T_invariant _ => id)) (ctxt_expr ctxta) [])) ctxta | Ctxt_inv _ => id))
    (ctxt_clause ctxt);

fun ty_paren x = Typ_apply_paren (SS_base (ST "("), SS_base (ST ")"), x);

val dot_oclastype : abr_string = SS_base (ST ".oclAsType");

fun mk_dot_par_gen dot l_s = flattena [dot, SS_base (ST "("), (case l_s of [] => SS_base (ST "") | x :: xs => flattena [x, flattena (map (flattenb (SS_base (ST ", "))) xs)]), SS_base (ST ")")];

fun mk_dot_par dot s = mk_dot_par_gen dot [s];

fun dot_astype x = mk_dot_par dot_oclastype x;

fun get_class_hierarchy_strict_aux dataty l_res = fold (fn OclClass (name, l_attr, datatya) => fn l_resa => get_class_hierarchy_strict_aux datatya (OclClass (name, l_attr, datatya) :: l_resa)) dataty l_res;

fun get_class_hierarchy_strict d = get_class_hierarchy_strict_aux d [];

fun get_class_hierarchy_aux l_res (OclClass (name, l_attr, dataty)) = let
                                                                        val l_resa = OclClass (name, l_attr, dataty) :: l_res;
                                                                      in
                                                                        (case dataty of [] => rev l_resa | a :: lista => fold (fn x => fn acc => get_class_hierarchy_aux acc x) (a :: lista) l_resa)
                                                                      end;

fun get_class_hierarchya x = get_class_hierarchy_aux [] x;

fun ascii_of_literal x = (hd o (List.map (fn c => let val k = Char.ord c in if k < 128 then IntInf.fromInt k else raise Fail "Non-ASCII character in literal" end)  o String.explode)) x;

fun is_letter x = let
                    val int_A = ascii_of_literal "A";
                    val int_Z = ascii_of_literal "Z";
                    val int_a = ascii_of_literal "a";
                    val int_z = ascii_of_literal "z";
                  in
                    (fn n => int_A <= n andalso n <= int_Z orelse int_a <= n andalso n <= int_z)
                  end
                    x;

fun is_digit x = let
                   val int_0 = ascii_of_literal "0";
                   val int_9 = ascii_of_literal "9";
                 in
                   (fn n => int_0 <= n andalso n <= int_9)
                 end
                   x;

fun isub x = replace_integersa let
                                 val is_und = member equal_integer ((List.map (fn c => let val k = Char.ord c in if k < 128 then IntInf.fromInt k else raise Fail "Non-ASCII character in literal" end)  o String.explode) "_");
                               in
                                 (fn c => (if is_letter c orelse (is_digit c orelse is_und c) then flattenb (SS_base (ST "\092<^sub>")) (SS_base (STa [c])) else add_0 c))
                               end
               x;

fun fold_class_gen_aux l_inh f accu (OclClass (name, l_attr, dataty)) =
  let
    val accua = f (fn s => flattenb s (isub name)) name l_attr (Tinh l_inh) (Tsub (get_class_hierarchy_strict dataty)) dataty accu;
  in
    (case dataty of [] => accua
      | _ :: _ => fst (fold (fn node => fn (accub, (l_inh_l, l_inh_r)) =>
                              (fold_class_gen_aux (Inheritance_ext (OclClass (name, l_attr, dataty), flatten (map (map (fn l => (l, get_class_hierarchya l))) [l_inh_l, tl l_inh_r]), flatten [l_inh_l, tl l_inh_r], ()) :: l_inh) f accub
                                 node,
                                (hd l_inh_r :: l_inh_l, tl l_inh_r)))
                        dataty (accua, ([], dataty))))
  end;

fun fold_class_gen f accu expr =
  let
    val a = fold_class_gen_aux [] (fn isub_name => fn name => fn l_attr => fn l_inh => fn l_subtree => fn next_dataty => fn (l_res, accua) => let
                          val a = f isub_name name l_attr l_inh l_subtree next_dataty accua;
                          val (r, aa) = a;
                        in
                          (r :: l_res, aa)
                        end)
              ([], accu) expr;
    val (l_res, aa) = a;
  in
    (flatten l_res, aa)
  end;

fun inh (Inheritance_ext (inh, inh_sib, inh_sib_unflat, more)) = inh;

fun of_linh x = map inh x;

fun map_inh f = (fn Tinh l => Tinh (f l));

fun of_sub x = (fn Tsub l => l) x;

fun fold_class f =
  fold_class_gen
    (fn isub_name => fn name => fn l_attr => fn l_inh => fn l_subtree => fn next_dataty => fn accu =>
      let
        val a = f isub_name name l_attr (map_inh of_linh l_inh) (Tsub (map (fn OclClass (n, _, _) => n) (of_sub l_subtree))) next_dataty accu;
        val (x, aa) = a;
      in
        ([x], aa)
      end);

fun thma x = Thm_thm x;

fun equal s1 s2 = equal_lista equal_integer (to_list s1) (to_list s2);

fun thm x = i Theory_thm x;

fun print_ctxt_pre_post x =
  ((fn a => map_prod flatten id o a) o mapM (fn xa => fn env => (xa env, env)) o
    (fn ctxt => let
                  val ty_name = ty_obj_to_string (ctxt_ty ctxt);
                in
                  flatten (map (fn (l_ctxt, ctxta) =>
                                 let
                                   val (l_pre, l_post) = partition (fn a => (case a of (OclCtxtPre, _) => true | (OclCtxtPost, _) => false)) l_ctxt;
                                   val attr_n = ctxt_fun_name ctxta;
                                   val a = (fn f => fn xa => term_app f [xa]);
                                   val b = (fn s => Term_basic [s]);
                                   val var_tau = SS_base (ST "\092<tau>");
                                   val f_tau = (fn s => term_warning_parenthesis (term_binop (b var_tau) (SS_base (ST "\092<Turnstile>")) (term_warning_parenthesis s)));
                                   val term_binop0 = (fn base => fn u_and => fn aa => (case aa of [] => b base | ab :: lista => term_parenthesis (term_binopa u_and (ab :: lista))));
                                   val to_s = (fn pref => fn f_to => fn l_prea =>
                                                term_parenthesis (term_binop0 (SS_base (ST "true")) (SS_base (ST "and")) (map let
          val nb_var = size_list (make_ctxt_free_var pref ctxta);
        in
          (fn (_, expr) => cross_abs (fn _ => id) nb_var let
                                                           val T_pure (expra, _) = f_to expr;
                                                         in
                                                           expra
                                                         end)
        end
     l_prea)));
                                   val f = (fn (var_at_when_hol, var_at_when_ocl) =>
                                             let
                                               val dot_expr = (fn e => fn f_escape => term_postunary e (b (mk_dot_par_gen (flattena [SS_base (ST "."), attr_n, var_at_when_ocl]) (map (f_escape o fst) (ctxt_fun_ty_arg ctxta)))));
                                             in
                                               (fn env => let
                                                            val (l_prea, l_posta) = (to_s OclCtxtPre (print_ctxt_to_ocl_pre env) l_pre, to_s OclCtxtPost id l_post);
                                                            val var_r = var_result;
                                                            val expr = Term_rewrite (dot_expr (term_annot_ocl (b var_self) ty_name) id, SS_base (ST "\092<equiv>"),
                                                                                      term_lambda var_tau
                                                                                        (a (SS_base (ST "Eps"))
                                                                                          (term_lambda var_r
                                                                                            (term_app (SS_base (ST "HOL.Let"))
                                                                                              [term_lambda (SS_base (ST "_")) (b var_r),
                                                                                                term_lambda var_result
                                                                                                  (term_parenthesis
                                                                                                    (Term_if_then_else
                                                                                                      (term_binop0 (SS_base (ST "True")) (SS_base (ST "\092<and>"))
                                                                                                         (f_tau (a (SS_base (ST "\092<delta>")) (b var_self)) ::
                                                                                                           map (fn s => f_tau (a (SS_base (ST "\092<upsilon>")) (b (fst s)))) (ctxt_fun_ty_arg ctxta)),
                                                                                                        term_binop (f_tau l_prea) (SS_base (ST "\092<and>")) (f_tau l_posta),
                                                                                                        f_tau (Term_rewrite (b var_result, SS_base (ST "\092<triangleq>"), b (SS_base (ST "invalid")))))))]))));
                                                            val (name0, def) =
                                                              (if fold (fn (_, T_pure (t, _)) => fn xa =>
                                                                         xa orelse fold_Const (fn ba => fn s =>
                                                                                                ba orelse (case print_ctxt_to_ocl_gen_split s of NONE => false
                                                                                                            | SOME sa => let
     val f_eq = (fn aa => equal_lista equal_integer (to_list (print_ctxt_const_name attr_n aa NONE)) sa);
   in
     f_eq var_at_when_hol_post orelse f_eq var_at_when_hol_pre
   end))
                                                                                     false t)
                                                                    l_ctxt false
                                                                then (print_ctxt_pre_post_name attr_n var_at_when_hol, axiomatization (Axiomatization (print_ctxt_pre_post_name attr_n var_at_when_hol (SOME ty_name), expr)))
                                                                else (print_ctxt_const_name attr_n var_at_when_hol,
                                                                       overloading (overloadinga (print_ctxt_const_name attr_n var_at_when_hol NONE) (ty_arrowb (ty_paren (Typ_base (wrap_oclty ty_name))))
                                                                                     (print_ctxt_const_name attr_n var_at_when_hol (SOME ty_name)) expr)));
                                                            val name = name0 (SOME ty_name);
                                                          in
                                                            def :: thm (Thm [thma name]) ::
                                                                     (case let
                                                                             val namea = name0 NONE;
                                                                           in
                                                                             print_ctxt_pre_post_interp (d_output_sorry_dirty env) namea ctxta let
                           val v = b var_self;
                         in
                           term_lambdas0 (term_annot_ocl v ty_name) (a namea v)
                         end
                                                                               (OclCtxtPre, l_prea) (OclCtxtPost, l_posta)
                                                                           end
                                                                       of NONE => [] | SOME xa => [xa])
                                                          end) ::
                                                 (fn env => flatten (fst (fold_class (fn _ => fn name => fn _ => fn _ => fn _ => fn _ =>
                                                                                       (fn aa => ((if equal ty_name name then []
                                                                                                    else let
                                                                                                           val var_x = SS_base (ST "x");
                                                                                                           val f_escape = (fn s => flattenb var_x (isub s));
                                                                                                         in
                                                                                                           [overloading (overloadinga (flattena [SS_base (ST "dot"), isup attr_n, var_at_when_hol])
    (ty_arrowb (ty_paren (Typ_base (wrap_oclty name)))) (flattena [SS_base (ST "dot"), isup attr_n, var_at_when_hol, SS_base (ST "_"), name])
    (Term_rewrite (dot_expr (term_annot_ocl (b var_x) name) f_escape, SS_base (ST "\092<equiv>"), dot_expr (term_postunary (b var_x) (b (dot_astype ty_name))) f_escape)))]
                                                                                                         end),
                                                                                                   aa)))
                                                                           () let
                                                                                val SOME class_spec = d_input_class env;
                                                                              in
                                                                                class_spec
                                                                              end))) ::
                                                   raise_ml_unbound
                                                     (fn n => fn pref =>
                                                       flattena [SS_base (ST "("), natural_to_digit10 (Code_Numeral.plus_natural n Code_Numeral.one_natural), SS_base (ST ") "),
                                                                  (if equal_ocl_ctxt_prefix pref OclCtxtPre then SS_base (ST "pre") else SS_base (ST "post"))])
                                                     l_ctxt
                                             end);
                                 in
                                   f (var_at_when_hol_post, var_at_when_ocl_post)
                                 end)
                            (rev (fold_pre_post (fn l => fn c => (fn a => (map (map_prod id snd) l, c) :: a)) ctxt [])))
                end))
    x;

val floor2_PRINT_ctxt_pre_post : ('a ocl_ctxt_ext -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor2_ctxt.print_ctxt_pre_post"), print_ctxt_pre_post);

fun print_ctxt_inv_name n tit var_at_when = flattena [n, SS_base (ST "_"), tit, var_at_when];

fun fold_invariant f_inv ctxt = fold (fn a => (case a of Ctxt_pp ctxta => fold (fn aa => (case aa of T_pp (_, _) => id | T_invariant ab => f_inv ab)) (ctxt_expr ctxta) | Ctxt_inv aa => f_inv aa)) (ctxt_clause ctxt);

fun fold_invarianta inva = rev (fst (fold_invariant (fn T_inv (_, OclProp_ctxt (tit, invaa)) => fn (accu, n) => (let
                                                                                                                   val tita = (case tit of NONE => nat_to_digit10 n | SOME tita => tita);
                                                                                                                 in
                                                                                                                   (tita, invaa)
                                                                                                                 end ::
                                                                                                                   accu,
                                                                                                                  suc n))
                                      inva ([], zero_nata)));

fun print_ctxt_thm ctxt =
  (fn a => ((case flatten (map (fn (tit, _) => map (hol_definition o print_ctxt_inv_name (ty_obj_to_string (ctxt_ty ctxt)) tit) [var_at_when_hol_pre, var_at_when_hol_post]) (fold_invarianta ctxt)) of [] => []
              | aa :: lista => [thm (Thm (map thma (aa :: lista)))]),
             a));

val floor2_PRINT_ctxt_thm : ('a ocl_ctxt_ext -> 'b -> all_meta list * 'b) embedding_fun = Embedding_fun_info (SS_base (ST "Floor2_ctxt.print_ctxt_thm"), print_ctxt_thm);

fun print_ctxt_to_ocl_post env = print_ctxt_to_ocl_gen (fst (d_ocl_accessor env)) print_ctxt_is_name_at_pre var_at_when_hol_post;

fun ctxt_param (Ocl_ctxt_ext (ctxt_param, ctxt_ty, ctxt_clause, more)) = ctxt_param;

val var_OclForall_set : abr_string = SS_base (ST "UML_Set.OclForall");

fun definition x = i Theory_definition x;

fun term_lam x f = term_lambdas0 (Term_basic [x]) (f x);

fun append a b = flatten [a, b];

fun print_ctxt_inv x =
  ((fn a => map_prod flatten id o a) o mapM (fn xa => fn env => (xa env, env)) o flatten o flatten o
    (fn ctxt => let
                  val a = (fn f => fn xa => term_app f [xa]);
                  val b = (fn s => Term_basic [s]);
                  val f_tau = (fn s => term_lam (SS_base (ST "\092<tau>")) (fn var_tau => term_warning_parenthesis (term_binop (b var_tau) (SS_base (ST "\092<Turnstile>")) s)));
                  val nb_var = size_list (ctxt_param ctxt);
                  val ctxt_ty_n = ty_obj_to_string (ctxt_ty ctxt);
                  val l = fold_invarianta ctxt;
                in
                  map (fn (tit, term) =>
                        append (map (fn (allinst_at_when, (var_at_when, e)) =>
                                      [(fn env => [definition (Definitiona (Term_rewrite
                                                                             (b (print_ctxt_inv_name ctxt_ty_n tit var_at_when), SS_base (ST "="),
                                                                               f_tau (cross_abs (fn s => fn xa => term_app var_OclForall_set [a allinst_at_when (b ctxt_ty_n), term_lambda s xa]) (suc nb_var)
                                                                                       let
                                                                                         val T_pure (ea, _) = e env;
                                                                                       in
                                                                                         ea
                                                                                       end))))])])
                                 [(SS_base (ST "OclAllInstances_at_pre"), (var_at_when_hol_pre, (fn env => print_ctxt_to_ocl_pre env term))),
                                   (SS_base (ST "OclAllInstances_at_post"), (var_at_when_hol_post, (fn env => print_ctxt_to_ocl_post env term)))])
                          [raise_ml_unbound (fn _ => fn pref => flattena [SS_base (ST "inv "), pref]) l])
                    l
                end))
    x;

val floor2_PRINT_ctxt_inv : ('a ocl_ctxt_ext -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor2_ctxt.print_ctxt_inv"), print_ctxt_inv);

fun to_String_b_a_s_e x = (fn a => (case a of SS_base s => s | String_concatWith (abr_string, lista) => STa (to_list (String_concatWith (abr_string, lista))))) x;

fun d_ocl_accessor_update d_ocl_accessora
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = Compiler_env_config_ext
      (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap,
        d_ocl_accessora d_ocl_accessor, d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more);

fun d_ocl_HO_type_update d_ocl_HO_typea
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = Compiler_env_config_ext
      (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
        d_ocl_HO_typea d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more);

val var_Sequence_base : abr_string = SS_base (ST "Sequence\092<^sub>b\092<^sub>a\092<^sub>s\092<^sub>e");

val var_Pair_base : abr_string = SS_base (ST "Pair\092<^sub>b\092<^sub>a\092<^sub>s\092<^sub>e");

val datatype_name : abr_string = SS_base (ST "ty");

val var_Set_base : abr_string = SS_base (ST "Set\092<^sub>b\092<^sub>a\092<^sub>s\092<^sub>e");

fun tyCollect (Ocl_multiplicity_ext (tyMult, tyRole, tyCollect, more)) = tyCollect;

fun is_sequence x =
  (list_ex (fn a => (case a of Set => false | Sequence => true | Ordered0 => false | Subsets0 => false | Union0 => false | Redefines0 => false | Derived0 => false | Qualifier0 => false | Nonunique0 => false)) o tyCollect) x;

fun str_of_ty e =
  (case e of OclTy_base_void => SS_base (ST "Void") | OclTy_base_boolean => SS_base (ST "Boolean") | OclTy_base_integer => SS_base (ST "Integer") | OclTy_base_unlimitednatural => SS_base (ST "UnlimitedNatural")
    | OclTy_base_real => SS_base (ST "Real") | OclTy_base_string => SS_base (ST "String") | OclTy_object (OclTyObj (OclTyCore_pre s, _)) => s
    | OclTy_collection (t, ocl_ty) => (if is_sequence t then flattena [SS_base (ST "Sequence("), str_of_ty ocl_ty, SS_base (ST ")")] else flattena [SS_base (ST "Set("), str_of_ty ocl_ty, SS_base (ST ")")])
    | OclTy_pair (ocl_ty1, ocl_ty2) => flattena [SS_base (ST "Pair("), str_of_ty ocl_ty1, SS_base (ST ","), str_of_ty ocl_ty2, SS_base (ST ")")] | OclTy_binding a => let
                                                  val (_, aa) = a;
                                                in
                                                  str_of_ty aa
                                                end
    | OclTy_class_syn s => s | OclTy_enum s => s | OclTy_raw s => flattena [SS_base (ST "\092<acute>"), s, SS_base (ST "\092<acute>")]);

fun print_infra_type_synonym_class_rec_aux0 e =
  let
    val optiona = (fn x => Typ_apply (Typ_base (SS_base (ST "option")), [x]));
  in
    (case e of OclTy_base_void => (str_of_ty OclTy_base_void, Typ_base (flattenb (str_of_ty OclTy_base_void) (isub (SS_base (ST "base")))))
      | OclTy_base_boolean => (str_of_ty OclTy_base_boolean, Typ_base (flattenb (str_of_ty OclTy_base_boolean) (isub (SS_base (ST "base")))))
      | OclTy_base_integer => (str_of_ty OclTy_base_integer, Typ_base (flattenb (str_of_ty OclTy_base_integer) (isub (SS_base (ST "base")))))
      | OclTy_base_unlimitednatural => (str_of_ty OclTy_base_unlimitednatural, Typ_base (flattenb (str_of_ty OclTy_base_unlimitednatural) (isub (SS_base (ST "base")))))
      | OclTy_base_real => (str_of_ty OclTy_base_real, Typ_base (flattenb (str_of_ty OclTy_base_real) (isub (SS_base (ST "base")))))
      | OclTy_base_string => (str_of_ty OclTy_base_string, Typ_base (flattenb (str_of_ty OclTy_base_string) (isub (SS_base (ST "base")))))
      | OclTy_object (OclTyObj (OclTyCore_pre s, _)) => (s, optiona (optiona (Typ_base (flattenb datatype_name (isub s)))))
      | OclTy_object (OclTyObj (OclTyCore ocl_ty_class_ext, x)) =>
        (str_of_ty (OclTy_object (OclTyObj (OclTyCore ocl_ty_class_ext, x))), Typ_base (flattenb (str_of_ty (OclTy_object (OclTyObj (OclTyCore ocl_ty_class_ext, x)))) (isub (SS_base (ST "base")))))
      | OclTy_collection (c, t) =>
        let
          val (name, ty) = print_infra_type_synonym_class_rec_aux0 t;
        in
          (flattenb (if is_sequence c then SS_base (ST "Sequence") else SS_base (ST "Set")) (flattenb (SS_base (ST "_")) name), Typ_apply (Typ_base (if is_sequence c then var_Sequence_base else var_Set_base), [ty]))
        end
      | OclTy_pair (t1, t2) => let
                                 val (name1, ty1) = print_infra_type_synonym_class_rec_aux0 t1;
                                 val (name2, ty2) = print_infra_type_synonym_class_rec_aux0 t2;
                               in
                                 (flattenb (SS_base (ST "Pair")) (flattenb (SS_base (ST "_")) (flattenb name1 (flattenb (SS_base (ST "_")) name2))), Typ_apply (Typ_base var_Pair_base, [ty1, ty2]))
                               end
      | OclTy_binding prod => (str_of_ty (OclTy_binding prod), Typ_base (flattenb (str_of_ty (OclTy_binding prod)) (isub (SS_base (ST "base")))))
      | OclTy_arrow (ocl_ty1, ocl_ty2) => (str_of_ty (OclTy_arrow (ocl_ty1, ocl_ty2)), Typ_base (flattenb (str_of_ty (OclTy_arrow (ocl_ty1, ocl_ty2))) (isub (SS_base (ST "base")))))
      | OclTy_class_syn abr_string => (str_of_ty (OclTy_class_syn abr_string), Typ_base (flattenb (str_of_ty (OclTy_class_syn abr_string)) (isub (SS_base (ST "base")))))
      | OclTy_enum abr_string => (str_of_ty (OclTy_enum abr_string), Typ_base (flattenb (str_of_ty (OclTy_enum abr_string)) (isub (SS_base (ST "base")))))
      | OclTy_raw abr_string => (str_of_ty (OclTy_raw abr_string), Typ_base (flattenb (str_of_ty (OclTy_raw abr_string)) (isub (SS_base (ST "base"))))))
  end;

fun print_infra_type_synonym_class_rec_aux t = let
                                                 val (tit, body) = print_infra_type_synonym_class_rec_aux0 t;
                                               in
                                                 (tit, Typ_apply (Typ_base (SS_base (ST "val")), [Typ_base (SS_base (ST "\092<AA>")), body]))
                                               end;

fun d_ocl_HO_type
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = d_ocl_HO_type;

fun d_input_meta
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = d_input_meta;

fun update_D_ocl_accessor_post f = (fn (l_pre, l_post) => (l_pre, f l_post));

fun print_infra_type_synonym_class_sequence_name name = flattenb (SS_base (ST "Sequence_")) name;

fun print_infra_type_synonym_class_set_name name = flattenb (SS_base (ST "Set_")) name;

fun tyObjN_role_multip (Ocl_ty_class_node_ext (tyObjN_ass_switch, tyObjN_role_multip, tyObjN_role_ty, more)) = tyObjN_role_multip;

fun tyObjN_role_ty (Ocl_ty_class_node_ext (tyObjN_ass_switch, tyObjN_role_multip, tyObjN_role_ty, more)) = tyObjN_role_ty;

fun tyObj_to (Ocl_ty_class_ext (tyObj_name, tyObj_ass_id, tyObj_ass_arity, tyObj_from, tyObj_to, more)) = tyObj_to;

fun tyObj_name (Ocl_ty_class_ext (tyObj_name, tyObj_ass_id, tyObj_ass_arity, tyObj_from, tyObj_to, more)) = tyObj_name;

fun pref_ty_enum s = flattenb (SS_base (ST "ty_enum")) (isub s);

val var_ty_prod : abr_string = SS_base (ST "prod");

val var_ty_list : abr_string = SS_base (ST "list");

fun pref_ty_syn s = flattenb (SS_base (ST "ty_syn")) (isub s);

val const_oid : abr_string = SS_base (ST "oid");

fun str_hol_of_ty_all f b e =
  (case e of OclTy_base_void => b (SS_base (ST "unit")) | OclTy_base_boolean => b (SS_base (ST "bool")) | OclTy_base_integer => b (SS_base (ST "int")) | OclTy_base_unlimitednatural => b (SS_base (ST "nat"))
    | OclTy_base_real => b (SS_base (ST "real")) | OclTy_base_string => b (SS_base (ST "string")) | OclTy_object (OclTyObj (OclTyCore_pre _, _)) => b const_oid
    | OclTy_object (OclTyObj (OclTyCore ty_obj, _)) => f (b var_ty_list) [b (tyObj_name ty_obj)] | OclTy_collection (_, ty) => f (b var_ty_list) [str_hol_of_ty_all f b ty]
    | OclTy_pair (ty1, ty2) => f (b var_ty_prod) [str_hol_of_ty_all f b ty1, str_hol_of_ty_all f b ty2] | OclTy_binding a => let
         val (_, aa) = a;
       in
         str_hol_of_ty_all f b aa
       end
    | OclTy_class_syn s => b (pref_ty_syn s) | OclTy_enum s => b (pref_ty_enum s) | OclTy_raw a => b a);

fun less_eq_natural m n = Code_Numeral.integer_of_natural m <= Code_Numeral.integer_of_natural n;

fun tyMult (Ocl_multiplicity_ext (tyMult, tyRole, tyCollect, more)) = tyMult;

fun single_multip x =
  (list_all (fn a => (case a of (Mult_nat natural, NONE) => less_eq_natural natural Code_Numeral.one_natural | (Mult_nat _, SOME (Mult_nat n)) => less_eq_natural n Code_Numeral.one_natural | (Mult_nat _, SOME Mult_star) => false
                       | (Mult_nat _, SOME Mult_infinity) => false | (Mult_star, NONE) => false | (Mult_star, SOME (Mult_nat n)) => less_eq_natural n Code_Numeral.one_natural | (Mult_star, SOME Mult_star) => false
                       | (Mult_star, SOME Mult_infinity) => false | (Mult_infinity, NONE) => false | (Mult_infinity, SOME (Mult_nat n)) => less_eq_natural n Code_Numeral.one_natural | (Mult_infinity, SOME Mult_star) => false
                       | (Mult_infinity, SOME Mult_infinity) => false)) o
    tyMult)
    x;

fun raw x = Typ_base x;

fun print_access_dot_consts_ty attr_ty =
  let
    val ty_base = (fn attr_tya => Typ_apply (Typ_base (SS_base (ST "val")), [Typ_base (SS_base (ST "\092<AA>")), let
                                                                                                                   val optiona = (fn x => Typ_apply (Typ_base (SS_base (ST "option")), [x]));
                                                                                                                 in
                                                                                                                   optiona (optiona (Typ_base attr_tya))
                                                                                                                 end]));
  in
    (case attr_ty of OclTy_base_void => raw (str_of_ty attr_ty) | OclTy_base_boolean => raw (str_of_ty attr_ty) | OclTy_base_integer => raw (str_of_ty attr_ty)
      | OclTy_base_unlimitednatural => str_hol_of_ty_all (fn a => fn b => Typ_apply (a, b)) ty_base attr_ty | OclTy_base_real => raw (str_of_ty attr_ty) | OclTy_base_string => raw (str_of_ty attr_ty)
      | OclTy_object (OclTyObj (OclTyCore_pre s, _)) => raw (wrap_oclty s)
      | OclTy_object (OclTyObj (OclTyCore ty_obj, _)) =>
        let
          val ty_obja = tyObj_to ty_obj;
          val name = tyObjN_role_ty ty_obja;
          val obj_mult = tyObjN_role_multip ty_obja;
        in
          Typ_base (if single_multip obj_mult then wrap_oclty name else (if is_sequence obj_mult then print_infra_type_synonym_class_sequence_name name else print_infra_type_synonym_class_set_name name))
        end
      | OclTy_collection (_, _) => raw (fst (print_infra_type_synonym_class_rec_aux attr_ty)) | OclTy_pair (_, _) => raw (fst (print_infra_type_synonym_class_rec_aux attr_ty)) | OclTy_binding _ => raw (str_of_ty attr_ty)
      | OclTy_arrow (_, _) => raw (str_of_ty attr_ty) | OclTy_class_syn _ => raw (str_of_ty attr_ty) | OclTy_enum _ => raw (str_of_ty attr_ty) | OclTy_raw a => ty_base a)
  end;

fun update_D_ocl_accessor_pre f = (fn (l_pre, a) => (f l_pre, a));

fun natural_of_nat n = Code_Numeral.natural_of_integer (integer_of_nat n);

val var_at_when_ocl_pre : abr_string = SS_base (ST "@pre");

fun type_synonyma n = (fn a => Type_synonym ((n, []), a));

val consts_value : abr_string = SS_base (ST "(_)");

fun consts_raw0 s l e o_arg =
  Consts (s, l, flattenb (replace_integersa (fn n => (if n = (95 : IntInf.int) then SS_base (ST "'_") else SS_base (STa [n]))) e)
                  (case o_arg of NONE => SS_base (ST "")
                    | SOME arg =>
                      let
                        val ap = (fn sa => flattenb (SS_base (ST "'(")) (flattenb sa (SS_base (ST "')"))));
                      in
                        ap (if equal_naturala arg Code_Numeral.zero_natural then SS_base (ST "")
                             else flattenb consts_value (flattena (map (fn _ => flattenb (SS_base (ST ",")) consts_value) (uptob (Code_Numeral.natural_of_integer (2 : IntInf.int)) arg))))
                      end));

fun is_higher_order x =
  (fn a => (case a of OclTy_base_void => false | OclTy_base_boolean => false | OclTy_base_integer => false | OclTy_base_unlimitednatural => false | OclTy_base_real => false | OclTy_base_string => false | OclTy_object _ => false
             | OclTy_collection (_, _) => true | OclTy_pair (_, _) => true | OclTy_binding _ => false | OclTy_arrow (_, _) => false | OclTy_class_syn _ => false | OclTy_enum _ => false | OclTy_raw _ => false))
    x;

fun ctxt_fun_ty_out ctxt =
  (case ctxt_fun_ty ctxt of OclTy_base_void => NONE | OclTy_base_boolean => NONE | OclTy_base_integer => NONE | OclTy_base_unlimitednatural => NONE | OclTy_base_real => NONE | OclTy_base_string => NONE | OclTy_object _ => NONE
    | OclTy_collection (_, _) => NONE | OclTy_pair (_, _) => NONE | OclTy_binding _ => NONE | OclTy_arrow (_, a) => SOME a | OclTy_class_syn _ => NONE | OclTy_enum _ => NONE | OclTy_raw _ => NONE);

fun type_synonym x = i Theory_type_synonym x;

fun ty_arrowa l = let
                    val x :: xs = rev l;
                  in
                    fold ty_arrow xs x
                  end;

fun map_enum_syn l_enum l_syn =
  (fn a => (case a of OclTy_base_void => OclTy_base_void | OclTy_base_boolean => OclTy_base_boolean | OclTy_base_integer => OclTy_base_integer | OclTy_base_unlimitednatural => OclTy_base_unlimitednatural
             | OclTy_base_real => OclTy_base_real | OclTy_base_string => OclTy_base_string
             | OclTy_object aa =>
               (case aa of OclTyObj (OclTyCore_pre s, []) =>
                          (if list_ex (fn syn => equal s let
                                                           val OclClassSynonym (n, _) = syn;
                                                         in
                                                           n
                                                         end)
                                l_syn
                            then OclTy_class_syn s else (if list_ex (fn enum => equal s let
                                                                                          val OclEnum (n, _) = enum;
                                                                                        in
                                                                                          n
                                                                                        end)
                                                              l_enum
                                                          then OclTy_enum s else OclTy_object (OclTyObj (OclTyCore_pre s, []))))
                 | OclTyObj (OclTyCore_pre s, ab :: lista) => OclTy_object (OclTyObj (OclTyCore_pre s, ab :: lista)) | OclTyObj (OclTyCore ocl_ty_class_ext, lista) => OclTy_object (OclTyObj (OclTyCore ocl_ty_class_ext, lista)))
             | OclTy_collection (aa, b) => OclTy_collection (aa, b) | OclTy_pair (aa, b) => OclTy_pair (aa, b) | OclTy_binding aa => OclTy_binding aa | OclTy_arrow (aa, b) => OclTy_arrow (aa, b)
             | OclTy_class_syn aa => OclTy_class_syn aa | OclTy_enum aa => OclTy_enum aa | OclTy_raw aa => OclTy_raw aa));

fun consts x = i Theory_consts x;

fun membera l x = member (equal_list equal_integer) (map to_lista l) (to_list x);

fun print_ctxt_const ctxt env =
  let
    val ty_par = (fn a => Typ_apply_paren (SS_base (ST "("), SS_base (ST ")"), a));
    val l_enum = map_filter (fn a => (case a of META_enum aa => SOME aa | META_class_raw (_, _) => NONE | META_association _ => NONE | META_ass_class (_, _) => NONE | META_ctxt (_, _) => NONE | META_haskell _ => NONE
                                       | META_class_synonym _ => NONE | META_instance _ => NONE | META_def_base_l _ => NONE | META_def_state (_, _) => NONE | META_def_transition (_, _) => NONE | META_class_tree _ => NONE
                                       | META_flush_all _ => NONE | META_generic _ => NONE))
                   (d_input_meta env);
    val l_syn = map_filter (fn a => (case a of META_enum _ => NONE | META_class_raw (_, _) => NONE | META_association _ => NONE | META_ass_class (_, _) => NONE | META_ctxt (_, _) => NONE | META_haskell _ => NONE
                                      | META_class_synonym aa => SOME aa | META_instance _ => NONE | META_def_base_l _ => NONE | META_def_state (_, _) => NONE | META_def_transition (_, _) => NONE | META_class_tree _ => NONE
                                      | META_flush_all _ => NONE | META_generic _ => NONE))
                  (d_input_meta env);
  in
    map_prod (map_prod id (rev o map type_synonym)) (rev o map consts)
      (fold (fn a => (case a of Ctxt_pp ctxta =>
                               let
                                 val attr_n = ctxt_fun_name ctxta;
                               in
                                 fold (fn (var_at_when_hol, (var_at_when_ocl, f_update_ocl)) => fn (aa, b) =>
                                        let
                                          val (enva, l_isab_ty) = aa;
                                        in
                                          (fn l_isab_const =>
                                            let
                                              val name = print_ctxt_const_name attr_n var_at_when_hol NONE;
                                              val (l_name, l) =
                                                fold (fn ty => fn (l_name, (l, l_isab_tya)) =>
                                                       let
                                                         val tya = map_enum_syn l_enum l_syn ty;
                                                         val (n, isab_ty) = print_infra_type_synonym_class_rec_aux tya;
                                                       in
                                                         (ty_par (print_access_dot_consts_ty tya) :: l_name,
                                                           (if is_higher_order tya andalso not (membera l n) then (to_String_b_a_s_e n :: l, type_synonyma n isab_ty :: l_isab_tya) else (l, l_isab_tya)))
                                                       end)
                                                  (flatten [map snd (ctxt_fun_ty_arg ctxta), [(case ctxt_fun_ty_out ctxta of NONE => OclTy_base_void | SOME s => s)]]) ([], (d_ocl_HO_type enva, l_isab_ty));
                                            in
                                              (map_prod let
                                                          val envb = d_ocl_accessor_update (fn _ => f_update_ocl (fn ab => to_String_b_a_s_e name :: ab) (d_ocl_accessor enva)) enva;
                                                        in
                                                          (fn d_ocl_HO_typea => d_ocl_HO_type_update (fn _ => d_ocl_HO_typea) envb)
                                                        end
                                                 id l,
                                                consts_raw0 name (ty_arrowa (Typ_apply (Typ_base (SS_base (ST "val")), [Typ_base (SS_base (ST "\092<AA>")), Typ_base (SS_base (ST "'\092<alpha>"))]) :: rev l_name))
                                                  (mk_dot attr_n var_at_when_ocl) (SOME (natural_of_nat (size_list (ctxt_fun_ty_arg ctxta)))) ::
                                                  l_isab_const)
                                            end)
                                        end
                                          b)
                                   [(var_at_when_hol_post, (var_at_when_ocl_post, update_D_ocl_accessor_post)), (var_at_when_hol_pre, (var_at_when_ocl_pre, update_D_ocl_accessor_pre))]
                               end
                       | Ctxt_inv _ => id))
        (ctxt_clause ctxt) ((env, []), []))
  end;

fun d_output_auto_bootstrap_update d_output_auto_bootstrapa
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = Compiler_env_config_ext
      (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force,
        d_output_auto_bootstrapa d_output_auto_bootstrap, d_ocl_accessor, d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more);

fun d_output_disable_thy_update d_output_disable_thya
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = Compiler_env_config_ext
      (d_output_disable_thya d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap,
        d_ocl_accessor, d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more);

fun d_output_header_thy_update d_output_header_thya
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = Compiler_env_config_ext
      (d_output_disable_thy, d_output_header_thya d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap,
        d_ocl_accessor, d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more);

fun d_output_auto_bootstrap
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = d_output_auto_bootstrap;

fun d_input_meta_update d_input_metaa
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = Compiler_env_config_ext
      (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_metaa d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap,
        d_ocl_accessor, d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more);

fun d_output_disable_thy
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = d_output_disable_thy;

fun d_ocl_oid_start
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = d_ocl_oid_start;

fun co15 f g x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15 = f (g x1 x2 x3 x4 x5 x6 x7 x8 x9 x10 x11 x12 x13 x14 x15);

fun makea x =
  co15 (fn f => f ()) (fn a => fn b => fn c => fn d => fn e => fn f => fn g => fn h => fn i => fn j => fn k => fn l => fn m => fn n => fn oa => fn p => Compiler_env_config_ext (a, b, c, d, e, f, g, h, i, j, k, l, m, n, oa, p)) x;

fun compiler_env_config_empty output_disable_thy output_header_thy oid_start design_analysis sorry_dirty =
  makea output_disable_thy output_header_thy oid_start (Code_Numeral.zero_natural, Code_Numeral.zero_natural) design_analysis NONE [] [] [] false false ([], []) [] [] sorry_dirty;

fun oidReinitAll x = (fn Oids (n1, _, _) => Oids (n1, n1, n1)) x;

fun compiler_env_config_reset_no_env env =
  d_input_meta_update (fn _ => d_input_meta env) (compiler_env_config_empty (d_output_disable_thy env) (d_output_header_thy env) (oidReinitAll (d_ocl_oid_start env)) (d_ocl_semantics env) (d_output_sorry_dirty env));

fun ignore_meta_header x =
  (fn a => (case a of META_enum _ => false | META_class_raw (_, _) => false | META_association _ => false | META_ass_class (_, _) => false | META_ctxt (Floor1, _) => true | META_ctxt (Floor2, _) => false | META_ctxt (Floor3, _) => false
             | META_haskell _ => false | META_class_synonym _ => false | META_instance _ => false | META_def_base_l _ => false | META_def_state (Floor1, _) => true | META_def_state (Floor2, _) => false
             | META_def_state (Floor3, _) => false | META_def_transition (Floor1, _) => true | META_def_transition (Floor2, _) => false | META_def_transition (Floor3, _) => false | META_class_tree _ => false | META_flush_all _ => false
             | META_generic _ => false))
    x;

fun prev_was_stop x = (fn a => (case a of [] => true | xa :: _ => ignore_meta_header xa)) x;

fun collect_meta_embed accu e = (case e of (true, _) => rev accu | (false, []) => rev accu | (false, x :: l_meta) => collect_meta_embed (x :: accu) (prev_was_stop l_meta, l_meta));

fun bootstrap_floor l env =
  let
    val l_setup = (fn f => META_boot_setup_env (Boot_setup_env (d_output_header_thy_update (fn _ => NONE) (d_output_disable_thy_update (fn _ => true) (f env)))) :: l);
  in
    ((if d_output_auto_bootstrap env then (if prev_was_stop (d_input_meta env) then l else l_setup (fn enva => d_input_meta_update (fn _ => collect_meta_embed [] (false, d_input_meta enva)) (compiler_env_config_reset_no_env enva)))
       else META_boot_generation_syntax (Boot_generation_syntax (d_ocl_semantics env)) :: l_setup id),
      d_output_auto_bootstrap_update (fn _ => true) env)
  end;

fun ctxt_expr_update ctxt_expra (Ocl_ctxt_pre_post_ext (ctxt_fun_name, ctxt_fun_ty, ctxt_expr, more)) = Ocl_ctxt_pre_post_ext (ctxt_fun_name, ctxt_fun_ty, ctxt_expra ctxt_expr, more);

fun ctxt_clause_update ctxt_clausea (Ocl_ctxt_ext (ctxt_param, ctxt_ty, ctxt_clause, more)) = Ocl_ctxt_ext (ctxt_param, ctxt_ty, ctxt_clausea ctxt_clause, more);

fun map_invariant f_inv =
  ctxt_clause_update
    (map (fn a => (case a of Ctxt_pp ctxt => Ctxt_pp (ctxt_expr_update (map (fn aa => (case aa of T_pp (ab, b) => T_pp (ab, b) | T_invariant ctxta => T_invariant (f_inv ctxta)))) ctxt) | Ctxt_inv ctxt => Ctxt_inv (f_inv ctxt))));

fun map_pre_post f =
  ctxt_clause_update
    (map (fn a => (case a of Ctxt_pp ctxt => Ctxt_pp (ctxt_expr_update (map (fn aa => (case aa of T_pp (pref, OclProp_ctxt (n, e)) => T_pp (pref, OclProp_ctxt (n, f pref ctxt e)) | T_invariant ab => T_invariant ab))) ctxt)
                    | Ctxt_inv aa => Ctxt_inv aa)));

fun t_lambdas x = fold (fn a => fn b => T_lambda (a, b)) x;

fun print_ctxt x =
  (fn ctxt => fn e =>
    let
      val a = let
                val a = print_ctxt_const ctxt e;
                val (aa, b) = a;
              in
                let
                  val (env, l_isab_ty) = aa;
                in
                  (fn l_isab =>
                    (flatten [l_isab_ty, l_isab,
                               [META_all_meta_embedding
                                  (META_ctxt (Floor2, map_invariant (fn T_inv (ba, OclProp_ctxt (n, p)) => T_inv (ba, OclProp_ctxt (n, t_lambdas (append (ctxt_param ctxt) [var_self]) p)))
                                                        (map_pre_post (fn pref => fn ctxta => t_lambdas (make_ctxt_free_var pref ctxta)) ctxt)))]],
                      env))
                end
                  b
              end;
      val (aa, b) = a;
    in
      bootstrap_floor aa b
    end)
    x;

val floor1_PRINT_ctxt : (unit ocl_ctxt_ext -> unit compiler_env_config_ext -> all_meta list * unit compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_ctxt.print_ctxt"), print_ctxt);

fun thy_ctxt x =
  (fn a => (case a of Floor1 => Embed_theories [sectiona (SS_base (ST "Context (Floor 1)")), floor1_PRINT_ctxt]
             | Floor2 => Embed_theories [sectiona (SS_base (ST "Context (Floor 2)")), floor2_PRINT_ctxt_pre_post, floor2_PRINT_ctxt_inv, floor2_PRINT_ctxt_thm]))
    x;

fun type_synonymb n l f = Type_synonym ((n, l), f l);

fun pref_generic_enum name_ty = flattenb name_ty (isub (SS_base (ST "generic")));

fun pref_constr_enum s = flattenb (SS_base (ST "constr")) (isub s);

fun term_applys e l = term_applys0 (term_parenthesis e) l;

fun term_some x = Term_paren (SS_base (ST "\092<lfloor>"), SS_base (ST "\092<rfloor>"), x);

fun datatypeb n l = Datatypea (Datatype_new, [((n, []), l)]);

fun datatypea x = i Theory_datatype x;

fun print_enum x =
  (fn OclEnum (name_ty, l) =>
    (fn a => (let
                val aa = (fn f => fn xa => term_app f [xa]);
                val b = (fn s => Term_basic [s]);
                val optiona = (fn ab => Typ_apply_paren (SS_base (ST "\092<langle>"), SS_base (ST "\092<rangle>\092<^sub>\092<bottom>"), ab));
                val name_ty_base = flattenb name_ty (isub (SS_base (ST "base")));
                val name_ty_basea = pref_generic_enum name_ty;
                val uu = SS_base (ST "'\092<AA>");
              in
                flatten [[datatypea (datatypeb (pref_ty_enum name_ty) (map (fn constr => (pref_constr_enum constr, [])) l)), type_synonym (type_synonyma name_ty_base (optiona (optiona (Typ_base (pref_ty_enum name_ty))))),
                           type_synonym (type_synonymb name_ty_basea [uu] (fn [u] => Typ_apply (Typ_base (SS_base (ST "val")), [Typ_base u, Typ_base name_ty_base]))),
                           overloading (overloadinga (SS_base (ST "StrictRefEq")) (ty_arrowb (Typ_apply (Typ_base name_ty_basea, [Typ_base uu]))) (flattenb (SS_base (ST "StrictRefEq")) (isub name_ty))
                                         let
                                           val var_x = SS_base (ST "x");
                                           val var_y = SS_base (ST "y");
                                         in
                                           Term_rewrite (Term_rewrite (Term_annot (b var_x, Typ_apply (Typ_base name_ty_basea, [Typ_base uu])), SS_base (ST "\092<doteq>"), b var_y), SS_base (ST "\092<equiv>"),
                                                          term_lam (SS_base (ST "\092<tau>"))
                                                            (fn var_tau =>
                                                              Term_if_then_else
                                                                (let
                                                                   val f = (fn v => Term_rewrite (term_applys (aa (SS_base (ST "\092<upsilon>")) (b v)) [b var_tau], SS_base (ST "="), aa (SS_base (ST "true")) (b var_tau)));
                                                                 in
                                                                   term_binop (f var_x) (SS_base (ST "\092<and>")) (f var_y)
                                                                 end,
                                                                  term_applys (Term_rewrite (b var_x, SS_base (ST "\092<triangleq>"), b var_y)) [b var_tau], aa (SS_base (ST "invalid")) (b var_tau))))
                                         end)],
                          map (fn constr =>
                                definition (Definitiona (Term_rewrite (b constr, SS_base (ST "="), term_lam (SS_base (ST "_")) (fn _ => term_some (term_some (term_annot (b (pref_constr_enum constr)) (pref_ty_enum name_ty))))))))
                            l]
              end,
               a)))
    x;

val pRINT_enum : (ocl_enum -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_enum.print_enum"), print_enum);

val thy_enum : (ocl_enum, unit compiler_env_config_ext) embedding = Embed_theories [sectiona (SS_base (ST "Enum")), pRINT_enum];

fun filtera f l = rev (foldl (fn la => fn x => (if f x then x :: la else la)) [] l);

fun mk_quote s = flattena [SS_base (ST "'"), s];

val wildcard : abr_string = SS_base (ST "_");

fun k x uu = x;

fun print f = f meta_of_logic (CodeConst.To.nat Code_Numeral.integer_of_natural);

fun comp_env_input_class_bind l f = fold (fn x => x f) l;

fun d_input_class_update d_input_classa
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = Compiler_env_config_ext
      (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_classa d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap,
        d_ocl_accessor, d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more);

fun comp_env_input_class_rm f_fold f env_accu = let
                                                  val a = f_fold f env_accu;
                                                  val (env, aa) = a;
                                                in
                                                  (d_input_class_update (fn _ => NONE) env, aa)
                                                end;

fun equal_generation_semantics_ocl Gen_only_analysis Gen_default = false
  | equal_generation_semantics_ocl Gen_default Gen_only_analysis = false
  | equal_generation_semantics_ocl Gen_only_design Gen_default = false
  | equal_generation_semantics_ocl Gen_default Gen_only_design = false
  | equal_generation_semantics_ocl Gen_only_design Gen_only_analysis = false
  | equal_generation_semantics_ocl Gen_only_analysis Gen_only_design = false
  | equal_generation_semantics_ocl Gen_default Gen_default = true
  | equal_generation_semantics_ocl Gen_only_analysis Gen_only_analysis = true
  | equal_generation_semantics_ocl Gen_only_design Gen_only_design = true;

fun classRaw_clause_update classRaw_clausea (Ocl_class_raw_ext (classRaw_name, classRaw_own, classRaw_clause, classRaw_abstract, more)) =
  Ocl_class_raw_ext (classRaw_name, classRaw_own, classRaw_clausea classRaw_clause, classRaw_abstract, more);

fun classRaw_clause (Ocl_class_raw_ext (classRaw_name, classRaw_own, classRaw_clause, classRaw_abstract, more)) = classRaw_clause;

fun classRaw_name (Ocl_class_raw_ext (classRaw_name, classRaw_own, classRaw_clause, classRaw_abstract, more)) = classRaw_name;

fun co4 f g x1 x2 x3 x4 = f (g x1 x2 x3 x4);

fun make x = co4 (fn f => f ()) (fn a => fn b => fn c => fn d => fn e => Ocl_class_raw_ext (a, b, c, d, e)) x;

fun nat_to_digit26_aux l n = (if less_nat n (nat_of_integer (26 : IntInf.int)) then n :: l else nat_to_digit26_aux (modulo_nat n (nat_of_integer (26 : IntInf.int)) :: l) (divide_nat n (nat_of_integer (26 : IntInf.int))));

fun mapb f = map_gen (replace_integers (fn c => SS_base (STa [f c]))) (fn x => SS_base (STa [f x]));

fun uppercase x = mapb (fn n => (if n < (97 : IntInf.int) then n else n - (32 : IntInf.int))) x;

fun nat_to_digit26 x =
  let
    val str26_of_nat = let
                         val nat_raw_of_str26 = map (integer_of_nat o plus_nat (nat_of_integer (97 : IntInf.int)));
                       in
                         (fn n => SS_base (STa (nat_raw_of_str26 (nat_to_digit26_aux [] n))))
                       end;
  in
    (fn n => let
               val na = minus_nat n one_nat;
               val s1 = str26_of_nat na;
               val xa :: xs = to_list (if less_nat na (nat_of_integer (26 : IntInf.int)) then let
                                                                                                val s2 = str26_of_nat (minus_nat (minus_nat (nat_of_integer (26 : IntInf.int)) na) one_nat);
                                                                                              in
                                                                                                flattena [s1, s1, s2, s2]
                                                                                              end
                                        else flattena [s1, s1]);
             in
               flattena [uppercase (SS_base (STa [xa])), SS_base (STa xs)]
             end)
  end
    x;

fun ident_current x = snd x;

fun ident_fresh A_ = (fn l => fn (map, ident) => (case lookupa A_ map l of NONE => (ident, (insert A_ l ident map, suc ident)) | SOME i => (i, (map, ident))));

fun ident_empty C_ = (emptya, zero C_);

fun make_tree l_pos nb_child deep = Tree (l_pos, (if equal_nata deep zero_nata then [] else make_treea l_pos nb_child nb_child (minus_nat deep one_nat) []))
and make_treea l_pos nb_child i deep l = (if equal_nata i zero_nata then l else make_treea l_pos nb_child (minus_nat i one_nat) deep (make_tree (minus_nat i one_nat :: l_pos) nb_child deep :: l));

fun fold_tree f t accu = (case t of Tree (_, []) => accu | Tree (x, aa :: lista) => fold (fold_tree f) (aa :: lista) (fold (fn ta => fn accua => let
                             val Tree (xa, _) = ta;
                           in
                             f x xa accua
                           end)
 (aa :: lista) accu));

fun mk_tree nb_child deep n_init =
  let
    val (l, map) =
      fold_tree (fn l1 => fn l2 => fn (l, map) => let
                                                    val (n1, mapa) = ident_fresh (equal_list equal_nat) l1 map;
                                                    val a = ident_fresh (equal_list equal_nat) l2 mapa;
                                                    val (n2, aa) = a;
                                                  in
                                                    (((if equal_nata n1 zero_nata then C_out_OclAny else C_out_simple (nat_to_digit26 (plus_nat n1 n_init))), nat_to_digit26 (plus_nat n2 n_init)) :: l, aa)
                                                  end)
        (make_tree [] nb_child deep) ([], ident_empty zero_nat);
  in
    (rev l, minus_nat (plus_nat n_init (ident_current map)) one_nat)
  end;

fun find_class_ass env =
  let
    val (l_tree, l_all_meta) =
      partition (fn a => (case a of META_enum _ => false | META_class_raw (_, _) => false | META_association _ => false | META_ass_class (_, _) => false | META_ctxt (_, _) => false | META_haskell _ => false
                           | META_class_synonym _ => false | META_instance _ => false | META_def_base_l _ => false | META_def_state (_, _) => false | META_def_transition (_, _) => false | META_class_tree _ => true
                           | META_flush_all _ => false | META_generic _ => false))
        (rev (d_input_meta env));
    val (l_class, l_all_metaa) =
      partition let
                  val f = (fn class => null (classRaw_clause class));
                in
                  (fn a => (case a of META_enum _ => false | META_class_raw (Floor1, class) => f class | META_class_raw (Floor2, _) => false | META_class_raw (Floor3, _) => false | META_association _ => true
                             | META_ass_class (Floor1, OclAssClass (_, aa)) => f aa | META_ass_class (Floor2, _) => false | META_ass_class (Floor3, _) => false | META_ctxt (_, _) => false | META_haskell _ => false
                             | META_class_synonym _ => true | META_instance _ => false | META_def_base_l _ => false | META_def_state (_, _) => false | META_def_transition (_, _) => false | META_class_tree _ => false
                             | META_flush_all _ => false | META_generic _ => false))
                end
        l_all_meta;
  in
    (flatten [map let
                    val mk = (fn n1 => fn n2 => META_class_raw (Floor1, make (OclTyObj (OclTyCore_pre n1, (case n2 of NONE => [] | SOME n2a => [[OclTyCore_pre n2a]]))) [] [] false));
                  in
                    (fn a => (case a of (C_out_OclAny, s) => mk s NONE | (C_out_simple s1, s) => mk s (SOME s1)))
                  end
                (concat (fst (mapM (fn META_class_tree (OclClassTree (n1, n2)) => mk_tree (nat_of_natural n1) (nat_of_natural n2)) l_tree zero_nata))),
               l_class, map_filter let
                                     val f = classRaw_clause_update (fn _ => []);
                                   in
                                     (fn a => (case a of META_enum _ => NONE | META_class_raw (Floor1, c) => SOME (META_class_raw (Floor1, f c)) | META_class_raw (Floor2, _) => NONE | META_class_raw (Floor3, _) => NONE
                                                | META_association _ => NONE | META_ass_class (Floor1, OclAssClass (ass, class)) => SOME (META_ass_class (Floor1, OclAssClass (ass, f class))) | META_ass_class (Floor2, _) => NONE
                                                | META_ass_class (Floor3, _) => NONE | META_ctxt (_, _) => NONE | META_haskell _ => NONE | META_class_synonym _ => NONE | META_instance _ => NONE | META_def_base_l _ => NONE
                                                | META_def_state (_, _) => NONE | META_def_transition (_, _) => NONE | META_class_tree _ => NONE | META_flush_all _ => NONE | META_generic _ => NONE))
                                   end
                          l_all_metaa],
      flatten (map let
                     val f = (fn class => [META_ctxt (Floor1, Ocl_ctxt_ext ([], classRaw_name class, classRaw_clause class, ()))]);
                   in
                     (fn a => (case a of META_enum ocl_enum => [META_enum ocl_enum] | META_class_raw (Floor1, class) => f class | META_class_raw (Floor2, class) => [META_class_raw (Floor2, class)]
                                | META_class_raw (Floor3, class) => [META_class_raw (Floor3, class)] | META_association ocl_association_ext => [META_association ocl_association_ext] | META_ass_class (Floor1, OclAssClass (_, aa)) => f aa
                                | META_ass_class (Floor2, ocl_ass_class) => [META_ass_class (Floor2, ocl_ass_class)] | META_ass_class (Floor3, ocl_ass_class) => [META_ass_class (Floor3, ocl_ass_class)]
                                | META_ctxt (floor, ocl_ctxt_ext) => [META_ctxt (floor, ocl_ctxt_ext)] | META_haskell isaUnit => [META_haskell isaUnit] | META_class_synonym ocl_class_synonym => [META_class_synonym ocl_class_synonym]
                                | META_instance ocl_instance => [META_instance ocl_instance] | META_def_base_l ocl_def_base_l => [META_def_base_l ocl_def_base_l]
                                | META_def_state (floor, ocl_def_state) => [META_def_state (floor, ocl_def_state)] | META_def_transition (floor, ocl_def_transition) => [META_def_transition (floor, ocl_def_transition)]
                                | META_class_tree ocl_class_tree => [META_class_tree ocl_class_tree] | META_flush_all ocl_flush_all => [META_flush_all ocl_flush_all] | META_generic ocl_generic => [META_generic ocl_generic]))
                   end
                l_all_metaa))
  end;

fun print_examp_def_st_locale_name n = flattenb (SS_base (ST "state_")) n;

fun definitiona x = Theory_definition x;

fun d_input_state
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = d_input_state;

fun assoca x l = assoc (equal_list equal_integer) (to_list x) (map (map_prod to_lista id) l);

fun get_state f = (fn OclDefPP (_, s_pre, s_post) => fn env => let
                                                                 val get_state = let
                                                                                   val l_st = d_input_state env;
                                                                                 in
                                                                                   (fn OclDefPPCoreBinding s => (s, (case assoca s l_st of NONE => [] | SOME l => l)))
                                                                                 end;
                                                                 val (s_prea, l_pre) = get_state s_pre;
                                                                 val (s_posta, l_post) = (case s_post of NONE => (s_prea, l_pre) | SOME a => get_state a);
                                                               in
                                                                 f (s_prea, l_pre) (s_posta, l_post) ((s_prea, l_pre) :: (if equal s_prea s_posta then [] else [(s_posta, l_post)])) env
                                                               end);

fun print_transition_def_state x =
  get_state (fn pre => fn post => fn _ =>
              ((fn a => fn b => (a, b)) o map definitiona) (map let
                                                                  val _ = (fn f => fn xa => term_app f [xa]);
                                                                  val b = (fn s => Term_basic [s]);
                                                                in
                                                                  (fn (s, _) => Definitiona (Term_rewrite (b s, SS_base (ST "="), b (flattenb (print_examp_def_st_locale_name s) (flattenb (SS_base (ST ".")) s)))))
                                                                end
                                                             [pre, post]))
    x;

fun print_examp_instance_name x = id x;

fun oidGetInh x = (fn Oids (_, _, a) => Oid a) x;

fun lemmas_nosimp x = (fn a => Lemmas_simp_thm (false, x, a));

fun merge_unique_gen B_ f l = fold (fold (fn x => (case f x of NONE => id | SOME a => let
                                                                                        val (aa, b) = a;
                                                                                      in
                                                                                        insert B_ aa b
                                                                                      end)))
                                l emptya;

fun merge_unique B_ f l = entries (merge_unique_gen B_ f l);

fun merge_uniquea B_ f =
  map snd o entries o (fn l => fold (fn (a, b) => let
                                                    val (k, _) = a;
                                                  in
                                                    (fn e => fn rbt => insert equal_internal_oid k (case lookupa equal_internal_oid rbt k of NONE => [e] | SOME aa => e :: aa) rbt)
                                                  end
                                                    b)
                                 l emptya) o
    merge_unique (equal_prod equal_internal_oid B_) (fn (a, b) => let
                                                                    val (aa, n) = a;
                                                                  in
                                                                    (fn ba => SOME ((oidGetInh aa, n), (aa, ba)))
                                                                  end
                                                                    b) o
    map (map (fn (oid, e) => ((oid, f e), e)));

fun merge_uniqueb l = map (map (map_prod id (fn OclDefCoreBinding (_, ocli) => ocli))) (merge_uniquea (equal_list equal_integer) (fn OclDefCoreBinding (s, _) => to_list s) l);

fun inst_attr (Ocl_instance_single_ext (inst_name, inst_ty, inst_attr_with, inst_attr, more)) = inst_attr;

fun inst_tya (Ocl_instance_single_ext (inst_name, inst_ty, inst_attr_with, inst_attr, more)) = inst_ty;

fun inst_ty0 ocli = (case inst_tya ocli of NONE => (case inst_attr ocli of OclAttrNoCast _ => NONE | OclAttrCast (ty, _, _) => SOME ty) | SOME a => SOME a);

fun inst_ty ocli = let
                     val SOME ty = inst_ty0 ocli;
                   in
                     ty
                   end;

fun inst_namea (Ocl_instance_single_ext (inst_name, inst_ty, inst_attr_with, inst_attr, more)) = inst_name;

fun inst_name ocli = let
                       val SOME n = inst_namea ocli;
                     in
                       n
                     end;

val var_oid_uniq : abr_string = SS_base (ST "oid");

fun lemmas x = i Theory_lemmas x;

fun print_transition_lemmas_oid x =
  get_state (fn (s_pre, l_pre) => fn (s_post, l_post) => fn _ =>
              ((fn a => fn b => (a, b)) o map lemmas)
                let
                  val _ = (fn s => Term_basic [s]);
                in
                  map let
                        val l_pp = merge_uniqueb [l_pre, l_post];
                      in
                        (fn (tit, f) => lemmas_nosimp (flattenb tit (flattenb s_pre (flattenb (SS_base (ST "_")) s_post))) (flatten (map (map (thma o hol_definition) o f) l_pp)))
                      end
                    [(SS_base (ST "pp_oid_"), (fn (cpt, _) :: _ => [flattena [var_oid_uniq, natural_to_digit10 let
                                                                                                                 val Oid i = oidGetInh cpt;
                                                                                                               in
                                                                                                                 i
                                                                                                               end]])),
                      (SS_base (ST "pp_object_"), map (fn (_, a) => inst_name a)), (SS_base (ST "pp_object_ty_"), map (fn (_, ocli) => print_examp_instance_name (fn s => flattenb s (isub (inst_ty ocli))) (inst_name ocli)))]
                end)
    x;

val floor2_PRINT_transition_lemmas_oid : (ocl_def_transition -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor2_examp.print_transition_lemmas_oid"), print_transition_lemmas_oid);

fun print_transition_locale_name s_pre s_post = flattenb (SS_base (ST "transition_")) (flattenb s_pre (flattenb (SS_base (ST "_")) s_post));

fun term_oid s = (fn Oid n => Term_basic [flattenb s (natural_to_digit10 n)]);

fun map_tail f = let
                   val fa = map_prod (term_oid var_oid_uniq o oidGetInh) f;
                 in
                   map (fn x :: xs => map_prod id (fn xa => flatten (xa :: map (snd o fa) xs)) (fa x))
                 end;

fun filter_locale_interp x = (split o map_tail let
                                                 val a = (fn f => fn xa => term_app f [xa]);
                                                 val b = (fn s => Term_basic [s]);
                                                 val c = (fn aa => Term_paren (SS_base (ST "\092<lceil>"), SS_base (ST "\092<rceil>"), aa));
                                                 val var_tau = SS_base (ST "\092<tau>");
                                               in
                                                 (fn xa => let
                                                             val n = inst_name xa;
                                                           in
                                                             [c (c (a n (b var_tau))), b n]
                                                           end)
                                               end)
                               x;

fun print_transition_def_interp x =
  get_state (fn (s_pre, l_pre) => fn (s_post, l_post) => fn _ =>
              ((fn a => fn b => (a, b)) o map definition)
                let
                  val a = (fn f => fn xa => term_app f [xa]);
                  val b = (fn s => Term_basic [s]);
                  val var_tau = SS_base (ST "\092<tau>");
                  val (oid, l_fix_assum) = filter_locale_interp (merge_uniqueb [l_pre, l_post]);
                in
                  [Definitiona (Term_rewrite
                                 (a (flattenb (SS_base (ST "pp_")) (flattenb s_pre (flattenb (SS_base (ST "_")) s_post))) (b var_tau), SS_base (ST "="),
                                   term_app (print_transition_locale_name s_pre s_post) (flatten [oid, flatten l_fix_assum])))]
                end)
    x;

val floor2_PRINT_transition_def_interp : (ocl_def_transition -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor2_examp.print_transition_def_interp"), print_transition_def_interp);

val print_examp_def_st_locale_distinct : abr_string = SS_base (ST "distinct_oid");

fun print_examp_def_st_locale_aux l =
  let
    val b = (fn s => Term_basic [s]);
  in
    map_prod id flatten
      (split (map_tail (fn ocli => let
                                     val n = inst_name ocli;
                                     val ty = inst_ty ocli;
                                     val f = (fn s => flattenb s (isub ty));
                                     val name_pers = print_examp_instance_name f n;
                                   in
                                     [([(b name_pers, Typ_base (f datatype_name))], NONE),
                                       ([(b n, Typ_base (wrap_oclty ty))], SOME (hol_definition n, Term_rewrite (b n, SS_base (ST "="), term_lambda wildcard (term_some (term_some (b name_pers))))))]
                                   end)
               l))
  end;

fun term_list l = (case l of [] => Term_basic [SS_base (ST "[]")] | _ :: _ => Term_paren (SS_base (ST "["), SS_base (ST "]"), term_binopa (SS_base (ST ",")) l));

fun print_examp_def_st_locale_make f_name f_spec l =
  let
    val (oid, l_fix_assum) = print_examp_def_st_locale_aux l;
    val ty_n = SS_base (ST "nat");
  in
    Semi_locale_ext
      (f_name, flatten [[(map (fn x => (x, Typ_base ty_n)) oid, SOME (print_examp_def_st_locale_distinct, term_app (SS_base (ST "distinct")) [let
                          val e = term_list oid;
                        in
                          (if null oid then term_annot e (flattenb ty_n (SS_base (ST " list"))) else e)
                        end]))],
                         l_fix_assum, f_spec],
        ())
  end;

fun print_transition_locale_aux l = let
                                      val (oid, l_fix_assum) = print_examp_def_st_locale_aux (merge_uniqueb [l]);
                                    in
                                      flatten [oid, flatten (map (map fst o fst) l_fix_assum)]
                                    end;

fun print_transition_locale x =
  get_state (fn (s_pre, l_pre) => fn (s_post, l_post) => fn l_pre_post =>
              (fn a => (print_examp_def_st_locale_make (print_transition_locale_name s_pre s_post) (map (fn (s, l) => ([], SOME (s, term_app (print_examp_def_st_locale_name s) (print_transition_locale_aux l)))) l_pre_post)
                          (merge_uniqueb [l_pre, l_post]),
                         a)))
    x;

fun interpretationa x = Theory_interpretation x;

fun rule x = (Method_rule o SOME) x;

fun by x = Command_by x;

fun print_transition_interp x = get_state (fn _ => fn _ => (fn a => fn b => (a, b)) o map interpretationa o map (fn (s, l) => let
          val n = print_examp_def_st_locale_name s;
        in
          Interpretation (n, n, print_transition_locale_aux l, by [rule (thma s)])
        end))
                                  x;

fun metis x = Method_metis ([], x);

val print_examp_def_st_locale_metis : semi_method = metis (map thma [print_examp_def_st_locale_distinct, SS_base (ST "distinct_length_2_or_more")]);

fun method_simp_add_del l_a l_d = Method_simp_add_del_split (l_a, l_d, []);

fun meth_gen_simp_add2 l1 l2 = method_simp_add_del (flatten [map Thms_mult l1, map (Thms_single o Thm_thm) l2]) [];

fun simp_add2 l1 l2 = Method_one (meth_gen_simp_add2 l1 l2);

fun simp_add x = simp_add2 [] x;

fun term_pair e1 e2 = term_parenthesis (term_binop e1 (SS_base (ST ",")) e2);

fun optiona x = Method_option x;

fun const_oid_of s = flattenb (SS_base (ST "oid_of_")) s;

fun applya x = Command_apply x;

fun lemmaa x = Theory_lemma x;

fun print_transition_where x =
  get_state (fn (s_pre, l_pre) => fn (s_post, l_post) => fn l_pre_post =>
              (fn a => ((map lemmaa o flatten)
                          let
                            val aa = (fn f => fn xa => term_app f [xa]);
                            val b = (fn s => Term_basic [s]);
                            val d = hol_definition;
                            val mk_n = (fn s => flattenb (print_examp_def_st_locale_name s) (flattenb (SS_base (ST ".")) s));
                            val f_name = (fn (cpt, ocore) => SOME (oidGetInh cpt, ocore));
                            val rbt_pre = merge_unique_gen equal_internal_oid f_name [l_pre];
                            val rbt_post = merge_unique_gen equal_internal_oid f_name [l_post];
                          in
                            map (fn x_pers_oid =>
                                  let
                                    val c = (case (lookupa equal_internal_oid rbt_pre x_pers_oid, lookupa equal_internal_oid rbt_post x_pers_oid) of (NONE, SOME ocore) => (SS_base (ST "OclIsNew"), [(ocore, s_post)])
                                              | (SOME ocore1, NONE) => (SS_base (ST "OclIsDeleted"), [(ocore1, s_pre)])
                                              | (SOME ocore1, SOME ocore2) => (SS_base (ST "OclIsMaintained"), let
                                                                                                                 val l = [(ocore1, s_pre), (ocore2, s_post)];
                                                                                                               in
                                                                                                                 (if equal_lista equal_integer (to_list s_pre) (to_list s_post) then [hd l] else l)
                                                                                                               end));
                                    val (x_where, ca) = c;
                                  in
                                    map (fn (OclDefCoreBinding (name, ocli), name_st) =>
                                          Lemma_assumes
                                            (flattena [var_oid_uniq, natural_to_digit10 let
                                                                                          val Oid i = x_pers_oid;
                                                                                        in
                                                                                          i
                                                                                        end,
                                                        s_pre, s_post, SS_base (ST "_"), name_st, SS_base (ST "_"), x_where],
                                              [(SS_base (ST ""),
                                                 (true, Term_rewrite (aa (SS_base (ST "oid_of")) (b (print_examp_instance_name (fn s => flattenb s (isub (inst_ty ocli))) (inst_name ocli))), SS_base (ST "="),
                                                                       term_oid var_oid_uniq x_pers_oid)))],
                                              term_binop let
                                                           val mk_na = b o mk_n;
                                                         in
                                                           term_pair (mk_na s_pre) (mk_na s_post)
                                                         end
                                                (SS_base (ST "\092<Turnstile>")) (aa x_where (b name)),
                                              [applya [simp_add (map d let
                                                                         val l = [mk_n s_post, name, x_where, SS_base (ST "OclValid"), const_oid_of (SS_base (ST "option"))];
                                                                       in
                                                                         (case l_pre_post of [] => mk_n s_pre :: l | [_] => l | _ :: _ :: _ => mk_n s_pre :: l)
                                                                       end)]],
                                              by [optiona [print_examp_def_st_locale_metis]]))
                                      ca
                                  end)
                              (keys (union equal_internal_oid rbt_pre rbt_post))
                          end,
                         a)))
    x;

fun auto_simp_add2 l1 l2 = Method_auto_simp_add_split (flatten [map Thms_mult l1, map (Thms_single o Thm_thm) l2], []);

fun auto_simp_add x = auto_simp_add2 [] x;

fun have0 x = (fn a => fn b => fn c => Command_have (x, a, b, c));

val datatype_in : abr_string = SS_base (ST "in");

fun print_transition_wff x =
  get_state (fn (s_pre, l_pre) => fn (s_post, l_post) => fn l_pre_post =>
              (fn a => (map lemmaa let
                                     val aa = (fn f => fn xa => term_app f [xa]);
                                     val b = (fn s => Term_basic [s]);
                                     val d = hol_definition;
                                     val mk_n = (fn s => flattenb (print_examp_def_st_locale_name s) (flattenb (SS_base (ST ".")) s));
                                   in
                                     [Lemma_assumes
                                        (flattena [SS_base (ST "basic_"), s_pre, SS_base (ST "_"), s_post, SS_base (ST "_wff")],
                                          flatten (map (map (fn (cpt, ocli) =>
                                                              let
                                                                val ty = (fn s => flattenb s (isub (inst_ty ocli)));
                                                                val n = inst_name ocli;
                                                              in
                                                                (SS_base (ST ""),
                                                                  (true, Term_rewrite (aa (SS_base (ST "oid_of")) (aa (ty datatype_in) (b (print_examp_instance_name ty n))), SS_base (ST "="), term_oid var_oid_uniq (oidGetInh cpt))))
                                                              end))
                                                    (merge_uniqueb [l_pre, l_post])),
                                          aa (SS_base (ST "WFF")) let
                                                                    val mk_na = b o mk_n;
                                                                  in
                                                                    term_pair (mk_na s_pre) (mk_na s_post)
                                                                  end,
                                          map snd (merge_unique (equal_list equal_internal_oid)
                                                    (fn [oid_b, oid_a] =>
                                                      (if equal_internal_oida oid_a oid_b then NONE
                                                        else SOME ([oid_a, oid_b],
                                                                    have0 (SS_base (ST "")) true (Term_rewrite (term_oid var_oid_uniq oid_a, SS_base (ST "\092<noteq>"), term_oid var_oid_uniq oid_b))
                                                                      (by [print_examp_def_st_locale_metis]))))
                                                    [n_lists (nat_of_integer (2 : IntInf.int)) (map (oidGetInh o fst) (flatten (map snd l_pre_post)))]),
                                          by [auto_simp_add (map d (SS_base (ST "WFF") :: map (mk_n o fst) l_pre_post))])]
                                   end,
                         a)))
    x;

fun print_examp_instance_app_constr2_notmpa l_attr e =
  (case l_attr of OclAttrNoCast _ => e | OclAttrCast (ty, OclAttrNoCast _, _) => term_annot e (wrap_oclty ty)
    | OclAttrCast (ty, OclAttrCast (abr_stringa, ocl_list_attr, aa), _) => term_postunary (term_parenthesis (print_examp_instance_app_constr2_notmpa (OclAttrCast (abr_stringa, ocl_list_attr, aa)) e)) (Term_basic [dot_astype ty]));

fun to_bold_number x =
  replace_integersa
    (fn n => nth [SS_base (ST "\092<zero>"), SS_base (ST "\092<one>"), SS_base (ST "\092<two>"), SS_base (ST "\092<three>"), SS_base (ST "\092<four>"), SS_base (ST "\092<five>"), SS_base (ST "\092<six>"), SS_base (ST "\092<seven>"),
                   SS_base (ST "\092<eight>"), SS_base (ST "\092<nine>")]
               (nat_of_integer (n - (48 : IntInf.int))))
    x;

val var_OclInteger : abr_string = SS_base (ST "OclInt");

val var_OclString : abr_string = SS_base (ST "OclString");

val var_OclReal : abr_string = SS_base (ST "OclReal");

fun is_emptyb x = (fn a => (case a of ST s => ((s : string) = "") | STa aa => null aa)) x;

fun is_empty e = (case e of SS_base a => is_emptyb a | String_concatWith (_, a) => list_all is_empty a);

fun base255 x = replace_integersa (fn c => (if is_letter c then SS_base (STa [c]) else add_0 c)) x;

fun text2_of_str x = replace_integersa (fn c => flattena [SS_base (ST "\092"), SS_base (ST "<"), SS_base (STa [c]), SS_base (ST ">")]) x;

fun text_of_str str =
  let
    val s = SS_base (ST "c");
    val ap = SS_base (ST " # ");
  in
    flattena [SS_base (ST "(let "), s, SS_base (ST " = char_of :: nat \092<Rightarrow> char in "),
               replace_integersa (fn c => (if is_letter c then flattena [SS_base (ST "CHR ''"), SS_base (STa [c]), SS_base (ST "''"), ap] else flattena [s, SS_base (ST " "), add_0 c, ap])) str, SS_base (ST "[])")]
  end;

fun all f = foldla (fn b => fn s => b andalso f s) true;

fun print_examp_oclbase_gen x =
  (fn a => (case a of OclDefInteger nb => let
                                            val name = flattenb var_OclInteger nb;
                                            val b = (fn s => Term_basic [s]);
                                            val ab_name = b nb;
                                          in
                                            (ab_name, Definition_where2 (name, b (to_bold_number nb), Term_rewrite (b name, SS_base (ST "="), term_lambda wildcard (term_some (term_some ab_name)))))
                                          end
             | OclDefReal (nb0, nb1) =>
               let
                 val name = flattena [var_OclReal, nb0, SS_base (ST "_"), nb1];
                 val b = (fn s => Term_basic [s]);
                 val ab_name = b (flattena [nb0]);
               in
                 (ab_name, Definition_where2 (name, b (flattena [to_bold_number nb0, SS_base (ST "."), to_bold_number nb1]), Term_rewrite (b name, SS_base (ST "="), term_lambda wildcard (term_some (term_some ab_name)))))
               end
             | OclDefString nb =>
               let
                 val name = flattenb var_OclString (base255 nb);
                 val b = (fn s => Term_basic [s]);
               in
                 (if not (is_empty nb) andalso all is_letter nb then let
                                                                       val ab_name = b (flattena [SS_base (ST "''"), nb, SS_base (ST "''")]);
                                                                     in
                                                                       (ab_name, Definition_where2 (name, b (text2_of_str nb), Term_rewrite (b name, SS_base (ST "="), term_lambda wildcard (term_some (term_some ab_name)))))
                                                                     end
                   else let
                          val ab_name = b (text_of_str nb);
                        in
                          (ab_name, Definitiona (Term_rewrite (b name, SS_base (ST "="), term_lambda wildcard (term_some (term_some ab_name)))))
                        end)
               end))
    x;

fun filter_ocl_exn s v = (if equal s (SS_base (ST "null")) then Return_err Return_ocl_null else (if equal s (SS_base (ST "invalid")) then Return_err Return_ocl_invalid else v));

fun print_examp_instance_draw_list_attr_aux_base x =
  (fn a => (case a of (_, ShallB_term t) => Return_val (fst (print_examp_oclbase_gen t)) | (xa, ShallB_str s) => filter_ocl_exn s (Return_err (Return_err_ty (xa, ShallB_str s)))
             | (xa, ShallB_self internal_oid) => Return_err (Return_err_ty (xa, ShallB_self internal_oid)) | (xa, ShallB_list lista) => Return_err (Return_err_ty (xa, ShallB_list lista))))
    x;

fun list_bind_e_r_r f0 f l =
  (case partition (fn a => (case a of Return_val _ => false | Return_err _ => true)) (map f0 l) of ([], la) => Return_val (f (map (fn Return_val e => e) la))
    | (a :: lista, _) => Return_err (Return_err_l (map (fn Return_err e => e) (a :: lista))));

fun print_examp_instance_draw_list_attr_aux f_oid_rec e =
  (case e of (OclTy_base_void, shall) => Return_err (Return_err_ty (OclTy_base_void, shall)) | (OclTy_base_boolean, shall) => Return_err (Return_err_ty (OclTy_base_boolean, shall))
    | (OclTy_base_integer, _) => print_examp_instance_draw_list_attr_aux_base e | (OclTy_base_unlimitednatural, shall) => Return_err (Return_err_ty (OclTy_base_unlimitednatural, shall))
    | (OclTy_base_real, _) => print_examp_instance_draw_list_attr_aux_base e | (OclTy_base_string, _) => print_examp_instance_draw_list_attr_aux_base e | (OclTy_object (OclTyObj (OclTyCore_pre _, _)), _) => f_oid_rec e
    | (OclTy_object (OclTyObj (OclTyCore ocl_ty_class_ext, xa)), shall) => Return_err (Return_err_ty (OclTy_object (OclTyObj (OclTyCore ocl_ty_class_ext, xa)), shall))
    | (OclTy_collection (x, ty), ShallB_term ocl_def_base) => Return_err (Return_err_ty (OclTy_collection (x, ty), ShallB_term ocl_def_base))
    | (OclTy_collection (x, ty), ShallB_str abr_string) => Return_err (Return_err_ty (OclTy_collection (x, ty), ShallB_str abr_string))
    | (OclTy_collection (x, ty), ShallB_self internal_oid) => Return_err (Return_err_ty (OclTy_collection (x, ty), ShallB_self internal_oid))
    | (OclTy_collection (_, ty), ShallB_list a) => list_bind_e_r_r (fn ea => print_examp_instance_draw_list_attr_aux f_oid_rec (ty, ea)) term_list a
    | (OclTy_pair (ty1, ty2), ShallB_term ocl_def_base) => Return_err (Return_err_ty (OclTy_pair (ty1, ty2), ShallB_term ocl_def_base))
    | (OclTy_pair (ty1, ty2), ShallB_str abr_string) => Return_err (Return_err_ty (OclTy_pair (ty1, ty2), ShallB_str abr_string))
    | (OclTy_pair (ty1, ty2), ShallB_self internal_oid) => Return_err (Return_err_ty (OclTy_pair (ty1, ty2), ShallB_self internal_oid))
    | (OclTy_pair (ty1, ty2), ShallB_list []) => Return_err (Return_err_ty (OclTy_pair (ty1, ty2), ShallB_list [])) | (OclTy_pair (ty1, ty2), ShallB_list [e1]) => Return_err (Return_err_ty (OclTy_pair (ty1, ty2), ShallB_list [e1]))
    | (OclTy_pair (ty1, ty2), ShallB_list [e1, e2]) => list_bind_e_r_r id (fn [e1a, e2a] => term_pair e1a e2a) [print_examp_instance_draw_list_attr_aux f_oid_rec (ty1, e1), print_examp_instance_draw_list_attr_aux f_oid_rec (ty2, e2)]
    | (OclTy_pair (ty1, ty2), ShallB_list (e1 :: e2 :: ad :: lista)) => Return_err (Return_err_ty (OclTy_pair (ty1, ty2), ShallB_list (e1 :: e2 :: ad :: lista)))
    | (OclTy_binding prod, shall) => Return_err (Return_err_ty (OclTy_binding prod, shall)) | (OclTy_arrow (ocl_ty1, ocl_ty2), shall) => Return_err (Return_err_ty (OclTy_arrow (ocl_ty1, ocl_ty2), shall))
    | (OclTy_class_syn _, _) => print_examp_instance_draw_list_attr_aux_base e | (OclTy_enum x, ShallB_term ocl_def_base) => Return_err (Return_err_ty (OclTy_enum x, ShallB_term ocl_def_base))
    | (OclTy_enum _, ShallB_str s) => filter_ocl_exn s (Return_val (Term_basic [pref_constr_enum s])) | (OclTy_enum x, ShallB_self internal_oid) => Return_err (Return_err_ty (OclTy_enum x, ShallB_self internal_oid))
    | (OclTy_enum x, ShallB_list lista) => Return_err (Return_err_ty (OclTy_enum x, ShallB_list lista)) | (OclTy_raw abr_string, shall) => Return_err (Return_err_ty (OclTy_raw abr_string, shall)));

fun bind_e_r_r v f = (case v of Return_val a => f a | Return_err a => Return_err a);

fun map_e_r_r f v = bind_e_r_r v (Return_val o f);

fun has_invalid e = (case e of Return_err_ty _ => false | Return_err_ty_auto => false | Return_ocl_null => false | Return_ocl_invalid => true | Return_object_variable _ => false | Return_err_l a => list_ex has_invalid a);

fun has_err_ty e = (case e of Return_err_ty _ => true | Return_err_ty_auto => true | Return_ocl_null => false | Return_ocl_invalid => false | Return_object_variable _ => false | Return_err_l a => list_ex has_err_ty a);

fun print_examp_instance_draw_list_attr x =
  (fn (f_oid, f_oid_rec) =>
    let
      val a = (fn f => fn xa => term_app f [xa]);
      val b = (fn s => Term_basic [s]);
      val filter_ty_err =
        (fn pre_post => fn f => fn c =>
          (case c of Return_val v => Return_val (f v)
            | Return_err err =>
              (if has_err_ty err orelse has_invalid err then Return_err err
                else (case (pre_post, err) of (NONE, _) => Return_val (b (SS_base (ST "None"))) | (SOME (_, _), Return_err_ty _) => Return_val (b (SS_base (ST "None")))
                       | (SOME (_, _), Return_err_ty_auto) => Return_val (b (SS_base (ST "None"))) | (SOME (_, _), Return_ocl_null) => Return_val (b (SS_base (ST "None")))
                       | (SOME (_, _), Return_ocl_invalid) => Return_val (b (SS_base (ST "None")))
                       | (SOME (pre, post), Return_object_variable s) => Return_val (a (SS_base (ST "Some")) (a (SS_base (ST "oid_of")) (term_app s [term_pair (b pre) (b post)])))
                       | (SOME (_, _), Return_err_l _) => Return_val (b (SS_base (ST "None")))))));
    in
      list_bind_e_r_r
        (fn obj => bind_e_r_r (case obj of (t_obj, NONE) => Return_val (case t_obj of NONE => Return_exp (b (SS_base (ST "None"))) | SOME aa => Return_obj aa)
                                | (_, SOME (OclTy_base_void, (pre_post, shallow))) => map_e_r_r Return_exp (filter_ty_err pre_post term_some (print_examp_instance_draw_list_attr_aux f_oid_rec (OclTy_base_void, shallow)))
                                | (_, SOME (OclTy_base_boolean, (pre_post, shallow))) => map_e_r_r Return_exp (filter_ty_err pre_post term_some (print_examp_instance_draw_list_attr_aux f_oid_rec (OclTy_base_boolean, shallow)))
                                | (_, SOME (OclTy_base_integer, (pre_post, shallow))) => map_e_r_r Return_exp (filter_ty_err pre_post term_some (print_examp_instance_draw_list_attr_aux f_oid_rec (OclTy_base_integer, shallow)))
                                | (_, SOME (OclTy_base_unlimitednatural, (pre_post, shallow))) =>
                                  map_e_r_r Return_exp (filter_ty_err pre_post term_some (print_examp_instance_draw_list_attr_aux f_oid_rec (OclTy_base_unlimitednatural, shallow)))
                                | (_, SOME (OclTy_base_real, (pre_post, shallow))) => map_e_r_r Return_exp (filter_ty_err pre_post term_some (print_examp_instance_draw_list_attr_aux f_oid_rec (OclTy_base_real, shallow)))
                                | (_, SOME (OclTy_base_string, (pre_post, shallow))) => map_e_r_r Return_exp (filter_ty_err pre_post term_some (print_examp_instance_draw_list_attr_aux f_oid_rec (OclTy_base_string, shallow)))
                                | (_, SOME (OclTy_object (OclTyObj (OclTyCore_pre abr_string, xa)), (pre_post, shallow))) =>
                                  map_e_r_r Return_exp (filter_ty_err pre_post term_some (print_examp_instance_draw_list_attr_aux f_oid_rec (OclTy_object (OclTyObj (OclTyCore_pre abr_string, xa)), shallow)))
                                | (_, SOME (OclTy_object (OclTyObj (OclTyCore ty_obj, _)), _)) => Return_val (Return_obj ty_obj)
                                | (_, SOME (OclTy_collection (ocl_multiplicity_ext, ocl_ty), (pre_post, shallow))) =>
                                  map_e_r_r Return_exp (filter_ty_err pre_post term_some (print_examp_instance_draw_list_attr_aux f_oid_rec (OclTy_collection (ocl_multiplicity_ext, ocl_ty), shallow)))
                                | (_, SOME (OclTy_pair (ocl_ty1, ocl_ty2), (pre_post, shallow))) =>
                                  map_e_r_r Return_exp (filter_ty_err pre_post term_some (print_examp_instance_draw_list_attr_aux f_oid_rec (OclTy_pair (ocl_ty1, ocl_ty2), shallow)))
                                | (_, SOME (OclTy_binding prod, (pre_post, shallow))) => map_e_r_r Return_exp (filter_ty_err pre_post term_some (print_examp_instance_draw_list_attr_aux f_oid_rec (OclTy_binding prod, shallow)))
                                | (_, SOME (OclTy_arrow (ocl_ty1, ocl_ty2), (pre_post, shallow))) =>
                                  map_e_r_r Return_exp (filter_ty_err pre_post term_some (print_examp_instance_draw_list_attr_aux f_oid_rec (OclTy_arrow (ocl_ty1, ocl_ty2), shallow)))
                                | (_, SOME (OclTy_class_syn abr_string, (pre_post, shallow))) =>
                                  map_e_r_r Return_exp (filter_ty_err pre_post term_some (print_examp_instance_draw_list_attr_aux f_oid_rec (OclTy_class_syn abr_string, shallow)))
                                | (_, SOME (OclTy_enum abr_string, (pre_post, shallow))) => map_e_r_r Return_exp (filter_ty_err pre_post term_some (print_examp_instance_draw_list_attr_aux f_oid_rec (OclTy_enum abr_string, shallow)))
                                | (_, SOME (OclTy_raw abr_string, (pre_post, shallow))) => map_e_r_r Return_exp (filter_ty_err pre_post term_some (print_examp_instance_draw_list_attr_aux f_oid_rec (OclTy_raw abr_string, shallow))))
                     (fn aa => (case aa of Return_obj ty_obj => filter_ty_err NONE id (f_oid ty_obj) | Return_exp ab => Return_val ab)))
        id
    end)
    x;

val datatype_constr_name : abr_string = SS_base (ST "mk");

fun print_examp_instance_app_constr_notmp f_oid = (fn isub_name => fn app_x => fn l_attr => map_e_r_r (fn l => term_app (isub_name datatype_constr_name) (app_x :: l)) (print_examp_instance_draw_list_attr f_oid l_attr));

val datatype_ext_constr_name : abr_string = flattenb datatype_constr_name (SS_base (ST "\092<E>\092<X>\092<T>"));

fun print_examp_instance_app_constr2_notmp l_attr isub_name cpt f_oid =
  (case l_attr of OclAttrNoCast [(OptOwn, l_own), (OptInh, l_inh)] =>
                 bind_e_r_r (map_e_r_r let
                                         val var_oid = term_oid var_oid_uniq (oidGetInh cpt);
                                       in
                                         (fn l => (term_app (isub_name datatype_ext_constr_name) (var_oid :: l), l_own))
                                       end
                              (print_examp_instance_draw_list_attr (f_oid isub_name cpt) l_inh))
                   (fn (a, b) => print_examp_instance_app_constr_notmp (f_oid isub_name cpt) isub_name a b)
    | OclAttrCast (x, l_attra, _) => print_examp_instance_app_constr2_notmp l_attra (fn s => flattenb s (isub x)) cpt f_oid);

fun tyObjN_ass_switch (Ocl_ty_class_node_ext (tyObjN_ass_switch, tyObjN_role_multip, tyObjN_role_ty, more)) = tyObjN_ass_switch;

fun tyObj_ass_arity (Ocl_ty_class_ext (tyObj_name, tyObj_ass_id, tyObj_ass_arity, tyObj_from, tyObj_to, more)) = tyObj_ass_arity;

fun print_access_oid_uniq_namea name_from_nat isub_name attr = flattena [isub_name var_oid_uniq, SS_base (ST "_"), natural_to_digit10 name_from_nat, SS_base (ST "_"), attr];

fun print_access_oid_uniq_name name_from_nat isub_name attr = print_access_oid_uniq_namea name_from_nat isub_name (isup attr);

val var_switch : abr_string = SS_base (ST "switch");

fun print_access_choose_name n i j = flattena [var_switch, isub (natural_to_digit10 n), SS_base (ST "_"), natural_to_digit10 i, natural_to_digit10 j];

fun tyObj_from (Ocl_ty_class_ext (tyObj_name, tyObj_ass_id, tyObj_ass_arity, tyObj_from, tyObj_to, more)) = tyObj_from;

fun fill_blank f_blank = map (fn (attr_ty, l) => let
                                                   val SOME f_fold = f_blank attr_ty;
                                                   val rbt = fold (fn ((ty, (_, ident)), shallow) => insert equal_opt_ident ident (ty, shallow)) l emptya;
                                                 in
                                                   (attr_ty, rev (f_fold (fn b => fn n => (fn a => (b, lookupa equal_opt_ident rbt (OptIdent n)) :: a)) []))
                                                 end);

fun split_inh_own f_class s_cast l_attr =
  let
    val (f_attr, f_blank) = f_class s_cast;
    val split = (fn l => partition (fn a => (case a of ((_, (OptInh, _)), _) => false | ((_, (OptOwn, _)), _) => true))
                           (map_filter (fn (pre_post, (name_attr, data)) => map_optiona (fn x => (x, (pre_post, data))) (f_attr name_attr)) l));
  in
    (case l_attr of OclAttrNoCast l => let
                                         val (l_own, l_inh) = split l;
                                       in
                                         OclAttrNoCast (fill_blank f_blank [(OptOwn, l_own), (OptInh, l_inh)])
                                       end
      | OclAttrCast (s_casta, l_attra, l) => let
                                               val (l_own, []) = split l;
                                             in
                                               OclAttrCast (s_casta, split_inh_own f_class s_casta l_attra, fill_blank f_blank [(OptOwn, l_own)])
                                             end)
  end;

fun tyRole (Ocl_multiplicity_ext (tyMult, tyRole, tyCollect, more)) = tyRole;

fun tyObjN_role_name x = (tyRole o tyObjN_role_multip) x;

fun print_examp_instance_app_constr2_notmp_norec x =
  (fn (rbt, (map_self, map_username)) => fn cpt_start => fn ocli => fn isub_name => fn cpt =>
    let
      val l_attr = split_inh_own rbt (inst_ty ocli) (inst_attr ocli);
    in
      (print_examp_instance_app_constr2_notmp l_attr isub_name cpt
         (fn isub_namea => fn oid =>
           ((fn ty_obj =>
              let
                val b = (fn s => Term_basic [s]);
              in
                Return_val (term_applys cpt_start
                             let
                               val ty_objfrom = tyObj_from ty_obj;
                               val ty_objto = tyObj_to ty_obj;
                             in
                               [b (print_access_oid_uniq_name (tyObjN_ass_switch ty_objfrom) isub_namea let
                                                                                                          val SOME s = tyObjN_role_name ty_objto;
                                                                                                        in
                                                                                                          s
                                                                                                        end),
                                 b (print_access_choose_name (tyObj_ass_arity ty_obj) (tyObjN_ass_switch ty_objfrom) (tyObjN_ass_switch ty_objto)), term_oid var_oid_uniq (oidGetInh oid)]
                             end)
              end),
             (fn base => let
                           val f = (fn v => fn a => (case a of NONE => Return_err v | SOME s => Return_val ((term_oid var_oid_uniq o oidGetInh) s)));
                         in
                           (case base of (_, ShallB_term _) => Return_err (Return_err_ty base) | (_, ShallB_str s) => f (Return_object_variable s) (map_username s) | (_, ShallB_self cpt1) => f (Return_err_ty base) (map_self cpt1)
                             | (_, ShallB_list _) => Return_err (Return_err_ty base))
                         end))),
        term_warning_parenthesis o print_examp_instance_app_constr2_notmpa l_attr)
    end)
    x;

fun d_input_instance_update d_input_instancea
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = Compiler_env_config_ext
      (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instancea d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap,
        d_ocl_accessor, d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more);

fun d_ocl_oid_start_update d_ocl_oid_starta
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = Compiler_env_config_ext
      (d_output_disable_thy, d_output_header_thy, d_ocl_oid_starta d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap,
        d_ocl_accessor, d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more);

fun d_input_instance
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = d_input_instance;

fun map_data_shallow_self f e = (case e of ShallB_term a => ShallB_term a | ShallB_str a => ShallB_str a | ShallB_self a => f a | ShallB_list l => ShallB_list (mapa (map_data_shallow_self f) l));

fun inst_attr_update inst_attra (Ocl_instance_single_ext (inst_name, inst_ty, inst_attr_with, inst_attr, more)) = Ocl_instance_single_ext (inst_name, inst_ty, inst_attr_with, inst_attra inst_attr, more);

fun map_list_attr f e = (case e of OclAttrNoCast x => OclAttrNoCast (f x) | OclAttrCast (c_from, l_attr, x) => OclAttrCast (c_from, map_list_attr f l_attr, f x));

fun map_instance_single f ocli = inst_attr_update (fn _ => map_list_attr (map f) (inst_attr ocli)) ocli;

fun map_inst_single_self f = map_instance_single (map_prod id (map_prod id (map_data_shallow_self f)));

fun inst_attr_with (Ocl_instance_single_ext (inst_name, inst_ty, inst_attr_with, inst_attr, more)) = inst_attr_with;

fun oidSucInh x = (fn Oids (n1, n2, n3) => Oids (n1, n2, succ (one_natural, plus_natural) n3)) x;

fun mk_instance_single_cpt0 map_username l env =
  let
    val a = mapM (fn ocli => fn cpt => (case inst_attr_with ocli of NONE => ([(ocli, cpt)], oidSucInh cpt) | SOME n => (case map_username n of NONE => ([(ocli, cpt)], oidSucInh cpt) | SOME cpta => ([(ocli, cpta)], cpt)))) l
              (d_ocl_oid_start env);
    val (la, aa) = a;
  in
    (flatten la, aa)
  end;

fun map_entry A_ k f [] = []
  | map_entry A_ k f (p :: ps) = (if eq A_ (fst p) k then (k, f (snd p)) :: ps else p :: map_entry A_ k f ps);

fun map_entrya A_ xc xd xe = Alist (map_entry A_ xc xd (impl_of xe));

fun modify_def B_ v k f rbt = (case lookup B_ rbt k of NONE => updatea B_ k (f v) rbt | SOME _ => map_entrya B_ k f rbt);

fun modify_defa v k = modify_def (equal_list equal_integer) v (to_list k);

fun of_inh x = (fn Tinh l => l) x;

fun map_class_inh l_inherited = map (fn OclClass (_, l, _) => l) (of_inh (map_inh of_linh l_inherited));

fun lookupb m k = lookupa (equal_list equal_integer) m (to_list k);

fun inserta k = insert (equal_list equal_integer) (to_list k);

fun rbt_of_class (B1_, B2_, B3_) env =
  let
    val rbt = (snd o fold_class_gen
                       (fn _ => fn name => fn l_attr => fn l_inh => fn _ => fn _ => fn rbt =>
                         ([()], modify_defa (emptya, []) name
                                  let
                                    val f_fold = (fn tag => fn l => fn rbta =>
                                                   let
                                                     val (rbtb, (_, n)) =
                                                       fold (fn (name_attr, ty) => fn (rbtb, (cpt, l_obj)) =>
                                                              (inserta name_attr (ty, (tag, OptIdent cpt)) rbtb,
                                                                (succ (one_natural, plus_natural) cpt,
                                                                  (case ty of OclTy_base_void => NONE | OclTy_base_boolean => NONE | OclTy_base_integer => NONE | OclTy_base_unlimitednatural => NONE | OclTy_base_real => NONE
                                                                    | OclTy_base_string => NONE | OclTy_object a => (case a of OclTyObj (OclTyCore_pre _, _) => NONE | OclTyObj (OclTyCore aa, _) => SOME aa)
                                                                    | OclTy_collection (_, _) => NONE | OclTy_pair (_, _) => NONE | OclTy_binding _ => NONE | OclTy_arrow (_, _) => NONE | OclTy_class_syn _ => NONE | OclTy_enum _ => NONE
                                                                    | OclTy_raw _ => NONE) ::
                                                                    l_obj)))
                                                         l (rbta, (Code_Numeral.zero_natural, []));
                                                   in
                                                     (rbtb, (tag, n))
                                                   end);
                                  in
                                    (fn (rbta, _) => let
                                                       val (rbtb, info_own) = f_fold OptOwn l_attr rbta;
                                                       val (rbtc, info_inh) = f_fold OptInh (flatten (map_class_inh l_inh)) rbtb;
                                                     in
                                                       (rbtc, [info_own, info_inh])
                                                     end)
                                  end
                                  rbt))
                       emptya)
                let
                  val SOME c = d_input_class env;
                in
                  c
                end;
  in
    (fn name => let
                  val rbta = lookupb rbt name;
                in
                  (is_none rbta,
                    ((fn name_attr => binda rbta (fn (rbtb, _) => lookupb rbtb name_attr)),
                      (fn v => binda rbta (fn (_, l) =>
                                            map_optiona (fn la => fn f => fn accu =>
                                                          let
                                                            val (_, accua) =
                                                              foldr let
                                                                      val f_fold = (fn b => fn (n, accua) => (succ (B1_, B2_) n, f b n accua));
                                                                    in
                                                                      (if equal_generation_semantics_ocl (d_ocl_semantics env) Gen_only_design then f_fold
                                                                        else (fn a => (case a of NONE => f_fold NONE | SOME _ => (fn (n, aa) => (succ (B1_, B2_) n, aa)))))
                                                                    end
                                                                la (zero B3_, accu);
                                                          in
                                                            accua
                                                          end)
                                              (assoc equal_opt_attr_type v l)))))
                end)
  end;

fun init_map_class (C1_, C2_, C3_) env l =
  let
    val (rbt_nat, (rbt_str, (_, _))) =
      fold (fn ocli => fn (rbt_nat, (rbt_str, (oid_start, accu))) =>
             let
               val f = (fn _ => (insert equal_internal_oid (Oid accu) oid_start rbt_nat, (inserta (inst_name ocli) oid_start rbt_str, (oidSucInh oid_start, succ (one_natural, plus_natural) accu))));
             in
               (case inst_attr_with ocli of NONE => f ()
                 | SOME s => (case lookupb rbt_str s of NONE => f ()
                               | SOME oid_starta => (insert equal_internal_oid (Oid accu) oid_starta rbt_nat, (inserta (inst_name ocli) oid_starta rbt_str, (oid_start, succ (one_natural, plus_natural) accu)))))
             end)
        l (emptya, (bulkload (equal_list equal_integer) (map (fn (k, a) => let
                                                                             val (_, aa) = a;
                                                                           in
                                                                             (to_lista k, aa)
                                                                           end)
                                                          (d_input_instance env)),
                     (d_ocl_oid_start env, Code_Numeral.zero_natural)));
  in
    (rbt_of_class (C1_, C2_, C3_) env, (lookupa equal_internal_oid rbt_nat, lookupb rbt_str))
  end;

val var_inst_assoc : abr_string = SS_base (ST "inst_assoc");

fun print_examp_instance x =
  (fn OclInstance l => fn env =>
    let
      val (a, b) = let
                     val (rbt, (map_self, map_username)) = init_map_class (one_natural, plus_natural, zero_natural) env l;
                     val a = (fn f => fn xa => term_app f [xa]);
                     val b = (fn s => Term_basic [s]);
                   in
                     (let
                        val var_inst_ass = SS_base (ST "inst_assoc");
                      in
                        map_prod (map (fn (ocli, cpt) =>
                                        let
                                          val _ = term_oid var_oid_uniq (oidGetInh cpt);
                                          val (isub_name, (body2, body2a)) =
                                            (case inst_ty0 ocli of NONE => (id, (Return_err Return_err_ty_auto, id))
                                              | SOME _ => let
                                                            val isub_name = (fn s => flattenb s (isub (inst_ty ocli)));
                                                          in
                                                            (isub_name, print_examp_instance_app_constr2_notmp_norec (snd o rbt, (map_self, map_username)) (b var_inst_ass) ocli isub_name cpt)
                                                          end);
                                          val la = [Definitiona (Term_rewrite
                                                                  (let
                                                                     val e = b (inst_name ocli);
                                                                   in
                                                                     (case inst_tya ocli of NONE => e | SOME aa => term_annot_ocl e aa)
                                                                   end,
                                                                    SS_base (ST "="),
                                                                    (case body2 of Return_val _ =>
                                                                                  body2a (term_lambda wildcard
                                                                                           (term_some (term_some let
                                                                                                                   val name_pers = print_examp_instance_name isub_name (inst_name ocli);
                                                                                                                 in
                                                                                                                   (if equal_generation_semantics_ocl (d_ocl_semantics env) Gen_only_design
                                                                                                                     then a name_pers (term_oid var_inst_assoc (oidGetInh (d_ocl_oid_start env))) else b name_pers)
                                                                                                                 end)))
                                                                      | Return_err _ => b (SS_base (ST "invalid")))))];
                                        in
                                          (case body2 of Return_val body2b =>
                                                        Definitiona (Term_rewrite
                                                                      (Term_basic (print_examp_instance_name isub_name (inst_name ocli) ::
                                                                                    (if equal_generation_semantics_ocl (d_ocl_semantics env) Gen_only_design then [var_inst_ass] else [])),
                                                                        SS_base (ST "="), body2b)) ::
                                                          la
                                            | Return_err _ => la)
                                        end))
                          id (mk_instance_single_cpt0 map_username l env)
                      end,
                       let
                         val l_id = mapi (fn i => fn ocli => (i, inst_name ocli)) l;
                       in
                         fold (fn ocli => fn instance_rbt =>
                                let
                                  val n = inst_name ocli;
                                in
                                  (to_String_b_a_s_e n, (map_inst_single_self (fn Oid self => (case assoc equal_natural self l_id of NONE => ShallB_list [] | SOME aa => ShallB_str aa)) ocli, let
                                                                           val SOME oid = map_username n;
                                                                         in
                                                                           oid
                                                                         end)) ::
                                    instance_rbt
                                end)
                           l (d_input_instance env)
                       end)
                   end;
    in
      let
        val (l_res, oid_start) = a;
      in
        (fn instance_rbt => ((map definition o flatten) l_res, d_input_instance_update (fn _ => instance_rbt) (d_ocl_oid_start_update (fn _ => oid_start) env)))
      end
        b
    end)
    x;

fun print_examp_increase_oid l_inst = snd o print_examp_instance (OclInstance l_inst);

fun inst_name_update inst_namea (Ocl_instance_single_ext (inst_name, inst_ty, inst_attr_with, inst_attr, more)) = Ocl_instance_single_ext (inst_namea inst_name, inst_ty, inst_attr_with, inst_attr, more);

fun print_examp_def_st0 name l =
  let
    val (la, _) =
      fold (fn (pos, core) => fn (la, n) => ((pos, (Code_Numeral.minus_natural pos n, core)) :: la, (case core of OclDefCoreAdd _ => n | OclDefCoreBinding _ => succ (one_natural, plus_natural) n))) (mapi (fn a => fn b => (a, b)) l)
        ([], Code_Numeral.zero_natural);
  in
    fold (fn a => (case a of (pos, (_, OclDefCoreAdd ocli)) =>
                            (fn (l_inst, l_defst) =>
                              let
                                val i_name = (case inst_namea ocli of NONE => flattena [name, SS_base (ST "_object"), natural_to_digit10 pos] | SOME x => x);
                              in
                                (inst_name_update (fn _ => SOME i_name)
                                   (map_inst_single_self
                                     (fn Oid self => (case assoc equal_natural self la of NONE => ShallB_list [] | SOME aa => let
          val (x, ab) = aa;
        in
          (case ab of OclDefCoreAdd _ => ShallB_self (Oid x) | OclDefCoreBinding ac => ShallB_str ac)
        end))
                                     ocli) ::
                                   l_inst,
                                  OclDefCoreBinding i_name :: l_defst)
                              end)
                    | (_, (_, OclDefCoreBinding namea)) => (fn (l_inst, l_defst) => (l_inst, OclDefCoreBinding namea :: l_defst))))
      la ([], [])
  end;

fun bootstrap_floora f_x l env = let
                                   val a = f_x l env;
                                   val (la, aa) = a;
                                 in
                                   (bootstrap_floor la env, aa)
                                 end;

fun print_transition_gen x =
  (fn OclDefPP (name, s_pre, s_post) =>
    bootstrap_floora (fn f => fn env => let
                                          val a = f env;
                                          val (l, aa) = a;
                                        in
                                          (flatten [map META_all_meta_embedding l], aa)
                                        end)
      (fn env => let
                   val pref_name = (case name of NONE => flattenb (SS_base (ST "WFF_")) (nat_to_digit10 (size_list (d_input_meta env))) | SOME n => n);
                   val f_comp = (fn a => (case a of NONE => id | SOME (_, (f, _)) => f));
                   val f_comp_env = (fn a => (case a of NONE => id | SOME (_, (_, f)) => f));
                   val f_conv = (fn msg => fn a =>
                                  (case a of OclDefPPCoreAdd ocl_def_state =>
                                            let
                                              val n = flattenb pref_name msg;
                                            in
                                              (OclDefPPCoreBinding n, ((fn aa => META_def_state (Floor1, OclDefSt (n, ocl_def_state)) :: aa), let
                          val l_inst = fst (print_examp_def_st0 n ocl_def_state);
                        in
                          (if null l_inst then id else print_examp_increase_oid l_inst)
                        end))
                                            end
                                    | OclDefPPCoreBinding abr_string => (OclDefPPCoreBinding abr_string, (id, id))));
                   val o_pre = SOME (f_conv (SS_base (ST "_pre")) s_pre);
                   val o_post = map_optiona (f_conv (SS_base (ST "_post"))) s_post;
                 in
                   ((f_comp o_pre o f_comp o_post) [META_def_transition (Floor2, OclDefPP (name, let
                                                                                                   val SOME (n, _) = o_pre;
                                                                                                 in
                                                                                                   n
                                                                                                 end,
                                                                                            map_optiona fst o_post))],
                     f_comp_env o_pre o f_comp_env o_post)
                 end))
    x;

fun print_transition s = fst o print_transition_gen s;

val floor1_PRINT_transition : (ocl_def_transition -> unit compiler_env_config_ext -> all_meta list * unit compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_examp.print_transition"), print_transition);

fun thy_def_transition x =
  (fn a => (case a of Floor1 => Embed_theories [sectiona (SS_base (ST "Transition (Floor 1)")), floor1_PRINT_transition]
             | Floor2 => Embed_locale ([sectiona (SS_base (ST "Transition (Floor 2)"))], print_transition_locale, [print_transition_interp, print_transition_def_state, print_transition_wff, print_transition_where],
                                        [floor2_PRINT_transition_def_interp, floor2_PRINT_transition_lemmas_oid])))
    x;

val const_oclany : abr_string = SS_base (ST "OclAny");

fun classRaw_name_update classRaw_namea (Ocl_class_raw_ext (classRaw_name, classRaw_own, classRaw_clause, classRaw_abstract, more)) =
  Ocl_class_raw_ext (classRaw_namea classRaw_name, classRaw_own, classRaw_clause, classRaw_abstract, more);

fun classRaw_own_update classRaw_owna (Ocl_class_raw_ext (classRaw_name, classRaw_own, classRaw_clause, classRaw_abstract, more)) = Ocl_class_raw_ext (classRaw_name, classRaw_owna classRaw_own, classRaw_clause, classRaw_abstract, more);

fun classRaw_own (Ocl_class_raw_ext (classRaw_name, classRaw_own, classRaw_clause, classRaw_abstract, more)) = classRaw_own;

fun cl_name_to_string x = (ty_obj_to_string o classRaw_name) x;

fun class_unflat_aux rbt rbt_inv rbt_cycle r =
  (case lookupb rbt_inv r
    of NONE => (case lookupb rbt_cycle r of NONE => map_optiona (fn a => OclClass (r, let
                                                                                        val SOME l = lookupb rbt r;
                                                                                      in
                                                                                        l
                                                                                      end,
                                                                                    a))
                                                      let
                                                        val l = mapa (class_unflat_aux rbt rbt_inv (inserta r () rbt_cycle)) [];
                                                      in
                                                        (if list_ex (fn a => (case a of NONE => true | SOME _ => false)) l then NONE else SOME (id (map_filter id l)))
                                                      end
                 | SOME _ => NONE)
    | SOME l => (case lookupb rbt_cycle r
                  of NONE => map_optiona (fn a => OclClass (r, let
                                                                 val SOME la = lookupb rbt r;
                                                               in
                                                                 la
                                                               end,
                                                             a))
                               let
                                 val la = mapa (class_unflat_aux rbt rbt_inv (inserta r () rbt_cycle)) l;
                               in
                                 (if list_ex (fn a => (case a of NONE => true | SOME _ => false)) la then NONE else SOME (id (map_filter id la)))
                               end
                  | SOME _ => NONE));

fun oclAss_relationa (Ocl_association_ext (oclAss_type, oclAss_relation, more)) = oclAss_relation;

fun oclAss_relation l = let
                          val OclAssRel la = oclAss_relationa l;
                        in
                          la
                        end;

fun remove_binding e =
  (case e of OclTy_base_void => OclTy_base_void | OclTy_base_boolean => OclTy_base_boolean | OclTy_base_integer => OclTy_base_integer | OclTy_base_unlimitednatural => OclTy_base_unlimitednatural | OclTy_base_real => OclTy_base_real
    | OclTy_base_string => OclTy_base_string | OclTy_object a => OclTy_object a | OclTy_collection (m, ty) => OclTy_collection (m, remove_binding ty) | OclTy_pair (ty1, ty2) => OclTy_pair (remove_binding ty1, remove_binding ty2)
    | OclTy_binding a => let
                           val (_, aa) = a;
                         in
                           remove_binding aa
                         end
    | OclTy_arrow (ty1, ty2) => OclTy_arrow (remove_binding ty1, remove_binding ty2) | OclTy_class_syn a => OclTy_class_syn a | OclTy_enum a => OclTy_enum a | OclTy_raw a => OclTy_raw a);

fun map_entryb A_ = map_entrya A_;

fun map_entryc k = map_entryb (equal_list equal_integer) (to_list k);

fun entriesa m = map (map_prod (fn c => SS_base (STa c)) id) (entries m);

fun oclTy_class c = OclTy_object (OclTyObj (OclTyCore c, []));

fun normalize0 B_ f l = rev (snd (fold (fn x => fn (rbt, la) => let
                                                                  val x0 = f x;
                                                                in
                                                                  (case lookupa B_ rbt x0 of NONE => (insert B_ x0 () rbt, x :: la) | SOME _ => (rbt, la))
                                                                end)
                                   l (emptya, [])));

fun fold_max_aux f l l_acc accu = (case l of [] => accu | x :: xs => fold_max_aux f xs (x :: l_acc) (f x (flatten [rev l_acc, xs]) accu));

fun fold_max f l = fold_max_aux f (mapi (fn a => fn b => (a, b)) l) [];

fun class_unflat x =
  (fn (l_class, l_ass) =>
    let
      val l = let
                val const_oclanya = OclTyCore_pre const_oclany;
                val rbt = inserta const_oclany (make (OclTyObj (const_oclanya, [])) [] [] false)
                            (fold (fn xa => inserta (cl_name_to_string xa) (classRaw_name_update (fn _ => let
                                                                                                            val OclTyObj (n, a) = classRaw_name xa;
                                                                                                          in
                                                                                                            (case a of [] => OclTyObj (n, [[const_oclanya]]) | aa :: lista => OclTyObj (n, aa :: lista))
                                                                                                          end)
                                                                             xa))
                              l_class emptya);
              in
                map snd (entriesa (fold (fn (ass_oid, ass) =>
                                          (case let
                                                  val (l_none, l_some) = partition (fn (_, m) => is_none (tyRole m)) (oclAss_relation ass);
                                                in
                                                  flatten [l_none, normalize0 (equal_list equal_integer) (fn (_, m) => let
   val SOME a = tyRole m;
 in
   to_list a
 end)
                                                                     l_some]
                                                end
                                            of [] => id | [_] => id
                                            | xa :: ab :: lista =>
                                              fold_max let
                                                         val n_rel = natural_of_nat (size_list (xa :: ab :: lista));
                                                       in
                                                         (fn (cpt_to, (name_to, category_to)) =>
                                                           (case tyRole category_to of NONE => (fn _ => id)
                                                             | SOME role_to =>
                                                               fold (fn (cpt_from, (name_from, mult_from)) =>
                                                                      let
                                                                        val name_froma = ty_obj_to_string name_from;
                                                                      in
                                                                        map_entryc name_froma
                                                                          (fn cflat => classRaw_own_update
                                                                                         (fn _ => (role_to, oclTy_class (Ocl_ty_class_ext
    (const_oid, ass_oid, n_rel, Ocl_ty_class_node_ext (cpt_from, mult_from, name_froma, ()), Ocl_ty_class_node_ext (cpt_to, category_to, ty_obj_to_string name_to, ()), ()))) ::
                                                                                                    classRaw_own cflat)
                                                                                         cflat)
                                                                      end)))
                                                       end
                                                (xa :: ab :: lista)))
                                    (mapi (fn a => fn b => (a, b)) l_ass) rbt))
              end;
    in
      class_unflat_aux (fold (fn cflat => inserta (cl_name_to_string cflat) (normalize0 (equal_list equal_integer) (to_list o fst) (map (map_prod id remove_binding) (classRaw_own cflat)))) l emptya)
        (fold (fn cflat => let
                             val OclTyObj (n, a) = classRaw_name cflat;
                           in
                             (case a of [] => id
                               | aa :: lista => let
                                                  val x0 :: xs = rev ([n] :: aa :: lista);
                                                in
                                                  (fn rbt => snd (fold (fn xa => fn (x0a, rbta) => (xa, fold (fn OclTyCore_pre k => modify_defa [] k (fn la => flatten [map (fn OclTyCore_pre s => s) xa, la])) x0a rbta)) xs (x0, rbt)))
                                                end)
                           end)
          l emptya)
        emptya const_oclany
    end)
    x;

fun class_unflata x = (case class_unflat x of NONE => OclClass (const_oclany, [], []) | SOME tree => tree);

fun equal_ocl_association_type OclAssTy_composition OclAssTy_aggregation = false
  | equal_ocl_association_type OclAssTy_aggregation OclAssTy_composition = false
  | equal_ocl_association_type OclAssTy_association OclAssTy_aggregation = false
  | equal_ocl_association_type OclAssTy_aggregation OclAssTy_association = false
  | equal_ocl_association_type OclAssTy_association OclAssTy_composition = false
  | equal_ocl_association_type OclAssTy_composition OclAssTy_association = false
  | equal_ocl_association_type OclAssTy_native_attribute OclAssTy_aggregation = false
  | equal_ocl_association_type OclAssTy_aggregation OclAssTy_native_attribute = false
  | equal_ocl_association_type OclAssTy_native_attribute OclAssTy_composition = false
  | equal_ocl_association_type OclAssTy_composition OclAssTy_native_attribute = false
  | equal_ocl_association_type OclAssTy_native_attribute OclAssTy_association = false
  | equal_ocl_association_type OclAssTy_association OclAssTy_native_attribute = false
  | equal_ocl_association_type OclAssTy_aggregation OclAssTy_aggregation = true
  | equal_ocl_association_type OclAssTy_composition OclAssTy_composition = true
  | equal_ocl_association_type OclAssTy_association OclAssTy_association = true
  | equal_ocl_association_type OclAssTy_native_attribute OclAssTy_native_attribute = true;

fun tyRole_update tyRolea (Ocl_multiplicity_ext (tyMult, tyRole, tyCollect, more)) = Ocl_multiplicity_ext (tyMult, tyRolea tyRole, tyCollect, more);

fun oclAss_type (Ocl_association_ext (oclAss_type, oclAss_relation, more)) = oclAss_type;

fun map_find_aux accu f l = (case l of [] => rev accu | x :: xs => (case f x of NONE => map_find_aux (x :: accu) f xs | SOME xa => fold (fn a => fn b => a :: b) accu (xa :: xs)));

fun map_find x = map_find_aux [] x;

fun arrange_ass with_aggreg with_optim_ass l_c l_enum =
  let
    val l_syn = map_filter (fn a => (case a of META_enum _ => NONE | META_class_raw (_, _) => NONE | META_association _ => NONE | META_ass_class (_, _) => NONE | META_ctxt (_, _) => NONE | META_haskell _ => NONE
                                      | META_class_synonym aa => SOME aa | META_instance _ => NONE | META_def_base_l _ => NONE | META_def_state (_, _) => NONE | META_def_transition (_, _) => NONE | META_class_tree _ => NONE
                                      | META_flush_all _ => NONE | META_generic _ => NONE))
                  l_c;
    val l_class =
      map_filter (fn a => (case a of META_enum _ => NONE | META_class_raw (Floor1, cflat) => SOME cflat | META_class_raw (Floor2, _) => NONE | META_class_raw (Floor3, _) => NONE | META_association _ => NONE
                            | META_ass_class (Floor1, OclAssClass (_, aa)) => SOME aa | META_ass_class (Floor2, _) => NONE | META_ass_class (Floor3, _) => NONE | META_ctxt (_, _) => NONE | META_haskell _ => NONE
                            | META_class_synonym _ => NONE | META_instance _ => NONE | META_def_base_l _ => NONE | META_def_state (_, _) => NONE | META_def_transition (_, _) => NONE | META_class_tree _ => NONE | META_flush_all _ => NONE
                            | META_generic _ => NONE))
        l_c;
    val l_classa = map (fn x => classRaw_own_update (fn _ => map (map_prod id (map_enum_syn l_enum l_syn)) (classRaw_own x)) x) l_class;
    val l_ass = map_filter (fn a => (case a of META_enum _ => NONE | META_class_raw (_, _) => NONE | META_association aa => SOME aa | META_ass_class (Floor1, OclAssClass (ass, _)) => SOME ass | META_ass_class (Floor2, _) => NONE
                                      | META_ass_class (Floor3, _) => NONE | META_ctxt (_, _) => NONE | META_haskell _ => NONE | META_class_synonym _ => NONE | META_instance _ => NONE | META_def_base_l _ => NONE
                                      | META_def_state (_, _) => NONE | META_def_transition (_, _) => NONE | META_class_tree _ => NONE | META_flush_all _ => NONE | META_generic _ => NONE))
                  l_c;
    val oclMult = (fn l => fn set => Ocl_multiplicity_ext (l, NONE, set, ()));
    val (l_classb, l_ass0) =
      (if with_optim_ass
        then map_prod rev rev
               (fold (fn c => fn (l_classb, l_assa) =>
                       let
                         val default = [Set];
                         val f = (fn role => fn t => fn mult_out =>
                                   Ocl_association_ext (OclAssTy_native_attribute, OclAssRel [(classRaw_name c, oclMult [(Mult_star, NONE)] default), (t, tyRole_update (fn _ => SOME role) mult_out)], ()));
                         val a = fold (fn a => (case a of (role, OclTy_base_void) => (fn (l_own, aa) => ((role, OclTy_base_void) :: l_own, aa))
                                                 | (role, OclTy_base_boolean) => (fn (l_own, aa) => ((role, OclTy_base_boolean) :: l_own, aa)) | (role, OclTy_base_integer) => (fn (l_own, aa) => ((role, OclTy_base_integer) :: l_own, aa))
                                                 | (role, OclTy_base_unlimitednatural) => (fn (l_own, aa) => ((role, OclTy_base_unlimitednatural) :: l_own, aa))
                                                 | (role, OclTy_base_real) => (fn (l_own, aa) => ((role, OclTy_base_real) :: l_own, aa)) | (role, OclTy_base_string) => (fn (l_own, aa) => ((role, OclTy_base_string) :: l_own, aa))
                                                 | (role, OclTy_object t) => (fn (l_own, l) => (l_own, f role t (oclMult [(Mult_nat Code_Numeral.zero_natural, SOME (Mult_nat Code_Numeral.one_natural))] default) :: l))
                                                 | (role, OclTy_collection (mult, OclTy_base_void)) => (fn (l_own, aa) => ((role, OclTy_collection (mult, OclTy_base_void)) :: l_own, aa))
                                                 | (role, OclTy_collection (mult, OclTy_base_boolean)) => (fn (l_own, aa) => ((role, OclTy_collection (mult, OclTy_base_boolean)) :: l_own, aa))
                                                 | (role, OclTy_collection (mult, OclTy_base_integer)) => (fn (l_own, aa) => ((role, OclTy_collection (mult, OclTy_base_integer)) :: l_own, aa))
                                                 | (role, OclTy_collection (mult, OclTy_base_unlimitednatural)) => (fn (l_own, aa) => ((role, OclTy_collection (mult, OclTy_base_unlimitednatural)) :: l_own, aa))
                                                 | (role, OclTy_collection (mult, OclTy_base_real)) => (fn (l_own, aa) => ((role, OclTy_collection (mult, OclTy_base_real)) :: l_own, aa))
                                                 | (role, OclTy_collection (mult, OclTy_base_string)) => (fn (l_own, aa) => ((role, OclTy_collection (mult, OclTy_base_string)) :: l_own, aa))
                                                 | (role, OclTy_collection (mult, OclTy_object t)) => (fn (l_own, l) => (l_own, f role t mult :: l))
                                                 | (role, OclTy_collection (mult, OclTy_collection (ocl_multiplicity_extb, ocl_tya))) =>
                                                   (fn (l_own, aa) => ((role, OclTy_collection (mult, OclTy_collection (ocl_multiplicity_extb, ocl_tya))) :: l_own, aa))
                                                 | (role, OclTy_collection (mult, OclTy_pair (ocl_ty1, ocl_ty2))) => (fn (l_own, aa) => ((role, OclTy_collection (mult, OclTy_pair (ocl_ty1, ocl_ty2))) :: l_own, aa))
                                                 | (role, OclTy_collection (mult, OclTy_binding prod)) => (fn (l_own, aa) => ((role, OclTy_collection (mult, OclTy_binding prod)) :: l_own, aa))
                                                 | (role, OclTy_collection (mult, OclTy_arrow (ocl_ty1, ocl_ty2))) => (fn (l_own, aa) => ((role, OclTy_collection (mult, OclTy_arrow (ocl_ty1, ocl_ty2))) :: l_own, aa))
                                                 | (role, OclTy_collection (mult, OclTy_class_syn abr_string)) => (fn (l_own, aa) => ((role, OclTy_collection (mult, OclTy_class_syn abr_string)) :: l_own, aa))
                                                 | (role, OclTy_collection (mult, OclTy_enum abr_string)) => (fn (l_own, aa) => ((role, OclTy_collection (mult, OclTy_enum abr_string)) :: l_own, aa))
                                                 | (role, OclTy_collection (mult, OclTy_raw abr_string)) => (fn (l_own, aa) => ((role, OclTy_collection (mult, OclTy_raw abr_string)) :: l_own, aa))
                                                 | (role, OclTy_pair (ocl_ty1, ocl_ty2)) => (fn (l_own, aa) => ((role, OclTy_pair (ocl_ty1, ocl_ty2)) :: l_own, aa))
                                                 | (role, OclTy_binding prod) => (fn (l_own, aa) => ((role, OclTy_binding prod) :: l_own, aa))
                                                 | (role, OclTy_arrow (ocl_ty1, ocl_ty2)) => (fn (l_own, aa) => ((role, OclTy_arrow (ocl_ty1, ocl_ty2)) :: l_own, aa))
                                                 | (role, OclTy_class_syn abr_string) => (fn (l_own, aa) => ((role, OclTy_class_syn abr_string) :: l_own, aa))
                                                 | (role, OclTy_enum abr_string) => (fn (l_own, aa) => ((role, OclTy_enum abr_string) :: l_own, aa))
                                                 | (role, OclTy_raw abr_string) => (fn (l_own, aa) => ((role, OclTy_raw abr_string) :: l_own, aa))))
                                   (classRaw_own c) ([], l_assa);
                         val (l_own, aa) = a;
                       in
                         (classRaw_own_update (fn _ => rev l_own) c :: l_classb, aa)
                       end)
                 l_classa ([], []))
        else (l_classa, []));
    val (l_classc, l_assa) =
      (if with_aggreg
        then map_prod rev rev
               (fold (fn ass => fn (l_classc, l_assa) =>
                       (if equal_ocl_association_type (oclAss_type ass) OclAssTy_aggregation
                         then (fold_max (fn (_, (name_to, category_to)) =>
                                          (case tyRole category_to of NONE => (fn _ => id)
                                            | SOME role_to =>
                                              fold (fn (_, (name_from, _)) =>
                                                     map_find (fn cflat => (if equal (cl_name_to_string cflat) (ty_obj_to_string name_from)
                                                                             then SOME (classRaw_own_update
                                                                                         (fn _ => flatten [classRaw_own cflat, [(role_to, let
                      val ty = OclTy_object name_to;
                    in
                      (if single_multip category_to then ty else OclTy_collection (category_to, ty))
                    end)]])
                                                                                         cflat)
                                                                             else NONE)))))
                                 (oclAss_relation ass) l_classc,
                                l_assa)
                         else (l_classc, ass :: l_assa)))
                 l_ass (l_classb, []))
        else (l_classb, l_ass));
  in
    (l_classc, flatten [l_assa, l_ass0])
  end;

fun print_examp_oclbase x = (fn OclDefBase a => (start_map definition o map (snd o print_examp_oclbase_gen)) a) x;

val pRINT_examp_oclbase : (ocl_def_base_l -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_examp.print_examp_oclbase"), print_examp_oclbase);

val thy_def_base_l : (ocl_def_base_l, unit compiler_env_config_ext) embedding = Embed_theories [sectiona (SS_base (ST "BaseType")), pRINT_examp_oclbase];

val thy_flush_all : ('a, 'b) embedding = Embed_theories [];

fun d_output_header_force_update d_output_header_forcea
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = Compiler_env_config_ext
      (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_forcea d_output_header_force, d_output_auto_bootstrap,
        d_ocl_accessor, d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more);

fun rev_map f = foldl (fn l => fn x => f x :: l) [];

fun print_examp_def_st_defassoc_typecheck_gen l env =
  [raise_ml (case fold (fn OclDefCoreBinding name => fn (la, rbt) =>
                         (((if is_none (assoca name (d_input_instance env)) then (fn a => (Error, name) :: a) else id) o (if is_none (lookupb rbt name) then id else (fn a => (Warning, name) :: a))) la, inserta name () rbt))
                    l ([], emptya)
              of ([], _) => []
              | (a :: lista, _) =>
                rev_map (fn aa => (case aa of (Warning, n) => (Warning, flattenb (SS_base (ST "Duplicate variables on rhs: ")) n) | (Error, n) => (Error, flattenb (SS_base (ST "Extra variables on rhs: ")) n))) (a :: lista))
     (SS_base (ST " error(s)"))];

fun mla x = Theory_ML x;

fun print_examp_def_st_defassoc_typecheck x = (fn OclDefSt (_, l) => fn env => (map mla (print_examp_def_st_defassoc_typecheck_gen l env), d_output_header_force_update (fn _ => true) env)) x;

fun fold_list_attr cast_from f l_attr accu = (case l_attr of OclAttrNoCast x => f cast_from x accu | OclAttrCast (c_from, l_attra, x) => fold_list_attr (SOME c_from) f l_attra (f cast_from x accu));

fun fold_instance_singlea f ocli = fold_list_attr (inst_tya ocli) f (inst_attr ocli);

fun fold_data_shallow f_str f_self f x accu = (case x of ShallB_term _ => accu | ShallB_str s => f (f_str s) accu | ShallB_self s => f (f_self s) accu | ShallB_list l => fold (fold_data_shallow f_str f_self f) l accu);

fun fold_instance_single_name ocli =
  let
    val b = (fn s => Term_basic [s]);
  in
    (case inst_attr_with ocli of NONE => id | SOME s => (fn a => b s :: a)) o
      fold_instance_singlea (fn _ => fold (fn (_, a) => let
                                                          val (_, aa) = a;
                                                        in
                                                          fold_data_shallow SOME (fn _ => NONE) (fn ab => (case ab of NONE => id | SOME s => (fn ac => b s :: ac))) aa
                                                        end))
        ocli
  end;

fun term_paira l = (case l of [] => Term_basic [SS_base (ST "()")] | _ :: _ => Term_paren (SS_base (ST "("), SS_base (ST ")"), term_binopa (SS_base (ST ",")) l));

fun print_examp_def_st_typecheck_var x =
  (fn OclDefSt (name, l) =>
    let
      val b = (fn s => Term_basic [s]);
      val l_var0 = [name];
      val n = flattenb (SS_base (ST "_")) (String_concatWith (SS_base (ST "_"), l_var0));
    in
      (fn a => ([definition (Definitiona (Term_rewrite (term_app (flattenb (SS_base (ST "typecheck_state_bad_head_on_lhs")) n) (map b l_var0), SS_base (ST "="), term_paira []))),
                  definition (Definitiona (Term_rewrite
                                            (b (flattenb (SS_base (ST "typecheck_state_extra_variables_on_rhs")) n), SS_base (ST "="),
                                              term_paira (fold (fn aa => (case aa of OclDefCoreAdd ab => fold_instance_single_name ab | OclDefCoreBinding s => (fn ab => b s :: ab))) l []))))],
                 a))
    end)
    x;

val floor1_PRINT_examp_def_st_typecheck_var : (ocl_def_state -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_examp.print_examp_def_st_typecheck_var"), print_examp_def_st_typecheck_var);

fun to_String x = SS_base x;

fun print_examp_def_st_dom_name name = flattena [SS_base (ST "dom_"), name];

fun lemmas_simp x = (fn a => Lemmas_simp_thm (true, x, a));

fun lemmasa x = Theory_lemmas x;

fun print_examp_def_st_dom_lemmas x = (fn _ => fn env => (map lemmasa let
                                                                        val (name, _) = hd (d_input_state env);
                                                                      in
                                                                        [lemmas_simp (SS_base (ST "")) [thma (print_examp_def_st_dom_name (to_String name))]]
                                                                      end,
                                                           env))
                                        x;

fun print_examp_def_st_locale_sort env l = merge_uniquea (equal_list equal_integer) (to_list o inst_name) (map (fn OclDefCoreBinding name => let
                         val SOME n = assoca name (d_input_instance env);
                       in
                         [flip n]
                       end)
                                                                                                            l);

fun print_examp_def_st_def_interp x =
  (fn OclDefSt (n, l) => fn env =>
    (map definition let
                      val a = (fn f => fn xa => term_app f [xa]);
                      val b = (fn s => Term_basic [s]);
                      val var_tau = SS_base (ST "\092<tau>");
                      val (oid, l_fix_assum) = filter_locale_interp (print_examp_def_st_locale_sort env l);
                    in
                      [Definitiona (Term_rewrite (a (flattenb (SS_base (ST "state_interpretation_")) n) (b var_tau), SS_base (ST "="), term_app (print_examp_def_st_locale_name n) (flatten [oid, flatten l_fix_assum])))]
                    end,
      env))
    x;

val floor2_PRINT_examp_def_st_def_interp : (ocl_def_state -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor2_examp.print_examp_def_st_def_interp"), print_examp_def_st_def_interp);

fun print_examp_def_st_mapsto_gen f = map (fn (cpt, ocore) => let
                                                                val b = (fn s => Term_basic [s]);
                                                                val a = let
                                                                          val OclDefCoreBinding (name, ocli) = ocore;
                                                                        in
                                                                          (ocli, SOME (b (print_examp_instance_name (fn s => flattenb s (isub (inst_ty ocli))) name)))
                                                                        end;
                                                                val (aa, ba) = a;
                                                              in
                                                                f (cpt, ocore) aa ba
                                                              end);

fun print_examp_def_st_perm_name name = flattena [SS_base (ST "perm_"), name];

fun meth_gen_simp_onlya l = Method_simp_only (map Thms_mult l);

fun simp_all_only l = Method_all (meth_gen_simp_onlya l);

fun add_hierarchyb f = (fn isub_name => fn name => fn l_attr => fn l_inh => fn l_subtree => f isub_name name l_attr (of_inh l_inh) (of_sub l_subtree));

fun map_class_gen f = fst o fold_class_gen (fn isub_name => fn name => fn l_attr => fn l_inh => fn l_subtree => fn last_d => fn () => (f isub_name name l_attr l_inh l_subtree last_d, ())) ();

fun map_class_gen_hb f x = map_class_gen (add_hierarchyb f) x;

fun map_class_gen_h_inh f =
  map_class_gen_hb
    (fn isub_name => fn name => fn _ => fn l_inh => fn l_subtree => fn _ =>
      let
        val l_mem = (fn l => member (equal_list equal_integer) (map (fn OclClass (n, _, _) => to_list n) l));
      in
        f isub_name name (fn n => let
                                    val na = to_list n;
                                  in
                                    (if equal_lista equal_integer na (to_list name) then EQ else (if l_mem (of_linh l_inh) na then GT else (if l_mem l_subtree na then LT else UN)))
                                  end)
      end);

fun simp_all_add l = Method_all (meth_gen_simp_add2 [] l);

fun meth_gen_simp_add_del l1 l2 = method_simp_add_del (map (Thms_single o Thm_thm) l1) (map (Thms_single o Thm_thm) l2);

fun simp_add_del l1 l2 = Method_one (meth_gen_simp_add_del l1 l2);

fun simp_onlya l = Method_one (meth_gen_simp_onlya l);

fun symmetric x = Thm_symmetric x;

fun meth_gen_simp_only l = Method_simp_only (map Thms_single l);

fun simp_only l = Method_one (meth_gen_simp_only l);

val const_oclastype : abr_string = SS_base (ST "OclAsType");

val meth_gen_simp : semi_method_simp = method_simp_add_del [] [];

val simp_all : semi_method = Method_all meth_gen_simp;

fun unfolding x = (Command_unfolding o map Thms_single) x;

fun gen_pre_post0 f_tit f_assum spec f_lemma meth_last =
  let
    val b = (fn s => Term_basic [s]);
    val d = hol_definition;
    val f_allinst = flattenb (SS_base (ST "OclAllInstances_"));
    val f_tita = f_tit o f_allinst;
    val var_pre_post = SS_base (ST "pre_post");
    val var_mk = SS_base (ST "mk");
    val var_st = SS_base (ST "st");
    val s_generic = SS_base (ST "generic");
    val lem_gen = f_tita s_generic;
    val mk_pre_post = (fn pre_post => fn at_when => fn f_cpl => let
                                                                  val s_allinst = f_allinst at_when;
                                                                in
                                                                  Lemma_assumes (f_tita at_when, f_assum, spec (term_app s_allinst) f_cpl pre_post, [unfolding [thma (d s_allinst)]], by (rule (thma lem_gen) :: meth_last))
                                                                end);
  in
    [f_lemma lem_gen f_assum (spec (fn l => term_app (f_allinst s_generic) (b var_pre_post :: l)) (fn e => term_app var_mk [e]) var_pre_post) var_pre_post var_mk var_st,
      mk_pre_post (SS_base (ST "snd")) (SS_base (ST "at_post")) (term_pair (b var_st)), mk_pre_post (SS_base (ST "fst")) (SS_base (ST "at_pre")) (fn e => term_pair e (b var_st))]
  end;

fun term_And x f = Term_bind (SS_base (ST "\092<And>"), Term_basic [x], f x);

fun method_subst_l x = (fn a => Method_subst (false, x, a));

fun subst_l x = method_subst_l x;

fun subst x = subst_l [SS_base (ST "0")] x;

fun blast x = Method_blast x;

fun term_oclset l = (case l of [] => Term_basic [SS_base (ST "Set{}")] | _ :: _ => Term_paren (SS_base (ST "Set{"), SS_base (ST "}"), term_binopa (SS_base (ST ",")) l));

fun thms x = Thm_thms x;

val simp : semi_method = Method_one meth_gen_simp;

fun print_examp_def_st_allinst x =
  (fn _ => fn env =>
    (map lemmaa let
                  val a = (fn f => fn xa => term_app f [xa]);
                  val b = (fn s => Term_basic [s]);
                  val d = hol_definition;
                  val (name_st, expr_app) = map_prod to_String (print_examp_def_st_mapsto_gen (fn (_, ocore) => fn ocli => fn _ => (ocore, (ocli, let
                              val OclDefCoreBinding (name, _) = ocore;
                            in
                              b name
                            end))))
                                              (hd (d_input_state env));
                in
                  map_class_gen_h_inh
                    (fn isub_name => fn name => fn compare =>
                      let
                        val in_name = (fn ocli => b (print_examp_instance_name (fn s => flattenb s (isub (inst_ty ocli))) (inst_name ocli)));
                        val in_pers = (fn ocli => a name (a (flattenb datatype_in (isub (inst_ty ocli))) (in_name ocli)));
                        val expr_appa =
                          map (fn (ocore, (ocli, exp)) =>
                                ((ocore, ocli),
                                  let
                                    val asty = (fn e => term_postunary e (b (dot_astype name)));
                                    val exp_annot =
                                      [([flattena [const_oclastype, isub name, SS_base (ST "_"), inst_ty ocli]],
                                         ((asty let
                                                  val OclDefCoreBinding _ = ocore;
                                                in
                                                  exp
                                                end,
                                            SOME let
                                                   val und = (fn e => term_lam (SS_base (ST "_")) (fn _ => term_some e));
                                                 in
                                                   Term_rewrite (und (in_pers ocli), SS_base (ST "="), term_warning_parenthesis (asty (term_parenthesis (term_annot (und (term_some (in_name ocli))) (wrap_oclty (inst_ty ocli))))))
                                                 end),
                                           (true, ocore)))];
                                  in
                                    (case compare (inst_ty ocli) of EQ => [([], ((exp, NONE), (false, ocore)))] | LT => exp_annot
                                      | GT => (case fold_list_attr NONE (fn ty => fn _ => (fn aa => ty :: aa)) (inst_attr ocli) [] of [] => [] | NONE :: _ => [] | SOME name2 :: _ => (if equal name name2 then exp_annot else []))
                                      | UN => [])
                                  end))
                            expr_app;
                        val c = map_prod (simp_add_del [] o flatten) (map_prod split id o split) (split (flatten (map snd expr_appa)));
                        val (l_asty, ca) = c;
                        val (cb, e) = ca;
                      in
                        let
                          val (l_spec, l_speca) = cb;
                        in
                          (fn l_body =>
                            let
                              val only_assms = (fn aa => simp_all_only [thms (SS_base (ST "assms"))] :: aa);
                              val l_assum =
                                flatten [map (fn (aa, cc) => let
                                                               val (_, ocli) = aa;
                                                             in
                                                               (fn l => (SS_base (ST ""), (true, Term_rewrite (in_pers ocli, (if null l then SS_base (ST "=") else SS_base (ST "\092<noteq>")), b (SS_base (ST "None"))))))
                                                             end
                                                               cc)
                                           expr_appa,
                                          map_filter (map_optiona (fn xa => (SS_base (ST ""), (true, xa)))) l_speca];
                            in
                              gen_pre_post0 (fn s => flattena [name_st, SS_base (ST "_"), s, SS_base (ST "_exec_"), name]) l_assum
                                (fn f_expr => fn f_mk => fn _ => term_binop (f_mk (b name_st)) (SS_base (ST "\092<Turnstile>")) (term_binop (f_expr [b name]) (SS_base (ST "\092<doteq>")) (term_oclset l_spec)))
                                (fn lem_tit => fn lem_assum => fn lem_spec => fn var_pre_post => fn var_mk => fn _ =>
                                  Lemma_assumes
                                    (lem_tit, flatten [lem_assum, [(SS_base (ST ""), (true, term_And (SS_base (ST "a")) (fn var_a => Term_rewrite (a var_pre_post (a var_mk (b var_a)), SS_base (ST "="), b var_a))))]], lem_spec,
                                      map applya (flatten [[[subst (thma (print_examp_def_st_perm_name name_st))]], [[simp_only (map (thma o d) (SS_base (ST "state.make") :: map (fn (_, OclDefCoreBinding (n, _)) => n) l_body))]],
                                                            fst (mapM (fn expr => fn l_specb =>
                                                                        let
                                                                          val mk_StrictRefEq_including =
                                                                            (fn l => rule (thma (SS_base (ST "const_StrictRefEq\092<^sub>S\092<^sub>e\092<^sub>t_including"))) :: l_asty :: l_asty :: simp :: l);
                                                                          val (state_update_vs_allInstances_generic, (l_specc, l_OclIncluding_cong)) =
                                                                            let
                                                                              val f = (fn aa => simp :: aa);
                                                                            in
                                                                              (case expr of ((_, _), []) =>
                                                                                           (SS_base (ST "state_update_vs_allInstances_generic_ntc"),
                                                                                             (l_specb, f (if null l_specb then [rule (thma (SS_base (ST "const_StrictRefEq\092<^sub>S\092<^sub>e\092<^sub>t_empty"))), simp]
                                                                                                           else mk_StrictRefEq_including [])))
                                                                                | ((_, _), _ :: _) =>
                                                                                  (SS_base (ST "state_update_vs_allInstances_generic_tc"),
                                                                                    (tl l_specb, blast NONE ::
                                                                                                   f let
                                                                                                       val fa = (fn l => optiona [simp_only [symmetric (thms (SS_base (ST "assms")))]] ::
     simp_add (map d [SS_base (ST "valid"), SS_base (ST "OclValid"), SS_base (ST "bot_fun"), SS_base (ST "bot_option")]) :: l);
                                                                                                     in
                                                                                                       mk_StrictRefEq_including (rule (thma (SS_base (ST "OclIncluding_cong"))) :: fa (fa []))
                                                                                                     end)))
                                                                            end;
                                                                        in
                                                                          (subst (thma state_update_vs_allInstances_generic) ::
                                                                             simp :: simp :: optiona [print_examp_def_st_locale_metis] :: simp_onlya [thms (SS_base (ST "assms"))] :: l_OclIncluding_cong,
                                                                            l_specc)
                                                                        end)
                                                                  expr_appa l_spec),
                                                            [[rule (thma (SS_base (ST "state_update_vs_allInstances_generic_empty")))]]]),
                                      by (if null l_spec then [simp] else only_assms [optiona [simp_all_add [d (flattena [isub_name const_oclastype, SS_base (ST "_\092<AA>")])]]])))
                                let
                                  val l = [simp_all];
                                in
                                  (if null l_assum then l else only_assms l)
                                end
                            end)
                        end
                          e
                      end)
                    let
                      val SOME class_spec = d_input_class env;
                    in
                      class_spec
                    end
                end,
      env))
    x;

fun print_examp_def_st_locale x = (fn OclDefSt (n, l) => fn env => (print_examp_def_st_locale_make (print_examp_def_st_locale_name n) [] (print_examp_def_st_locale_sort env l), env)) x;

fun print_examp_def_st_mapsto l =
  bind id id (print_examp_def_st_mapsto_gen
               (fn (cpt, _) => fn ocli => map_optiona (fn exp => term_binop (term_oid var_oid_uniq (oidGetInh cpt)) (SS_base (ST "\092<mapsto>")) (term_app (flattenb datatype_in (isub (inst_ty ocli))) [exp]))) l);

val var_assocs : abr_string = SS_base (ST "assocs");

fun print_examp_def_st_perm x =
  (fn _ => fn env =>
    (map lemmaa let
                  val (name, l_st) = map_prod to_String id (hd (d_input_state env));
                  val expr_app = print_examp_def_st_mapsto (rev l_st);
                  val b = (fn s => Term_basic [s]);
                  val d = hol_definition;
                  val (l_app, l_last) =
                    (case l_st of [] => ([], by [simp_add [d name]]) | [_] => ([], by [simp_add [d name]])
                      | _ :: _ :: _ =>
                        ([simp_add [d name]] ::
                           flatten (map (fn i_max => map (fn i => [subst_l (map nat_to_digit10 [minus_nat i_max i]) (thma (SS_base (ST "fun_upd_twist"))), print_examp_def_st_locale_metis]) (upt zero_nata i_max))
                                     (upt one_nat (size_list l_st))),
                          by [simp]));
                in
                  (case expr_app of NONE => []
                    | SOME expr_appa =>
                      [Lemma (print_examp_def_st_perm_name name, [Term_rewrite (b name, SS_base (ST "="), term_app (SS_base (ST "state.make")) [term_app (SS_base (ST "Map.empty")) expr_appa, term_app var_assocs [b name]])], l_app,
                               l_last)])
                end,
      env))
    x;

fun term_set l = (case l of [] => Term_basic [SS_base (ST "{}")] | _ :: _ => Term_paren (SS_base (ST "{"), SS_base (ST "}"), term_binopa (SS_base (ST ",")) l));

fun print_examp_def_st_dom x =
  (fn _ => fn env =>
    (map lemmaa let
                  val (name, l_st) = map_prod to_String id (hd (d_input_state env));
                  val a = (fn f => fn xa => term_app f [xa]);
                  val b = (fn s => Term_basic [s]);
                  val d = hol_definition;
                in
                  [Lemma (print_examp_def_st_dom_name name, [Term_rewrite (a (SS_base (ST "dom")) (a (SS_base (ST "heap")) (b name)), SS_base (ST "="), term_set (map (fn (cpt, _) => term_oid var_oid_uniq (oidGetInh cpt)) l_st))], [],
                           by [auto_simp_add [d name]])]
                end,
      env))
    x;

fun d_input_state_update d_input_statea
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = Compiler_env_config_ext
      (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_statea d_input_state, d_output_header_force, d_output_auto_bootstrap,
        d_ocl_accessor, d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more);

val ocl_instance_single_empty : unit ocl_instance_single_ext = Ocl_instance_single_ext (NONE, NONE, NONE, OclAttrNoCast [], ());

fun fold_instance_single f ocli = fold_list_attr (inst_ty0 ocli) (fn SOME a => f a) (inst_attr ocli);

fun print_examp_def_st_assoc_build_rbt_gen f rbt map_self map_username l_assoc =
  fold (fn (ocli, cpt) =>
         fold_instance_single
           (fn ty => fn l_attr =>
             let
               val (f_attr_ty, _) = rbt ty;
             in
               f ty (fold (fn (_, (name_attr, shall)) =>
                            (case f_attr_ty name_attr of NONE => id | SOME (OclTy_base_void, _) => id | SOME (OclTy_base_boolean, _) => id | SOME (OclTy_base_integer, _) => id | SOME (OclTy_base_unlimitednatural, _) => id
                              | SOME (OclTy_base_real, _) => id | SOME (OclTy_base_string, _) => id | SOME (OclTy_object (OclTyObj (OclTyCore_pre _, _)), _) => id
                              | SOME (OclTy_object (OclTyObj (OclTyCore ty_obj, _)), (_, _)) =>
                                modify_defa ([], ty_obj) name_attr
                                  (fn (l, accu) =>
                                    (case let
                                            val find_map = (fn a => (case a of ShallB_term _ => NONE | ShallB_str aa => map_username aa | ShallB_self aa => map_self aa | ShallB_list _ => NONE));
                                          in
                                            (case shall of ShallB_term _ => map_optiona (fn x => [x]) (find_map shall) | ShallB_str _ => map_optiona (fn x => [x]) (find_map shall)
                                              | ShallB_self _ => map_optiona (fn x => [x]) (find_map shall) | ShallB_list la => (if list_ex (fn x => is_none (find_map x)) la then NONE else SOME (map_filter find_map la)))
                                          end
                                      of NONE => (l, accu) | SOME oid => (map (map oidGetInh) [[cpt], oid] :: l, accu)))
                              | SOME (OclTy_collection (_, _), _) => id | SOME (OclTy_pair (_, _), _) => id | SOME (OclTy_binding _, _) => id | SOME (OclTy_arrow (_, _), _) => id | SOME (OclTy_class_syn _, _) => id
                              | SOME (OclTy_enum _, _) => id | SOME (OclTy_raw _, _) => id))
                      l_attr)
             end)
           ocli)
    l_assoc emptya;

fun print_examp_def_st_assoc_build_rbt x = print_examp_def_st_assoc_build_rbt_gen (modify_defa emptya) x;

val var_map_of_list : abr_string = SS_base (ST "map_of_list");

fun term_lista f l = term_list (map f l);

fun foldb f = folda (fn c => f (SS_base (STa c)));

fun print_examp_def_st_assoc rbt map_self map_username l_assoc =
  let
    val b = (fn s => Term_basic [s]);
    val rbta = print_examp_def_st_assoc_build_rbt rbt map_self map_username l_assoc;
  in
    term_app var_map_of_list
      [term_list (foldb (fn name => foldb (fn name_attr => fn (l_attr, ty_obj) => fn l_cons =>
                                            let
                                              val cpt_from = tyObjN_ass_switch (tyObj_from ty_obj);
                                            in
                                              term_pair (Term_basic [print_access_oid_uniq_name cpt_from (fn s => flattenb s (isub name)) name_attr])
                                                (term_app (SS_base (ST "List.map"))
                                                  [term_binop let
                                                                val var_x = SS_base (ST "x");
                                                                val var_y = SS_base (ST "y");
                                                              in
                                                                term_lambdas0 (term_pair (b var_x) (b var_y)) (term_list [b var_x, b var_y])
                                                              end
                                                     (SS_base (ST "o")) (b (print_access_choose_name (tyObj_ass_arity ty_obj) cpt_from (tyObjN_ass_switch (tyObj_to ty_obj)))),
                                                    term_lista (term_lista (term_lista (term_oid var_oid_uniq))) l_attr]) ::
                                                l_cons
                                            end))
                   rbta [])]
  end;

fun init_map_class2 (C1_, C2_, C3_) env l =
  let
    val rbt_str = bulkload (equal_list equal_integer) (map (fn (k, a) => let
                                                                           val (_, aa) = a;
                                                                         in
                                                                           (to_lista k, aa)
                                                                         end)
                                                        (d_input_instance env));
  in
    (rbt_of_class (C1_, C2_, C3_) env,
      (lookupa equal_internal_oid
         (fst (fold (fn ocli => fn (rbt_nat, accu) =>
                      ((case lookupb rbt_str (case inst_attr_with ocli of NONE => inst_name ocli | SOME s => s) of NONE => rbt_nat | SOME oid_start => insert equal_internal_oid (Oid accu) oid_start rbt_nat),
                        succ (one_natural, plus_natural) accu))
                l (emptya, Code_Numeral.zero_natural))),
        lookupb rbt_str))
  end;

fun unique B_ f l = map_filter id (fst (mapM (fn (cpt, v) => fn rbt => let
                                                                         val f_cpt = f cpt;
                                                                       in
                                                                         (if is_none (lookupa B_ rbt f_cpt) then (SOME (cpt, v), insert B_ f_cpt () rbt) else (NONE, rbt))
                                                                       end)
                                         l emptya));

fun print_examp_def_st2 x =
  (fn OclDefSt (name, l) => fn env =>
    let
      val (la, l_st) =
        let
          val b = (fn s => Term_basic [s]);
          val la = map (fn OclDefCoreBinding namea => map_optiona (fn a => (namea, a)) (assoca namea (d_input_instance env))) l;
          val (rbt, (map_self, map_username)) = init_map_class2 (one_natural, plus_natural, zero_natural) env (map (fn a => (case a of NONE => ocl_instance_single_empty | SOME (_, (ocli, _)) => ocli)) la);
          val (l_st, l_assoc) = mapM (fn o_n => fn l_assoc => (case o_n of NONE => ([], l_assoc) | SOME (namea, (ocli, cpt)) => ([(cpt, OclDefCoreBinding (namea, ocli))], (ocli, cpt) :: l_assoc))) la [];
          val l_sta = unique equal_internal_oid oidGetInh (flatten l_st);
        in
          ([Definitiona (Term_rewrite
                          (b name, SS_base (ST "="),
                            term_app (SS_base (ST "state.make"))
                              [term_app (SS_base (ST "Map.empty")) (case print_examp_def_st_mapsto l_sta of NONE => [] | SOME lb => lb), print_examp_def_st_assoc (snd o rbt) map_self map_username l_assoc]))],
            l_sta)
        end;
    in
      (map definitiona la, d_input_state_update (fn _ => (to_String_b_a_s_e name, l_st) :: d_input_state env) env)
    end)
    x;

fun print_examp_def_st1_gen x =
  (fn OclDefSt (name, l) => bootstrap_floora (fn (la, accu) => fn _ => (flatten [map META_all_meta_embedding la], accu)) let
     val (l_inst, l_defst) = print_examp_def_st0 name l;
     val la = [META_def_state (Floor2, OclDefSt (name, l_defst))];
   in
     (if null l_inst then (la, id) else (META_instance (OclInstance l_inst) :: la, print_examp_increase_oid l_inst))
   end)
    x;

fun print_examp_def_st1 s = fst o print_examp_def_st1_gen s;

val floor1_PRINT_examp_def_st1 : (ocl_def_state -> unit compiler_env_config_ext -> all_meta list * unit compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_examp.print_examp_def_st1"), print_examp_def_st1);

fun thy_def_state x =
  (fn a => (case a of Floor1 => Embed_theories [sectiona (SS_base (ST "State (Floor 1)")), floor1_PRINT_examp_def_st_typecheck_var, floor1_PRINT_examp_def_st1]
             | Floor2 => Embed_locale ([sectiona (SS_base (ST "State (Floor 2)"))], print_examp_def_st_locale,
                                        [print_examp_def_st2, print_examp_def_st_dom, print_examp_def_st_dom_lemmas, print_examp_def_st_perm, print_examp_def_st_allinst, print_examp_def_st_defassoc_typecheck],
                                        [floor2_PRINT_examp_def_st_def_interp])))
    x;

fun comp_env_save ast f_fold f env_accu = let
                                            val a = f_fold f env_accu;
                                            val (env, aa) = a;
                                          in
                                            (d_input_meta_update (fn _ => ast :: d_input_meta env) env, aa)
                                          end;

fun print_examp_instance_defassoc_typecheck_var x =
  (fn OclInstance l =>
    let
      val b = (fn s => Term_basic [s]);
      val l_var = fold (fn ocli => (case inst_namea ocli of NONE => id | SOME a => (fn ba => a :: ba))) l [];
      val n = flattenb (SS_base (ST "_")) (String_concatWith (SS_base (ST "_"), l_var));
    in
      (fn a => ([definition (Definitiona (Term_rewrite (term_app (flattenb (SS_base (ST "typecheck_instance_bad_head_on_lhs")) n) (map b l_var), SS_base (ST "="), term_paira []))),
                  definition (Definitiona (Term_rewrite (b (flattenb (SS_base (ST "typecheck_instance_extra_variables_on_rhs")) n), SS_base (ST "="), term_lambdas l_var (term_paira (fold fold_instance_single_name l [])))))],
                 a))
    end)
    x;

val pRINT_examp_instance_defassoc_typecheck_var : (ocl_instance -> 'a -> all_meta list * 'a) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_examp.print_examp_instance_defassoc_typecheck_var"), print_examp_instance_defassoc_typecheck_var);

fun fold_e_r_r f e accu =
  (case e of Return_err_ty _ => f e accu | Return_err_ty_auto => f e accu | Return_ocl_null => accu | Return_ocl_invalid => f e accu | Return_object_variable _ => accu | Return_err_l l => fold (fold_e_r_r f) l accu);

fun str_of_def_base x = (fn a => (case a of OclDefInteger _ => SS_base (ST "Integer") | OclDefReal _ => SS_base (ST "Real") | OclDefString _ => SS_base (ST "String"))) x;

fun str_of_data_shallow e =
  (case e of ShallB_term a => str_of_def_base a | ShallB_str s => flattenb (SS_base (ST "\"")) (flattenb s (SS_base (ST "\""))) | ShallB_self _ => SS_base (ST "(*object_oid*)")
    | ShallB_list l => flattenb (SS_base (ST "[ ")) (flattenb (String_concatWith (SS_base (ST ", "), mapa str_of_data_shallow l)) (SS_base (ST " ]"))));

fun print_examp_def_st_assoc_build_rbt_gen_typecheck check_ty f_attr_none f_attr map_self map_username l_enum l accu =
  let
    val v_null = SS_base (ST "null");
    val v_invalid = SS_base (ST "invalid");
  in
    fst (fold (fn (ocli, cpt) => fn (la, rbt) =>
                let
                  val inst_name_ocli = inst_name ocli;
                  val lb = fold_instance_single
                             (fn ty => fn lb => fn accua =>
                               let
                                 val f_attra = f_attr ty;
                               in
                                 fst (fold (fn (pre_post, (name_attr, shall)) => fn (accub, rbta) =>
                                             let
                                               val f = (fn msg => fn a => (case a of NONE => SOME msg | SOME _ => NONE));
                                               val find_map =
                                                 (fn x => fold_data_shallow (fn s => (if equal s v_null orelse (equal s v_invalid orelse list_ex (fn OclEnum (_, a) => list_ex (equal s) a) l_enum) then NONE else f s (map_username s)))
                                                            (fn s => f (flattenb (SS_base (ST "self ")) (natural_to_digit10 let
        val Oid n = s;
      in
        n
      end))
                                                                       (map_self s))
                                                            (fn a => (case a of NONE => id | SOME aa => (fn b => aa :: b))) x []);
                                               val (accuc, rbtb) =
                                                 (case (case shall of ShallB_term _ => find_map shall | ShallB_str _ => find_map shall | ShallB_self _ => find_map shall | ShallB_list lc => flatten (map find_map lc))
                                                   of [] => (accub, rbta)
                                                   | a :: lista =>
                                                     ((if is_none pre_post
                                                        then (Error, flattena [SS_base (ST "Extra variables on rhs: "),
                                                                                String_concatWith (SS_base (ST ", "), map (fn s => flattenb (SS_base (ST "\"")) (flattenb s (SS_base (ST "\"")))) (a :: lista)),
                                                                                SS_base (ST " in the definition of \""), inst_name_ocli, SS_base (ST "\"")]) ::
                                                               accub
                                                        else accub),
                                                       rbta));
                                               val a = (if is_none (lookupb rbtb name_attr) then (accuc, inserta name_attr () rbtb)
                                                         else ((Warning, flattena [SS_base (ST "At least one unused variable \""), name_attr, SS_base (ST "\""), SS_base (ST " in the definition of \""), inst_name_ocli,
                                                                                    SS_base (ST "\"")]) ::
                                                                 accuc,
                                                                rbtb));
                                               val (accud, aa) = a;
                                             in
                                               ((if is_none (f_attra name_attr)
                                                  then (Error, flattena [SS_base (ST "Error in record input: \""), name_attr, SS_base (ST "\" is no proper field"), SS_base (ST " in the definition of \""), inst_name_ocli,
                                                                          SS_base (ST "\"")]) ::
                                                         accud
                                                  else accud),
                                                 aa)
                                             end)
                                       lb (accua, emptya))
                               end)
                             ocli (if equal inst_name_ocli v_null orelse (equal inst_name_ocli v_invalid orelse not (f_attr_none inst_name_ocli))
                                    then (Error, flattena [SS_base (ST "Bad head of lhs: existing constant \""), inst_name_ocli, SS_base (ST "\"")]) :: la else la);
                  val (lc, rbta) =
                    ((case check_ty ocli cpt of Return_val _ => lb
                       | Return_err err =>
                         fold_e_r_r (fn a => (case a of Return_err_ty (ty, obj) =>
                                                       (fn aa => (Error, flattena [SS_base (ST "Type unification failed: Clash of types \""), str_of_ty ty, SS_base (ST "\" and \""), str_of_data_shallow obj, SS_base (ST "\""),
                                                                                    SS_base (ST " in the definition of \""), inst_name_ocli, SS_base (ST "\"")]) ::
                                                                   aa)
                                               | Return_err_ty_auto => id | Return_ocl_null => id
                                               | Return_ocl_invalid => (fn aa => (Writeln, flattena [SS_base (ST "\"invalid\" returned"), SS_base (ST " in the definition of \""), inst_name_ocli, SS_base (ST "\"")]) :: aa)
                                               | Return_object_variable _ => id | Return_err_l _ => id))
                           err lb),
                      rbt);
                in
                  (if is_none (lookupb rbta inst_name_ocli) then (lc, inserta inst_name_ocli () rbta) else ((Error, flattena [SS_base (ST "Duplicate fixed variable(s): \""), inst_name_ocli, SS_base (ST "\"")]) :: lc, rbta))
                end)
          l (accu, emptya))
  end;

fun print_examp_def_st_assoc_build_rbt2 x = print_examp_def_st_assoc_build_rbt_gen (fn _ => id) x;

fun less_natural m n = Code_Numeral.integer_of_natural m < Code_Numeral.integer_of_natural n;

fun mk_instance_single_cpt map_username l = fst o mk_instance_single_cpt0 map_username l;

fun tyObj_ass_id (Ocl_ty_class_ext (tyObj_name, tyObj_ass_id, tyObj_ass_arity, tyObj_from, tyObj_to, more)) = tyObj_ass_id;

fun check_single x =
  (fn (name_attr, (oid, l_oid)) => fn l_mult => fn l =>
    let
      val la = (keys o bulkload equal_internal_oid o map (fn xa => (xa, ()))) l;
      val assoc = (fn xa => (case map_of equal_internal_oid l_oid xa of NONE => let
                                                                                  val Oid n = xa;
                                                                                in
                                                                                  flattena [SS_base (ST "/*"), natural_to_digit10 n, SS_base (ST "*/")]
                                                                                end
                              | SOME s => s));
      val attr_len = natural_of_nat (size_list la);
      val l_typed =
        map (fn (mult_min, mult_max0) =>
              let
                val mult_max = (case mult_max0 of NONE => mult_min | SOME mult_max => mult_max);
                val s_mult = (fn a => (case a of Mult_nat aa => natural_to_digit10 aa | Mult_star => SS_base (ST "*") | Mult_infinity => SS_base (ST "\092<infinity>")));
                val f = (fn s => flattena [SS_base (ST " // "), s, SS_base (ST " constraint ["), s_mult mult_min, (if is_none mult_max0 then SS_base (ST "") else flattena [SS_base (ST " .. "), s_mult mult_max]),
                                            SS_base (ST "] not satisfied")]);
              in
                map (fn (b, msg) =>
                      (b, flattena [assoc oid, SS_base (ST " "), (case name_attr of NONE => SS_base (ST "/* unnamed attribute */") | SOME a => flattenb (SS_base (ST ".")) a), SS_base (ST " \092<cong> Set{"),
                                     let
                                       val lb = map assoc la;
                                     in
                                       (if null lb then SS_base (ST "") else flattenb (SS_base (ST " ")) (flattenb (String_concatWith (SS_base (ST " , "), lb)) (SS_base (ST " "))))
                                     end,
                                     SS_base (ST "}"), (if b then SS_base (ST "") else f msg)]))
                  [((case mult_min of Mult_nat mult_mina => less_eq_natural mult_mina attr_len | Mult_star => true | Mult_infinity => true), SS_base (ST "minimum")),
                    ((case mult_max of Mult_nat a => less_eq_natural attr_len a | Mult_star => true | Mult_infinity => true), SS_base (ST "maximum"))]
              end)
          l_mult;
      val (stop, l_typeda) = (if list_ex (list_all fst) l_typed then (Warning, (if list_ex (list_ex (not o fst)) l_typed then map (filter (not o fst)) l_typed else [[hd (hd l_typed)]])) else (Error, map (filter (not o fst)) l_typed));
    in
      flatten (map (map (fn (b, a) => ((if b then Writeln else stop), a))) l_typeda)
    end)
    x;

fun choose_1 x = snd x;

fun choose_0 x = fst x;

fun deref_assocs_list B_ to_from oid s = concat (map_filter (fn x => (if member B_ (choose_0 (to_from x)) oid then SOME ((choose_1 o to_from) x) else NONE)) s);

fun check_single_ty rbt_init rbt l_attr_gen l_oid x =
  (fn (ty1, mult1) => fn (ty2, mult2) =>
    let
      val role1 = tyRole mult1;
      val role2 = tyRole mult2;
      val s = (fn [x0, x1] => (x0, x1));
      val sa = (fn [x0, x1] => (x0, x1));
      val sb = (fn [x0, x1] => (x0, x1));
      val a = (case let
                      val f = (fn g => fn a =>
                                (case a of NONE => NONE
                                  | SOME role1a => map_optiona (fn _ => let
                                                                          val (ty1a, (role1b, f_swap)) = g role1a;
                                                                        in
                                                                          (let
                                                                             val SOME (OclTy_object (OclTyObj (OclTyCore ty_obj, _)), (_, _)) = fst (rbt_init ty1a) role1b;
                                                                           in
                                                                             ty_obj
                                                                           end,
                                                                            f_swap (tyObj_from, tyObj_to))
                                                                        end)
                                                     (lookupb rbt role1a)));
                    in
                      (case role2 of NONE => f (fn role1a => (ty2, (role1a, (fn (a, b) => (b, a))))) role1
                        | SOME role2a => (case lookupb rbt role2a of NONE => f (fn _ => (ty1, (role2a, id))) role1 | SOME (_, ty_obj) => SOME (ty_obj, (tyObj_from, tyObj_to))))
                    end
                of NONE => ([role1, role2], ((mult1, mult2), []))
                | SOME (ty_obj, (f_from, f_to)) =>
                  let
                    val (o_from, o_to) = (f_from ty_obj, f_to ty_obj);
                  in
                    (let
                       val (name_from, name_to) = (tyObjN_role_name o_from, tyObjN_role_name o_to);
                     in
                       [name_from, name_to]
                     end,
                      ((tyObjN_role_multip o_from, tyObjN_role_multip o_to),
                        deref_assocs_list equal_internal_oid s x
                          (map (if equal_proda equal_natural equal_natural (tyObjN_ass_switch o_from, tyObjN_ass_switch o_to) (Code_Numeral.zero_natural, Code_Numeral.one_natural) then id else rev)
                            let
                              val SOME l_attr = l_attr_gen (tyObj_ass_id ty_obj);
                            in
                              l_attr
                            end)))
                  end);
      val (name, aa) = a;
      val (ab, b) = aa;
    in
      let
        val (mult_from, mult_to) = ab;
      in
        (fn l => fn acc => flatten [acc, check_single ((snd o sb) name, (x, l_oid)) ((snd o sa) [tyMult mult_from, tyMult mult_to]) l])
      end
        b
    end);

fun map_of_list A_ = foldl (fn map => fn (x, l1) => (case map x of NONE => fun_upd A_ map x (SOME l1) | SOME l0 => fun_upd A_ map x (SOME (concat [l0, l1])))) (fn _ => NONE);

fun nb_class e = let
                   val OclClass (_, _, l) = e;
                 in
                   suc (fold (plus_nat o nb_class) l zero_nata)
                 end;

fun find_inh name class =
  let
    val (_, SOME l) = fold_class (fn _ => fn name0 => fn _ => fn l_inh => fn _ => fn _ => fn accu => ((), (if is_none accu andalso equal name name0 then SOME (map (fn OclClass (n, _, _) => n) (of_inh l_inh)) else accu))) NONE class;
  in
    l
  end;

fun print_examp_instance_defassoc_typecheck_gen l_ocli env =
  let
    val l_enum = map_filter (fn a => (case a of META_enum aa => SOME aa | META_class_raw (_, _) => NONE | META_association _ => NONE | META_ass_class (_, _) => NONE | META_ctxt (_, _) => NONE | META_haskell _ => NONE
                                       | META_class_synonym _ => NONE | META_instance _ => NONE | META_def_base_l _ => NONE | META_def_state (_, _) => NONE | META_def_transition (_, _) => NONE | META_class_tree _ => NONE
                                       | META_flush_all _ => NONE | META_generic _ => NONE))
                   (d_input_meta env);
    val (l_spec1, l_spec2) = arrange_ass false true (fst (find_class_ass env)) l_enum;
  in
    (case class_unflat (l_spec1, l_spec2) of NONE => [raise_ml [(Error, SS_base (ST "The universe of classes contains a cycle"))] (SS_base (ST " error(s)"))]
      | SOME spec =>
        let
          val raise_ml_warn = (fn s => fn raise_mla => fn l => raise_mla ((Warning, s) :: l));
          val raise_mla =
            (if less_nat (nb_class spec) (plus_nat (size_list l_spec1) (if list_ex (fn c => equal (cl_name_to_string c) const_oclany) l_spec1 then zero_nata else one_nat))
              then raise_ml_warn
                     (flattenb (SS_base (ST "Some classes have been ignored because of duplications of classes, the absence of classes inheriting from OclAny or the presence of cycles.\092n"))
                       (flattenb (SS_base (ST "The classes considered for the generation are only:\092n  "))
                         (String_concatWith
                           (SS_base (ST ", "),
                             rev (fst (fold_class (fn _ => fn name => fn _ => fn _ => fn _ => fn a =>
                                                    (case a of [] => (fn aa => (name, aa))
                                                      | aa :: lista =>
                                                        (fn b => (flattenb name (flattenb (SS_base (ST "[")) (flattenb (String_concatWith (SS_base (ST ", "), map (fn OclClass (n, _, _) => n) (aa :: lista))) (SS_base (ST "]")))), b))))
                                        () spec))))))
              else id)
              raise_ml;
          val raise_mlb =
            (case entries (fold (fn c => fn l => snd (fold (fn (s, _) => fn (rbt, la) => (case lookupb rbt s of NONE => (inserta s () rbt, la) | SOME _ => (rbt, inserta s (cl_name_to_string c) la))) (classRaw_own c) (emptya, l)))
                            l_spec1 emptya)
              of [] => id
              | a :: lista =>
                raise_ml_warn
                  (flattenb (SS_base (ST "Duplicate constant declaration:\092n"))
                    (String_concatWith (SS_base (ST "\092n"), map (fn (s, name) => flattenb (SS_base (ST "  ")) (flattenb name (flattenb (SS_base (ST ": ")) (SS_base (STa s))))) (a :: lista)))))
              raise_mla;
          val raise_mlc =
            (case map fst (entries (fold (fn ass => fn accu =>
                                           let
                                             val OclAssRel l = oclAss_relationa ass;
                                           in
                                             snd (fold (fn (_, m) =>
                                                         (case tyRole m of NONE => id | SOME name => (fn (rbt, accua) => (case lookupb rbt name of NONE => (inserta name () rbt, accua) | SOME _ => (rbt, inserta name () accua)))))
                                                   l (emptya, accu))
                                           end)
                                     l_spec2 emptya))
              of [] => id
              | a :: lista =>
                raise_ml_warn (flattenb (SS_base (ST "Duplicate constant declaration in association:\092n")) (String_concatWith (SS_base (ST "\092n"), map (fn s => flattenb (SS_base (ST "  ")) (SS_base (STa s))) (a :: lista)))))
              raise_mlb;
          val enva = d_input_class_update (fn _ => SOME spec) env;
          val l_assoc = map_filter id l_ocli;
        in
          (if list_ex (fn ocli => is_none (inst_ty0 ocli)) l_assoc
            then [raise_mlc (map_filter (fn ocli => (if is_none (inst_ty0 ocli) then SOME (Error, flattenb (SS_base (ST "Missing type annotation in the definition of \"")) (flattenb (inst_name ocli) (SS_base (ST "\"")))) else NONE))
                              l_assoc)
                    (SS_base (ST " error(s)"))]
            else let
                   val (rbt_init0, (map_self, map_username)) = init_map_class (one_natural, plus_natural, zero_natural) enva (map (fn a => (case a of NONE => ocl_instance_single_empty | SOME ocli => ocli)) l_ocli);
                   val rbt_init = snd o rbt_init0;
                   val l_assoca = mk_instance_single_cpt map_username l_assoc enva;
                   val rbt = print_examp_def_st_assoc_build_rbt2 rbt_init map_self map_username l_assoca;
                   val l_attr_gen =
                     map_of_list equal_natural
                       (foldb (fn _ => fn (l_attr, ty_obj) =>
                                (fn a => (tyObj_ass_id ty_obj,
                                           map ((fn (x, y) => [x, y]) o (if less_natural (tyObjN_ass_switch (tyObj_from ty_obj)) (tyObjN_ass_switch (tyObj_to ty_obj)) then (fn [x0, x1] => (x0, x1)) else (fn [x0, x1] => (x1, x0))))
                                             l_attr) ::
                                           a))
                         rbt []);
                   val l_oid_gen = map (fn (ocli, oids) => (fst (hd (fold_instance_single (fn a => fn b => (fn c => (a, b) :: c)) ocli [])), (oidGetInh oids, inst_name ocli))) l_assoca;
                   val (_, l_oid) = split l_oid_gen;
                   val l_out = fold (fn (name, (x, _)) =>
                                      let
                                        val l = find_inh name spec;
                                        val f = (fn (ty1, mult1) => fn ty2 => fn accu =>
                                                  fst (fold (fn ty1a => fn (la, b) => (if b then (la, b) else (check_single_ty rbt_init rbt l_attr_gen l_oid x (ty1a, mult1) ty2 la, equal ty1a ty1)))
                                                        (if equal name ty1 then ty1 :: l else (if list_ex (equal ty1) l then l else [])) (accu, false)));
                                      in
                                        fold (fn ass => (case map (map_prod ty_obj_to_string id) (oclAss_relation ass) of [] => id | [_] => id | [t1, t2] => f t2 t1 o f t1 t2 | _ :: _ :: _ :: _ => id)) l_spec2
                                      end)
                                 l_oid_gen [];
                 in
                   [raise_mlc (flatten [rev (print_examp_def_st_assoc_build_rbt_gen_typecheck (fn ocli => fst o print_examp_instance_app_constr2_notmp_norec (snd o rbt_init0, (map_self, map_username)) (Term_basic []) ocli id)
                                              (fst o rbt_init0) (fst o rbt_init) map_self map_username l_enum l_assoca []),
                                         l_out])
                      (SS_base (ST " error(s)"))]
                 end)
        end)
  end;

fun print_examp_instance_defassoc_typecheck x = (fn OclInstance l => fn env => (map ml (print_examp_instance_defassoc_typecheck_gen (map SOME l) env), d_output_header_force_update (fn _ => true) env)) x;

val pRINT_examp_instance_defassoc_typecheck : (ocl_instance -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_examp.print_examp_instance_defassoc_typecheck"), print_examp_instance_defassoc_typecheck);

val var_deref_assocs_list : abr_string = SS_base (ST "deref_assocs_list");

fun term_case x = ((fn a => fn b => Term_fun_case (a, b)) o SOME) x;

fun ty_times x = (fn a => Typ_apply_bin (SS_base (ST "\092<times>"), x, a));

fun print_examp_instance_defassoc_gen name l_ocli env =
  (case d_ocl_semantics env
    of Gen_only_design =>
      (fn (rbt, (map_self, map_username)) =>
        let
          val a = (fn f => fn x => term_app f [x]);
          val b = (fn s => Term_basic [s]);
          val l_oclia = (if list_ex (fn (ocli, _) => is_none (inst_ty0 ocli)) l_ocli then [] else l_ocli);
        in
          [Definitiona (Term_rewrite
                         (name, SS_base (ST "="),
                           let
                             val var_oid_class = SS_base (ST "oid_class");
                             val var_to_from = SS_base (ST "to_from");
                             val var_oid = SS_base (ST "oid");
                             val a_l = (fn s => Typ_apply (Typ_base var_ty_list, [s]));
                           in
                             term_lambdas [var_oid_class, var_to_from, var_oid]
                               (Term_annot (term_case (term_app var_deref_assocs_list
                                                        [Term_annot (b var_to_from, ty_arrow (a_l (a_l (Typ_base const_oid))) let
          val t = a_l (Typ_base const_oid);
        in
          ty_times t t
        end),
                                                          term_annot (b var_oid) const_oid,
                                                          a (SS_base (ST "the")) (term_applys (print_examp_def_st_assoc (snd o rbt) map_self map_username l_oclia) [term_annot (b var_oid_class) const_oid])])
                                              [(b (SS_base (ST "Nil")), b (SS_base (ST "None"))), let
                                                                                                    val b_l = b (SS_base (ST "l"));
                                                                                                  in
                                                                                                    (b_l, a (SS_base (ST "Some")) b_l)
                                                                                                  end],
                                             Typ_apply (Typ_base (SS_base (ST "option")), [a_l (Typ_base const_oid)])))
                           end))]
        end)
    | Gen_only_analysis => (fn _ => []) | Gen_default => (fn _ => []));

fun print_examp_instance_oid thy_definition_hol l env =
  (map thy_definition_hol o flatten)
    let
      val (f1, f2) = ((fn var_oid => fn _ => fn _ => var_oid), (fn _ => fn _ => fn cpt => term_oid (SS_base (ST "")) (oidGetInh cpt)));
    in
      map (fn (ocli, cpt) =>
            (if fold (fn (_, (_, cpt0)) => fn b => b orelse equal_internal_oida (oidGetInh cpt0) (oidGetInh cpt)) (d_input_instance env) false then []
              else let
                     val var_oid = term_oid var_oid_uniq (oidGetInh cpt);
                     val isub_name = (fn s => flattenb s (isub (inst_ty ocli)));
                   in
                     [Definitiona (Term_rewrite (f1 var_oid isub_name ocli, SS_base (ST "="), f2 ocli isub_name cpt))]
                   end))
        l
    end;

fun print_examp_instance_defassoc x =
  (fn OclInstance l => fn env =>
    let
      val (rbt, (map_self, map_username)) = init_map_class (one_natural, plus_natural, zero_natural) env l;
      val la = mk_instance_single_cpt map_username l env;
    in
      (append (print_examp_instance_oid definition la env) (map definition (print_examp_instance_defassoc_gen (term_oid var_inst_assoc (oidGetInh (d_ocl_oid_start env))) la env (rbt, (map_self, map_username)))), env)
    end)
    x;

val pRINT_examp_instance_defassoc : (ocl_instance -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_examp.print_examp_instance_defassoc"), print_examp_instance_defassoc);

val pRINT_examp_instance : (ocl_instance -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_examp.print_examp_instance"), print_examp_instance);

val thy_instance : (ocl_instance, unit compiler_env_config_ext) embedding =
  Embed_theories [sectiona (SS_base (ST "Instance")), pRINT_examp_instance_defassoc_typecheck_var, pRINT_examp_instance_defassoc, pRINT_examp_instance, pRINT_examp_instance_defassoc_typecheck];

fun d_hsk_constr_update d_hsk_constra
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = Compiler_env_config_ext
      (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
        d_ocl_HO_type, d_hsk_constra d_hsk_constr, d_output_sorry_dirty, more);

fun hsk_name0 flatten = (fn l_name => fn a => (case a of QName (ThyName n0, n1) => (case find (fn (n1a, _) => equal n0 n1a) l_name of NONE => flatten n0 n1 | SOME (_, NONE) => n1 | SOME (_, SOME n0a) => flatten n0a n1) | Name n => n));

fun hsk_name x = hsk_name0 (fn n0 => fn n1 => flattena [n0, SS_base (ST "."), n1]) x;

fun hsk_namea names = mk_quote o hsk_name names;

fun hsk_typespec names = (fn TypeSpec (l, n) => (hsk_name names n, map (hsk_namea names) l));

fun hsk_nameb x = hsk_name0 (fn _ => id) x;

fun term_stringa s = Term_basic [flattena [SS_base (ST "\092"), SS_base (ST "<open>"), s, SS_base (ST "\092"), SS_base (ST "<close>")]];

fun term_stringb f s = Term_apply (f, [term_stringa s]);

fun hsk_type names e =
  (case e of Typea (n, a) => (case a of [] => Typ_base (hsk_name names n) | aa :: lista => Typ_apply (Typ_base (hsk_name names n), mapa (hsk_type names) (aa :: lista)))
    | Func (t1, t2) => Typ_apply (hsk_type names t1, [hsk_type names t2]) | TVar n => Typ_base (hsk_namea names n));

fun lex_bool_false (Lexical_ext (lex_list_cons, lex_bool_false, lex_string, more)) = lex_bool_false;

fun lex_list_cons (Lexical_ext (lex_list_cons, lex_bool_false, lex_string, more)) = lex_list_cons;

fun lex_string (Lexical_ext (lex_list_cons, lex_bool_false, lex_string, more)) = lex_string;

fun hsk_literal str = (fn a => (case a of Int n => Term_basic [natural_to_digit10 n] | Stringa aa => str aa));

fun hsk_term lexi names t =
  (case t of Literal a => hsk_literal (lex_string lexi) a
    | Const n => let
                   val f = (fn () => Term_basic [hsk_name names n]);
                 in
                   (case n of QName (ThyName s1, s2) =>
                             (if equal s1 (SS_base (ST "List")) andalso equal s2 (SS_base (ST "Nil")) then term_list []
                               else (if equal s1 (SS_base (ST "HOL")) andalso equal s2 (SS_base (ST "False")) then Term_basic [lex_bool_false lexi] else f ()))
                     | Name _ => f ())
                 end
    | App (t1, t2) =>
      let
        val t2a = hsk_term lexi names t2;
        val f = (fn () => hsk_term_app lexi names [t2a] t1);
      in
        (case t1 of Literal _ => f () | Const _ => f () | Abs (_, _) => f () | App (Literal _, _) => f ()
          | App (Const (QName (ThyName s1, s2)), t12) =>
            let
              val t12a = (fn () => hsk_term lexi names t12);
            in
              (if equal s1 (SS_base (ST "Product_Type")) andalso equal s2 (SS_base (ST "Pair")) then term_pair (t12a ()) t2a
                else (if equal s1 (SS_base (ST "Prelude")) andalso equal s2 (SS_base (ST "#")) then term_parenthesis (term_binop (t12a ()) (lex_list_cons lexi) t2a) else f ()))
            end
          | App (Const (Name _), _) => f () | App (Abs (_, _), _) => f () | App (App (_, _), _) => f () | App (If (_, _, _), _) => f () | App (Let (_, _), _) => f () | App (Case (_, _), _) => f () | App (ListCompr (_, _), _) => f ()
          | App (RecConstr (_, _), _) => f () | App (RecUpdate (_, _), _) => f () | App (DoBlock (_, _, _), _) => f () | App (Parenthesized _, _) => f () | If (_, _, _) => f () | Let (_, _) => f () | Case (_, _) => f ()
          | ListCompr (_, _) => f () | RecConstr (_, _) => f () | RecUpdate (_, _) => f () | DoBlock (_, _, _) => f () | Parenthesized _ => f ())
      end
    | Parenthesized a => hsk_term lexi names a)
and hsk_term_app lexi names l t =
  (case t of Literal literal => term_parenthesis (Term_apply (hsk_term lexi names (Literal literal), l)) | Const name => term_parenthesis (Term_apply (hsk_term lexi names (Const name), l))
    | Abs (name, term) => term_parenthesis (Term_apply (hsk_term lexi names (Abs (name, term)), l)) | App (t1, t2) => hsk_term_app lexi names (hsk_term lexi names t2 :: l) t1
    | If (term1, term2, term3) => term_parenthesis (Term_apply (hsk_term lexi names (If (term1, term2, term3)), l)) | Let (lista, term) => term_parenthesis (Term_apply (hsk_term lexi names (Let (lista, term)), l))
    | Case (term, lista) => term_parenthesis (Term_apply (hsk_term lexi names (Case (term, lista)), l)) | ListCompr (term, lista) => term_parenthesis (Term_apply (hsk_term lexi names (ListCompr (term, lista)), l))
    | RecConstr (name, lista) => term_parenthesis (Term_apply (hsk_term lexi names (RecConstr (name, lista)), l)) | RecUpdate (term, lista) => term_parenthesis (Term_apply (hsk_term lexi names (RecUpdate (term, lista)), l))
    | DoBlock (abr_string1, lista, abr_string2) => term_parenthesis (Term_apply (hsk_term lexi names (DoBlock (abr_string1, lista, abr_string2)), l))
    | Parenthesized term => term_parenthesis (Term_apply (hsk_term lexi names (Parenthesized term), l)));

fun gen_zero s = flattenb s (SS_base (ST "0"));

fun pair0 l = paren (SS_base (ST "(")) (SS_base (ST ")")) (binop_l (SS_base (ST ",")) l);

fun app_pair e l = apply e (case l of [] => [] | _ :: _ => [pair0 l]);

fun rewrite x = (fn a => fn b => SML_rewrite (x, a, b));

fun hol_to_sml e =
  (case e of Term_rewrite (t1, s, t2) => (if equal s (SS_base (ST "=")) then (fn a => fn b => fn c => SML_rewrite (a, b, c)) else (fn a => fn b => fn c => SML_binop (a, b, c))) (hol_to_sml t1) s (hol_to_sml t2)
    | Term_basic a => SML_basic a | Term_apply (t, l) => app_pair (hol_to_sml t) (mapa hol_to_sml l)
    | Term_paren (x, xa, Term_rewrite (semi_term1, abr_string, semi_term2)) => SML_paren (x, xa, hol_to_sml (Term_rewrite (semi_term1, abr_string, semi_term2)))
    | Term_paren (x, xa, Term_basic lista) => SML_paren (x, xa, hol_to_sml (Term_basic lista)) | Term_paren (x, xa, Term_annot (semi_term, semi_typ)) => SML_paren (x, xa, hol_to_sml (Term_annot (semi_term, semi_typ)))
    | Term_paren (x, xa, Term_bind (abr_string, semi_term1, semi_term2)) => SML_paren (x, xa, hol_to_sml (Term_bind (abr_string, semi_term1, semi_term2)))
    | Term_paren (x, xa, Term_fun_case (optiona, lista)) => SML_paren (x, xa, hol_to_sml (Term_fun_case (optiona, lista)))
    | Term_paren (x, xa, Term_apply (semi_term, lista)) => SML_paren (x, xa, hol_to_sml (Term_apply (semi_term, lista)))
    | Term_paren (x, xa, Term_paren (abr_string1a, abr_string2a, semi_term)) => SML_paren (x, xa, hol_to_sml (Term_paren (abr_string1a, abr_string2a, semi_term)))
    | Term_paren (x, xa, Term_if_then_else (semi_term1, semi_term2, semi_term3)) => SML_paren (x, xa, hol_to_sml (Term_if_then_else (semi_term1, semi_term2, semi_term3)))
    | Term_paren (_, _, Term_let (l, ea)) => hol_to_sml (Term_let (l, ea)) | Term_paren (x, xa, Term_term (lista, term)) => SML_paren (x, xa, hol_to_sml (Term_term (lista, term)))
    | Term_let (l, ea) => SML_let (SML_top (mapa (fn (e1, e2) => SML_val_fun (SOME Sval, rewrite (hol_to_sml e1) (SS_base (ST "=")) (hol_to_sml e2))) l), hol_to_sml ea));

fun hsk_stmt version names app_end =
  let
    val b = (fn s => Term_basic [s]);
  in
    map_prod concat concat o split o
      mapa (fn a => (case a of Datatype l =>
                              let
                                val l_data = map (map_prod (hsk_typespec names) (map (map_prod (hsk_name names) (map (hsk_type names))))) l;
                                val l_dataa = concat (map (map (fn (s, _) => (s, gen_zero s)) o snd) l_data);
                              in
                                (datatypea (Datatypea (version, map (map_prod id (map (map_prod gen_zero id))) l_data)) :: map (fn (s, sa) => definition (Definitiona (Term_rewrite (b s, SS_base (ST "="), b sa)))) l_dataa,
                                  map fst l_dataa)
                              end
                      | Record (_, _) => ([], []) | TypeSynonym [] => ([], []) | TypeSynonym [(t0, t1)] => ([type_synonym (Type_synonym (hsk_typespec names t0, hsk_type names t1))], []) | TypeSynonym ((_, _) :: _ :: _) => ([], [])
                      | Functiona (Function_Stmt (Definition, [], _)) => ([], []) | Functiona (Function_Stmt (Definition, [_], [])) => ([], [])
                      | Functiona (Function_Stmt (Definition, [_], [((lhs_n, lhs_arg), rhs)])) =>
                        let
                          val s_empty = b (SS_base (ST "v"));
                          val t_string = term_stringa;
                          val hsk_terma = hsk_term (Lexical_ext (SS_base (ST "#"), SS_base (ST "False"), (fn s => (if equal s (SS_base (ST "")) then s_empty else t_string s)), ())) names;
                        in
                          ([(definition o Definitiona)
                              (Term_rewrite
                                (term_app (hsk_nameb names lhs_n) (mapa hsk_terma lhs_arg), SS_base (ST "="),
                                  let
                                    val t = term_parenthesis (Term_let ([(s_empty, t_string (SS_base (ST "")))], hsk_terma rhs));
                                  in
                                    (case app_end of Gen_apply_hol f => term_app f [t] | Gen_apply_sml _ => t | Gen_apply_sml_cmd (_, _) => t | Gen_no_apply => t)
                                  end))],
                            [])
                        end
                      | Functiona (Function_Stmt (Definition, [_], ((_, _), _) :: _ :: _)) => ([], []) | Functiona (Function_Stmt (Definition, _ :: _ :: _, _)) => ([], []) | Functiona (Function_Stmt (Primrec, _, _)) => ([], [])
                      | Functiona (Function_Stmt (Fun, _, _)) => ([], []) | Functiona (Function_Stmt (Function_Sorry, _, _)) => ([], []) | Class (_, _, _) => ([], []) | Instance (_, _, _, _) => ([], []) | Comment _ => ([], [])
                      | SML (Function_Stmt (Definition, [], _)) => ([], []) | SML (Function_Stmt (Definition, [_], [])) => ([], [])
                      | SML (Function_Stmt (Definition, [_], [((lhs_n, lhs_arg), rhs)])) =>
                        let
                          val s_empty = b (SS_base (ST "v"));
                          val f_content = b (SS_base (ST "content"));
                          val t_string = term_stringb f_content;
                          val hsk_terma = hsk_term (Lexical_ext (SS_base (ST "::"), SS_base (ST "false"), (fn s => (if equal s (SS_base (ST "")) then s_empty else t_string s)), ())) names;
                        in
                          ((ml o SMLa o SML_top)
                             [SML_val_fun (SOME Sval, hol_to_sml (Term_rewrite
                                                                   (term_app (hsk_nameb names lhs_n) (mapa hsk_terma lhs_arg), SS_base (ST "="),
                                                                     let
                                                                       val t = term_parenthesis
                                                                                 (Term_let ([(f_content, term_binopa (SS_base (ST "o")) (mapa b [SS_base (ST "SS_base"), SS_base (ST "ST"), SS_base (ST "Input.source_content")])),
                                                                                              (s_empty, t_string (SS_base (ST "")))],
                                                                                             hsk_terma rhs));
                                                                     in
                                                                       (case app_end of Gen_apply_hol _ => t | Gen_apply_sml f => term_app f [t] | Gen_apply_sml_cmd (f, _) => term_app f [t] | Gen_no_apply => t)
                                                                     end)))] ::
                             (case app_end of Gen_apply_hol _ => [] | Gen_apply_sml _ => [] | Gen_apply_sml_cmd (_, s) => [(META_all_meta_embedding o META_generic o OclGeneric) s] | Gen_no_apply => []),
                            [])
                        end
                      | SML (Function_Stmt (Definition, [_], ((_, _), _) :: _ :: _)) => ([], []) | SML (Function_Stmt (Definition, _ :: _ :: _, _)) => ([], []) | SML (Function_Stmt (Primrec, _, _)) => ([], [])
                      | SML (Function_Stmt (Fun, _, _)) => ([], []) | SML (Function_Stmt (Function_Sorry, _, _)) => ([], [])))
  end;

fun print_haskell x =
  (fn IsaUnit (version, l_name, app_end, name_new, (l_mod, b_concat)) => fn env =>
    (map_prod concat ((fn l1 => d_hsk_constr_update (fn l0 => l0 @ l1) env) o map to_String_b_a_s_e o concat) o split o
      mapa (fn Module (ThyName name_old, _, m, _) =>
             hsk_stmt (case map_prod id nat_of_natural version
                        of (true, xa) =>
                          (if equal_nata xa zero_nata then Datatype_old
                            else (if equal_nata (minus_nat xa one_nat) zero_nata then Datatype_old_atomic
                                   else (if equal_nata (minus_nat (minus_nat xa one_nat) one_nat) zero_nata then Datatype_old_atomic_sub else (raise Fail "undefined"))))
                        | (false, _) => Datatype_new)
               ((name_old, SOME name_new) :: l_name) app_end m))
      (if b_concat then l_mod else [last l_mod]))
    x;

val pRINT_haskell : (isaUnit -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_haskabelle.print_haskell"), print_haskell);

val thy_haskell : (isaUnit, unit compiler_env_config_ext) embedding = Embed_theories [sectiona (SS_base (ST "Haskell")), pRINT_haskell];

fun map_class f = map_class_gen (fn isub_name => fn name => fn l_attr => fn l_inh => fn l_subtree => fn next_dataty => [f isub_name name l_attr l_inh (Tsub (map (fn OclClass (n, _, _) => n) (of_sub l_subtree))) next_dataty]);

fun print_infra_type_synonym_class_higher expr =
  start_map type_synonym let
                           val optiona = (fn a => Typ_apply_paren (SS_base (ST "\092<langle>"), SS_base (ST "\092<rangle>\092<^sub>\092<bottom>"), a));
                         in
                           flatten (map_class (fn isub_name => fn name => fn _ => fn _ => fn _ => fn _ => [type_synonyma name (optiona (optiona (Typ_base (isub_name datatype_name))))]) expr)
                         end;

val pRINT_infra_type_synonym_class_higher : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_infra.print_infra_type_synonym_class_higher"), print_infra_type_synonym_class_higher);

fun print_instantia_def_strictrefeq_name mk_strict name = mk_strict [SS_base (ST "_"), isub name];

val activate_simp_optimization : bool = true;

fun print_instantia_lemmas_strictrefeq x =
  start_mapa (if activate_simp_optimization then (fn expr => let
                                                               val mk_strict = (fn l => flattena (SS_base (ST "StrictRefEq") :: isub (SS_base (ST "Object")) :: l));
                                                               val name_set = map_class (fn _ => fn name => fn _ => fn _ => fn _ => fn _ => print_instantia_def_strictrefeq_name mk_strict name) expr;
                                                             in
                                                               (case name_set of [] => [] | _ :: _ => map lemmas [lemmas_simp (SS_base (ST "")) (map thma name_set)])
                                                             end)
               else (fn _ => []))
    x;

val pRINT_instantia_lemmas_strictrefeq : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_infra.print_instantia_lemmas_strictrefeq"), print_instantia_lemmas_strictrefeq);

fun oclTy_class_pre c = OclTy_object (OclTyObj (OclTyCore_pre c, []));

fun print_infra_type_synonym_class_rec x =
  (fn expr => fn env =>
    map_prod id (fn d_ocl_HO_type => d_ocl_HO_type_update (fn _ => d_ocl_HO_type) env)
      (split (map (fn (tit, body) => (type_synonym (type_synonyma (to_String tit) body), tit))
               (snd (fold_class (fn _ => fn _ => fn l_attr => fn _ => fn _ => fn _ =>
                                  (fn a => ((), a)) o
                                    fold (fn (_, t) => fn l =>
                                           let
                                             val f = (fn ta => fn la => let
                                                                          val (tit, body) = print_infra_type_synonym_class_rec_aux ta;
                                                                        in
                                                                          (if is_none (assoca tit la) then (to_String_b_a_s_e tit, body) :: la else la)
                                                                        end);
                                           in
                                             (case t of OclTy_base_void => l | OclTy_base_boolean => l | OclTy_base_integer => l | OclTy_base_unlimitednatural => l | OclTy_base_real => l | OclTy_base_string => l
                                               | OclTy_object (OclTyObj (OclTyCore_pre _, _)) => l
                                               | OclTy_object (OclTyObj (OclTyCore obj, _)) => let
                                                                                                 val ta = (fn ty => OclTy_collection (Ocl_multiplicity_ext ([], NONE, [ty], ()), oclTy_class_pre (tyObjN_role_ty (tyObj_to obj))));
                                                                                               in
                                                                                                 f (ta Sequence) (f (ta Set) l)
                                                                                               end
                                               | OclTy_collection (_, _) => f t l | OclTy_pair (_, _) => f t l | OclTy_binding _ => l | OclTy_arrow (_, _) => l | OclTy_class_syn _ => l | OclTy_enum _ => l | OclTy_raw _ => l)
                                           end)
                                      l_attr)
                      [] expr)))))
    x;

val pRINT_infra_type_synonym_class_rec : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_infra.print_infra_type_synonym_class_rec"), print_infra_type_synonym_class_rec);

fun term_function x = Term_fun_case (NONE, x);

fun instantiation x = i Theory_instantiation x;

fun print_infra_instantiation_universe expr =
  start_map instantiation
    [let
       val oid_of = SS_base (ST "oid_of");
     in
       Instantiation
         (SS_base (ST "\092<AA>"), oid_of, Term_rewrite (Term_basic [oid_of], SS_base (ST "="), term_function (map_class (fn isub_name => fn name => fn _ => fn _ => fn _ => fn _ => let
                                                                 val esc = (fn h => Term_basic [h, name]);
                                                               in
                                                                 (esc (isub_name datatype_in), esc oid_of)
                                                               end)
                                                                                                                expr)))
     end];

val pRINT_infra_instantiation_universe : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_infra.print_infra_instantiation_universe"), print_infra_instantiation_universe);

val const_oclistypeof : abr_string = SS_base (ST "OclIsTypeOf");

val const_ocliskindof : abr_string = SS_base (ST "OclIsKindOf");

fun print_iskindof_up_istypeof_unfold_name name_pers name_any = flattena [SS_base (ST "not_"), const_ocliskindof, isub name_pers, SS_base (ST "_then_"), name_any, SS_base (ST "_"), const_oclistypeof, SS_base (ST "_others_unfold")];

fun print_iskindof_defined_namea isub_name h_name = flattena [isub_name const_ocliskindof, SS_base (ST "_"), h_name, SS_base (ST "_defined'")];

fun print_istypeof_defined_namea isub_name h_name = flattena [isub_name const_oclistypeof, SS_base (ST "_"), h_name, SS_base (ST "_defined'")];

fun erule x = Method_erule x;

fun oF_l s l = fold (fn x => fn acc => Thm_OF (acc, x)) l s;

fun ofa x = (fn a => Thm_OF (x, a));

fun print_iskindof_up_istypeof_erule var_isdef next_dataty name_pers name_any =
  let
    val mk_OF = (fn f => ofa (thma (f name_any)) (thma var_isdef));
    val next_datatya = let
                         val x :: xs = next_dataty;
                       in
                         rev ((SS_base (ST "foundation26"), x) :: map (fn a => (SS_base (ST "defined_or_I"), a)) xs)
                       end;
  in
    erule (fold (fn (rule_name, OclClass (n, _, _)) => fn prf => oF_l (thma rule_name) [prf, mk_OF (print_iskindof_defined_namea (fn name => flattenb name (isub n)))]) next_datatya
            (mk_OF (print_istypeof_defined_namea (fn name => flattenb name (isub name_pers)))))
  end;

fun equal_position GT UN = false
  | equal_position UN GT = false
  | equal_position LT UN = false
  | equal_position UN LT = false
  | equal_position LT GT = false
  | equal_position GT LT = false
  | equal_position EQ UN = false
  | equal_position UN EQ = false
  | equal_position EQ GT = false
  | equal_position GT EQ = false
  | equal_position EQ LT = false
  | equal_position LT EQ = false
  | equal_position UN UN = true
  | equal_position GT GT = true
  | equal_position LT LT = true
  | equal_position EQ EQ = true;

fun term_binopb s l = let
                        val x :: xs = rev l;
                      in
                        fold (fn xa => term_parenthesis o term_binop xa s) xs x
                      end;

fun m_class_default x = (fn _ => fn _ => fn _ => id) x;

val dot_oclistypeof : abr_string = SS_base (ST ".oclIsTypeOf");

fun dot_istypeof x = mk_dot_par dot_oclistypeof x;

val dot_ocliskindof : abr_string = SS_base (ST ".oclIsKindOf");

fun dot_iskindof x = mk_dot_par dot_ocliskindof x;

fun drule x = Method_drule x;

fun using x = (Command_using o map Thms_single) x;

fun inh_sib (Inheritance_ext (inh, inh_sib, inh_sib_unflat, more)) = inh_sib;

fun of_linh_sib l = flatten (map snd (flatten (map inh_sib l)));

fun inh_sib_unflat (Inheritance_ext (inh, inh_sib, inh_sib_unflat, more)) = inh_sib_unflat;

fun map_linh f cl = Inheritance_ext (f (inh cl), map (map_prod f (map f)) (inh_sib cl), map f (inh_sib_unflat cl), ());

fun m_class_gen2 base_attr f print =
  let
    val m_base_attr = (fn OclClass (n, l, a) => OclClass (n, base_attr l, a));
    val f_base_attr = map m_base_attr;
  in
    map_class_gen_hb
      (fn isub_name => fn name => fn nl_attr => fn l_inh => fn l_subtree => fn next_dataty =>
        f name l_inh l_subtree
          (flatten (flatten (map let
                                   val print_astype = print (map (map_linh m_base_attr) l_inh) (f_base_attr l_subtree) next_dataty;
                                   val nl_attra = base_attr nl_attr;
                                 in
                                   (fn (l_hierarchy, a) => map (print_astype l_hierarchy (isub_name, (name, nl_attra)) o m_base_attr) a)
                                 end
                              [(EQ, [OclClass (name, nl_attr, next_dataty)]), (GT, of_linh l_inh), (LT, l_subtree), (UN, of_linh_sib l_inh)]))))
  end;

fun start_mapc f fl =
  (fn env => let
               val design_analysis = d_ocl_semantics env;
               val base_attr =
                 (if equal_generation_semantics_ocl design_analysis Gen_only_design then id
                   else filtera (fn a => (case a of (_, OclTy_base_void) => true | (_, OclTy_base_boolean) => true | (_, OclTy_base_integer) => true | (_, OclTy_base_unlimitednatural) => true | (_, OclTy_base_real) => true
                                           | (_, OclTy_base_string) => true | (_, OclTy_object (OclTyObj (OclTyCore_pre _, _))) => true | (_, OclTy_object (OclTyObj (OclTyCore _, _))) => false | (_, OclTy_collection (_, _)) => true
                                           | (_, OclTy_pair (_, _)) => true | (_, OclTy_binding _) => true | (_, OclTy_arrow (_, _)) => true | (_, OclTy_class_syn _) => true | (_, OclTy_enum _) => true | (_, OclTy_raw _) => true)));
               val base_attra = (fn (l_attr, l_inh) => (base_attr l_attr, map base_attr l_inh));
               val base_attrb = (fn (l_attr, l_inh) => (base_attr l_attr, base_attr l_inh));
             in
               start_map f (fl design_analysis base_attr base_attra base_attrb) env
             end);

fun start_mapb f fl e = start_mapc f (fn _ => fl) e;

fun start_m_gen final f print = start_mapb final o (fn expr => fn base_attr => fn _ => fn _ => m_class_gen2 base_attr f print expr);

val done : semi_command_final = Command_done;

fun lemma x = i Theory_lemma x;

fun print_iskindof_up_istypeof_unfold x =
  start_m_gen lemma m_class_default
    (fn _ => fn name_pred0 => fn next_dataty => fn compare => fn (isub_name, (name_pers, _)) => fn OclClass (name_any, _, _) =>
      (if equal_position compare GT
        then let
               val var_X = SS_base (ST "X");
               val var_iskin = SS_base (ST "iskin");
               val var_isdef = SS_base (ST "isdef");
               val f = (fn f => f o term_parenthesis o term_binop (Term_basic [SS_base (ST "\092<tau>")]) (SS_base (ST "\092<Turnstile>")));
             in
               [Lemma_assumes
                  (print_iskindof_up_istypeof_unfold_name name_pers name_any,
                    [(var_isdef, (false, f id (term_app (SS_base (ST "\092<delta>")) [Term_basic [var_X]]))),
                      (var_iskin, (false, f id (term_warning_parenthesis (term_postunary (term_annot_ocl (Term_basic [var_X]) name_any) (Term_basic [dot_iskindof name_pers])))))],
                    term_binopb (SS_base (ST "\092<or>"))
                      (flatten (map (fn (f_dot, a) => map (fn name_pred => f id (term_warning_parenthesis (term_postunary (term_annot_ocl (Term_basic [var_X]) name_any) (Term_basic [f_dot name_pred])))) a)
                                 [(dot_istypeof, name_pers :: map (fn OclClass (n, _, _) => n) name_pred0)])),
                    using [thma var_iskin] ::
                      applya [simp_only [thma (flattena [isub_name const_ocliskindof, SS_base (ST "_"), name_any])]] ::
                        (if null next_dataty then []
                          else flatten [fst (mapM (fn _ => fn next_datatya => (applya [print_iskindof_up_istypeof_erule var_isdef next_datatya name_pers name_any], tl next_datatya)) next_dataty (rev next_dataty)), [applya [simp]],
                                         map (fn OclClass (n, _, _) => applya [drule (ofa (thma (print_iskindof_up_istypeof_unfold_name n name_any)) (thma var_isdef)), blast NONE]) next_dataty]),
                    done)]
             end
        else []))
    x;

val pRINT_iskindof_up_istypeof_unfold : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_iskindof.print_iskindof_up_istypeof_unfold"), print_iskindof_up_istypeof_unfold);

fun print_instantia_def_strictrefeq x =
  (start_map overloading o
    map_class (fn _ => fn name => fn _ => fn _ => fn _ => fn _ =>
                let
                  val mk_strict = (fn l => flattena (SS_base (ST "StrictRefEq") :: isub (SS_base (ST "Object")) :: l));
                  val _ = mk_strict [SS_base (ST "_"), isub name];
                  val var_x = SS_base (ST "x");
                  val var_y = SS_base (ST "y");
                in
                  overloadinga (SS_base (ST "StrictRefEq")) (ty_arrowb (ty_arrowb (ty_paren (Typ_base (wrap_oclty name))))) (print_instantia_def_strictrefeq_name mk_strict name)
                    (Term_rewrite (term_binop (term_annot_ocl (Term_basic [var_x]) name) (SS_base (ST "\092<doteq>")) (Term_basic [var_y]), SS_base (ST "\092<equiv>"), Term_basic [mk_strict [], var_x, var_y]))
                end))
    x;

val pRINT_instantia_def_strictrefeq : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_infra.print_instantia_def_strictrefeq"), print_instantia_def_strictrefeq);

fun get_class_hierarchy e = map (fn OclClass (n, l, _) => (n, l)) (get_class_hierarchya e);

fun add_hierarchya f x = (fn isub_name => fn name => fn l_attr => fn l_inh => fn l_subtree => fn _ => f isub_name name (Tuniv (get_class_hierarchy x)) l_attr (map_inh (map (fn OclClass (_, l, _) => l) o of_linh) l_inh) l_subtree);

fun map_class_gen_ha f x =
  map_class_gen (add_hierarchya (fn isub_name => fn name => fn l_inherited => fn l_attr => fn l_inh => fn l_subtree => f isub_name name l_inherited l_attr l_inh (Tsub (map (fn OclClass (n, _, _) => n) (of_sub l_subtree)))) x) x;

fun mk_constr_name name = (fn x => flattena [isub name, SS_base (ST "_"), isub x]);

fun print_infra_instantiation_class x =
  (start_mapb instantiation o
    (fn expr => fn _ => fn base_attr => fn _ =>
      map_class_gen_ha
        (fn isub_name => fn name => fn _ => fn l_attr => fn l_inherited => fn l_cons =>
          let
            val (l_attra, l_inheriteda) = base_attr (l_attr, of_inh l_inherited);
            val oid_of = SS_base (ST "oid_of");
          in
            [Instantiation
               (isub_name datatype_name, oid_of,
                 Term_rewrite (Term_basic [oid_of], SS_base (ST "="),
                                term_function
                                  [let
                                     val var_oid = SS_base (ST "t");
                                   in
                                     (Term_basic (isub_name datatype_constr_name :: var_oid :: map (fn _ => wildcard) l_attra),
                                       term_case (Term_basic [var_oid])
                                         ((term_app (isub_name datatype_ext_constr_name) (Term_basic [var_oid] :: flatten (map (map (fn _ => Term_basic [wildcard])) l_inheriteda)), Term_basic [var_oid]) ::
                                           map (fn xa => (term_app (flattenb datatype_ext_constr_name (mk_constr_name name xa)) [Term_basic [var_oid]], term_app oid_of [Term_basic [var_oid]])) (of_sub l_cons)))
                                   end]))]
          end)
        expr))
    x;

val pRINT_infra_instantiation_class : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_infra.print_infra_instantiation_class"), print_infra_instantiation_class);

val print_infra_datatype_equiv_2of1_name : abr_string = SS_base (ST "class_ty_ext_equiv_2of1");

val print_infra_datatype_equiv_2of1_name_aux : abr_string = flattenb print_infra_datatype_equiv_2of1_name (SS_base (ST "_aux"));

val datatype_ext_constr_namea : abr_string = SS_base (ST "mk2");

val datatype_constr_namea : abr_string = flattenb datatype_ext_constr_namea const_oid;

fun add_hierarchy f x = (fn isub_name => fn name => fn l_attr => fn l_inh => fn _ => f isub_name name (Tuniv (get_class_hierarchy x)) l_attr (map_inh (map (fn OclClass (_, l, _) => l) o of_linh) l_inh));

fun map_class_gen_h f x = map_class_gen (add_hierarchy f x) x;

fun print_infra_datatype_equiv_2of1 x =
  (start_mapb definition o
    (fn expr => fn _ => fn base_attr => fn _ =>
      map_class_gen_h
        (fn isub_name => fn name => fn _ => fn l_attr => fn l_inherited => fn next_dataty =>
          let
            val (l_attra, l_inheriteda) = base_attr (l_attr, of_inh l_inherited);
            val f_attr_own = (fn s => flattenb (SS_base (ST "own")) (isub s)) o fst;
            val f_attr_inh = (fn s => flattenb (SS_base (ST "inh")) (isub s)) o fst;
            val (l_attrb, l_inheritedb) = (map f_attr_own l_attra, map f_attr_inh (flatten l_inheriteda));
            val a = (fn f => fn xa => term_app f [xa]);
            val b = (fn s => Term_basic [s]);
            val aa = (fn f => fn l => term_app f (map b l));
            val print_name = isub_name print_infra_datatype_equiv_2of1_name_aux;
            val var_oid = SS_base (ST "oid");
            val f_pat = (fn l => flatten [var_oid :: l_inheritedb, l]);
          in
            map (fn (n, d) => Definitiona (Term_rewrite (b n, SS_base (ST "="), d)))
              [(print_name, let
                              val var_t = SS_base (ST "t");
                            in
                              term_lambdas (f_pat [])
                                (term_function
                                  [(aa (isub_name datatype_ext_constr_namea) (flatten [l_attrb, (if null next_dataty then [] else [var_t])]),
                                     term_app (isub_name datatype_constr_name)
                                       (let
                                          val pat_none = aa (isub_name datatype_ext_constr_name) (f_pat []);
                                        in
                                          (if null next_dataty then pat_none
                                            else term_case (b var_t)
                                                   ((b (SS_base (ST "None")), pat_none) ::
                                                     map (fn OclClass (name_pers, l_attr_pers, name_pers0) =>
                                                           let
                                                             val l_attr_persa = map f_attr_own (fst (base_attr (l_attr_pers, [])));
                                                             val isub_name_pers = (fn xa => flattenb xa (isub name_pers));
                                                           in
                                                             (term_some (a (flattenb datatype_ext_constr_namea (mk_constr_name name name_pers)) (b var_t)),
                                                               let
                                                                 val f_pata = (fn l => flatten [l_attrb, l_inheritedb, l]);
                                                               in
                                                                 term_case (aa (isub_name_pers print_infra_datatype_equiv_2of1_name_aux) (var_oid :: f_pata [var_t]))
                                                                   let
                                                                     val a_pers = (fn xa => term_app (isub_name_pers datatype_constr_name) (xa :: map b l_attr_persa));
                                                                     val v = a_pers (aa (isub_name_pers datatype_ext_constr_name) (var_oid :: f_pata []));
                                                                   in
                                                                     (v, a (flattenb datatype_ext_constr_name (mk_constr_name name name_pers)) v) ::
                                                                       map (fn OclClass (name_bot, _, _) =>
                                                                             (a_pers (a (flattenb datatype_ext_constr_name (mk_constr_name name_pers name_bot)) (b var_t)),
                                                                               a (flattenb datatype_ext_constr_name (mk_constr_name name name_bot)) (b var_t)))
                                                                         (get_class_hierarchy_strict name_pers0)
                                                                   end
                                                               end)
                                                           end)
                                                       next_dataty))
                                        end ::
                                         map b l_attrb))])
                            end),
                (isub_name print_infra_datatype_equiv_2of1_name, term_function [let
                                                                                  val l = map b (f_pat [SS_base (ST "t")]);
                                                                                in
                                                                                  (term_app (isub_name datatype_constr_namea) l, term_app print_name l)
                                                                                end])]
          end)
        expr))
    x;

val pRINT_infra_datatype_equiv_2of1 : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_infra.print_infra_datatype_equiv_2of1"), print_infra_datatype_equiv_2of1);

val print_infra_datatype_equiv_1of2_name : abr_string = SS_base (ST "class_ty_ext_equiv_1of2");

val print_infra_datatype_equiv_1of2_name_get_oid_inh : abr_string = flattenb print_infra_datatype_equiv_1of2_name (SS_base (ST "_get_oid_inh"));

val print_infra_datatype_equiv_1of2_name_aux : abr_string = flattenb print_infra_datatype_equiv_1of2_name (SS_base (ST "_aux"));

fun term_pairs f l = term_paira (map f l);

fun print_infra_datatype_equiv_1of2 x =
  (start_mapb definition o
    (fn expr => fn _ => fn base_attr => fn _ =>
      map_class_gen_h
        (fn isub_name => fn name => fn _ => fn l_attr => fn l_inherited => fn next_dataty =>
          let
            val (l_attra, l_inheriteda) = base_attr (l_attr, of_inh l_inherited);
            val f_attr_own = (fn s => flattenb (SS_base (ST "own")) (isub s)) o fst;
            val f_attr_inh = (fn s => flattenb (SS_base (ST "inh")) (isub s)) o fst;
            val f_attr_var = (fn s => flattenb (SS_base (ST "var")) (isub s)) o fst;
            val (l_attrb, (l_attraa, (l_inheritedb, l_inheritedaa))) = (map f_attr_var l_attra, (map f_attr_own l_attra, (map f_attr_var (flatten l_inheriteda), map f_attr_inh (flatten l_inheriteda))));
            val a = (fn f => fn xa => term_app f [xa]);
            val b = (fn s => Term_basic [s]);
            val aa = (fn f => fn l => term_app f (map b l));
            val print_name = isub_name print_infra_datatype_equiv_1of2_name_aux;
            val var_t = SS_base (ST "t");
            val var_tt = SS_base (ST "tt");
            val var_oid = SS_base (ST "oid");
          in
            map (fn (n, d) => Definitiona (Term_rewrite (b n, SS_base (ST "="), d)))
              [(isub_name print_infra_datatype_equiv_1of2_name_get_oid_inh,
                 term_function
                   ((aa (isub_name datatype_ext_constr_name) (flatten [[var_oid], l_inheritedaa]), term_pairs b (flatten [[var_oid], l_inheritedaa])) ::
                     flatten (map (fst o fold_class (fn isub_name_pers => fn name_pers => fn l_attr_pers => fn l_inh => fn _ => fn _ =>
                                                      let
                                                        val l_attr_persa = map f_attr_var (fst (base_attr (l_attr_pers, [])));
                                                      in
                                                        (fn c => ((a (flattenb datatype_ext_constr_name (mk_constr_name name name_pers)) (aa (isub_name_pers datatype_constr_name) (var_t :: l_attr_persa)),
                                                                    term_case (a (isub_name_pers print_infra_datatype_equiv_1of2_name_get_oid_inh) (b var_t))
                                                                      [let
                                                                         val l_inha = flatten [flatten (map (fn OclClass (_, l_attrc, _) => map f_attr_var (fst (base_attr (l_attrc, [])))) (of_inh l_inh)), l_attrb, l_inheritedb];
                                                                       in
                                                                         (term_pairs b (var_oid :: l_inha), term_pairs b (var_oid :: l_inheritedb))
                                                                       end]),
                                                                   c))
                                                      end)
                                           ())
                               next_dataty))),
                (print_name, term_function
                               [(aa (isub_name datatype_constr_name) (var_t :: l_attraa),
                                  term_app (isub_name datatype_ext_constr_namea)
                                    (flatten [map b l_attraa,
                                               (if null next_dataty then []
                                                 else [term_case (b var_t)
                                                         ((aa (isub_name datatype_ext_constr_name) (var_oid :: l_inheritedaa), b (SS_base (ST "None"))) ::
                                                           flatten (map (fst o fold_class (fn isub_name_pers => fn name_pers => fn l_attr_pers => fn l_inh => fn _ => fn _ =>
                                                                                            let
                                                                                              val l_attr_persa = map f_attr_var (fst (base_attr (l_attr_pers, [])));
                                                                                            in
                                                                                              (fn c => ((a (flattenb datatype_ext_constr_name (mk_constr_name name name_pers)) (b var_tt),
                                                                                                          term_case (term_case (b var_tt)
[let
   val var_ta = SS_base (ST "t");
 in
   (aa (isub_name_pers datatype_constr_name) (var_ta :: l_attr_persa), a (isub_name_pers print_infra_datatype_equiv_1of2_name_get_oid_inh) (b var_ta))
 end])
                                                                                                            [(term_pairs b (var_oid ::
       flatten [flatten (map (fn OclClass (_, l_attrc, _) => map f_attr_var (fst (base_attr (l_attrc, [])))) (of_inh l_inh)), l_attrb, l_inheritedb]),
                                                                                                               let
                                                                                                                 val f_cons = (fn expra => fn name0 => fn name1 =>
          term_some (a (flattenb datatype_ext_constr_namea (mk_constr_name name1 name0)) expra));
                                                                                                                 val (expra, name0) =
                                                                                                                   foldl (fn (expra, name0) => fn (name1, l_attr1) =>
     (term_app (flattenb datatype_ext_constr_namea (isub name1)) (flatten [map b (map f_attr_var (fst (base_attr (l_attr1, [])))), [f_cons expra name0 name1]]), name1))
                                                                                                                     (a (isub_name_pers print_infra_datatype_equiv_1of2_name_aux) (b var_tt), name_pers)
                                                                                                                     (map (fn OclClass (n, l_attrc, _) => (n, l_attrc)) (of_inh l_inh));
                                                                                                               in
                                                                                                                 f_cons expra name0 name
                                                                                                               end)]),
                                                                                                         c))
                                                                                            end)
                                                                                 ())
                                                                     next_dataty))])]))]),
                (isub_name print_infra_datatype_equiv_1of2_name,
                  term_function
                    [(aa (isub_name datatype_constr_name) (var_t :: l_attraa),
                       term_case (a (isub_name print_infra_datatype_equiv_1of2_name_get_oid_inh) (b var_t))
                         [(term_pairs b (var_oid :: l_inheritedaa), term_app (isub_name datatype_constr_namea) (flatten [map b (var_oid :: l_inheritedaa), [a print_name (aa (isub_name datatype_constr_name) (var_t :: l_attraa))]]))])])]
          end)
        expr))
    x;

val pRINT_infra_datatype_equiv_1of2 : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_infra.print_infra_datatype_equiv_1of2"), print_infra_datatype_equiv_1of2);

fun type_notation x = i Theory_type_notation x;

val ty_integer : abr_string = str_of_ty OclTy_base_integer;

val ty_boolean : abr_string = str_of_ty OclTy_base_boolean;

val ty_string : abr_string = str_of_ty OclTy_base_string;

val var_val : abr_string = SS_base (ST "val'");

val ty_void : abr_string = str_of_ty OclTy_base_void;

val ty_real : abr_string = str_of_ty OclTy_base_real;

fun print_infra_type_synonym_class uu =
  start_map id (append (map type_synonym
                         let
                           val ty = (fn t => fn s => type_synonyma (str_of_ty t) (Typ_apply (Typ_base s, [Typ_base (SS_base (ST "\092<AA>"))])));
                         in
                           [ty OclTy_base_void ty_void, ty OclTy_base_boolean ty_boolean, ty OclTy_base_integer ty_integer, ty OclTy_base_real ty_real, ty OclTy_base_string ty_string,
                             type_synonymb var_val [SS_base (ST "'\092<alpha>")] (fn [alpha] => Typ_apply (Typ_base (SS_base (ST "val")), [Typ_base (SS_base (ST "\092<AA>")), Typ_base alpha]))]
                         end)
                 (map type_notation [Type_notation (var_val, SS_base (ST "\092<cdot>(_)"))]));

val pRINT_infra_type_synonym_class : ('a -> 'b -> all_meta list * 'b) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_infra.print_infra_type_synonym_class"), print_infra_type_synonym_class);

fun print_infra_datatype_universe expr = start_map datatypea [datatypeb (SS_base (ST "\092<AA>")) (map_class (fn isub_name => fn _ => fn _ => fn _ => fn _ => fn _ => (isub_name datatype_in, [raw (isub_name datatype_name)])) expr)];

val pRINT_infra_datatype_universe : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_infra.print_infra_datatype_universe"), print_infra_datatype_universe);

val print_allinst_istypeof_pre_name2 : abr_string = SS_base (ST "ex_def");

val print_allinst_istypeof_pre_name1 : abr_string = SS_base (ST "ex_ssubst");

fun print_iskindof_up_eq_asty_name name = flattena [SS_base (ST "actual_eq_static"), isub name];

fun print_iskindof_up_larger_name name_pers name_any = flattena [SS_base (ST "actualKind"), isub name_pers, SS_base (ST "_larger_staticKind"), isub name_any];

val var_Abs_Set : abr_string = SS_base (ST "Abs_Set\092<^sub>b\092<^sub>a\092<^sub>s\092<^sub>e");

val var_Abs_Set_inverse : abr_string = flattenb var_Abs_Set (SS_base (ST "_inverse"));

fun simplified_l s l = fold (fn x => fn acc => Thm_simplified (acc, x)) l s;

fun simplified x = (fn a => Thm_simplified (x, a));

fun gen_pre_post f_tit spec f_lemma = gen_pre_post0 f_tit [] spec (fn lem_gen => fn _ => f_lemma lem_gen);

fun wherea x = (fn a => Thm_where (x, a));

fun intro x = Method_intro x;

fun print_allinst_istypeof_single isub_name name isub_name2 name2 const_oclisof dot_isof f_simp1 f_simp2 =
  let
    val b = (fn s => Term_basic [s]);
    val d = hol_definition;
    val s = subst_l [SS_base (ST "1"), SS_base (ST "2"), SS_base (ST "3")];
    val var_tau = SS_base (ST "\092<tau>");
  in
    gen_pre_post (fn sa => flattena [name, SS_base (ST "_"), sa, SS_base (ST "_"), isub_name2 const_oclisof])
      (fn f_expr => fn _ => fn _ => term_binop (b var_tau) (SS_base (ST "\092<Turnstile>")) (term_app var_OclForall_set [f_expr [b name], b (isub_name2 const_oclisof)]))
      (fn lem_tit => fn lem_spec => fn _ => fn _ => fn _ =>
        Lemma (lem_tit, [lem_spec],
                [[simp_add_del [d (SS_base (ST "OclValid"))] (d (SS_base (ST "OclAllInstances_generic")) :: f_simp1 [flattena [isub_name2 const_oclisof, SS_base (ST "_"), name]])],
                  [simp_only (flatten [map thma [d var_OclForall_set, SS_base (ST "refl"), SS_base (ST "if_True")], [simplified (thma (SS_base (ST "OclAllInstances_generic_defined"))) (thma (d (SS_base (ST "OclValid"))))]])],
                  [simp_only [thma (d (SS_base (ST "OclAllInstances_generic")))]], [s (thma var_Abs_Set_inverse), simp_add [d (SS_base (ST "bot_option"))]],
                  [s (wherea (thma print_allinst_istypeof_pre_name1)
                       [(SS_base (ST "s"), term_lam (SS_base (ST "x")) (fn var_x => term_applys (term_postunary (term_lambda wildcard (b var_x)) (b (dot_isof name2))) [b var_tau])),
                         (SS_base (ST "t"), term_lambda wildcard (term_app (SS_base (ST "true")) [b var_tau]))])],
                  [intro [thma (SS_base (ST "ballI")),
                           simplified_l (thma (if equal_abr_stringa name name2 then print_iskindof_up_eq_asty_name name else print_iskindof_up_larger_name name name2))
                             (map thma (d (SS_base (ST "OclValid")) :: f_simp2 [flattena [isub_name const_ocliskindof, SS_base (ST "_"), name]]))]],
                  [drule (thma print_allinst_istypeof_pre_name2), erule (thma (SS_base (ST "exE"))), simp]],
                by [simp]))
      []
  end;

fun m_class base_attr f print = m_class_gen2 base_attr f (fn _ => fn _ => fn _ => print);

fun m_classa base_attr print = m_class base_attr m_class_default (fn l_hierarchy => fn x0 => fn x1 => [print l_hierarchy x0 x1]);

fun map_class_nupl2_inh f = map_filter id o m_classa id (fn compare => fn (_, (name, _)) => fn OclClass (h_name, _, _) => (if equal_position compare GT then SOME (f name h_name) else NONE));

fun print_allinst_iskindof_larger x =
  (start_map lemma o flatten o map_class_nupl2_inh (fn name => fn name2 => print_allinst_istypeof_single (fn s => flattenb s (isub name)) name (fn s => flattenb s (isub name2)) name2 const_ocliskindof dot_iskindof id (fn _ => []))) x;

val pRINT_allinst_iskindof_larger : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_allinst.print_allinst_iskindof_larger"), print_allinst_iskindof_larger);

fun get_hierarchy_map f f_l x = flatten (flatten let
                                                   val (l1, (l2, l3)) = f_l (map fst (get_class_hierarchy x));
                                                 in
                                                   map (fn name1 => map (fn name2 => map (f name1 name2) l3) l2) l1
                                                 end);

fun print_istypeof_lemmas_strict_set x =
  (if activate_simp_optimization then get_hierarchy_map (fn name1 => fn name2 => fn name3 => (name1, (name3, name2))) (fn xa => (xa, ([SS_base (ST "invalid"), SS_base (ST "null")], xa))) else (fn _ => [])) x;

fun print_istypeof_lemmas_strict expr =
  start_map lemmas
    (case print_istypeof_lemmas_strict_set expr of [] => []
      | a :: lista => [lemmas_simp (SS_base (ST "")) (map (fn (name1, (name3, name2)) => thma (flattena [const_oclistypeof, isub name1, SS_base (ST "_"), name3, SS_base (ST "_"), name2])) (a :: lista))]);

val pRINT_istypeof_lemmas_strict : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_istypeof.print_istypeof_lemmas_strict"), print_istypeof_lemmas_strict);

val term_basety : semi_terma = let
                                 val var_x = SS_base (ST "x");
                               in
                                 term_lambdas [var_x, wildcard] (term_some (term_some (Term_basic [var_x])))
                               end;

fun start_m final f print = start_mapb final o (fn expr => fn base_attr => fn _ => fn _ => m_class base_attr f print expr);

fun print_istypeof_from_universe x =
  start_m definition (fn name => fn _ => fn _ => fn l => let
                                                           val const_istypeof = flattena [const_oclistypeof, isub name, SS_base (ST "_\092<AA>")];
                                                         in
                                                           [Definitiona (Term_rewrite (Term_basic [const_istypeof], SS_base (ST "="), term_function l))]
                                                         end)
    (fn _ => fn (_, (name, _)) => fn OclClass (h_name, _, _) =>
      let
        val isub_h = (fn s => flattenb s (isub h_name));
      in
        [(term_app (isub_h datatype_in) [Term_basic [h_name]], term_warning_parenthesis (term_postunary (term_annot_ocl (term_applys term_basety [Term_basic [h_name]]) h_name) (Term_basic [dot_istypeof name])))]
      end)
    x;

val pRINT_istypeof_from_universe : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_istypeof.print_istypeof_from_universe"), print_istypeof_from_universe);

fun print_iskindof_lemmas_strict x =
  start_mapa (if activate_simp_optimization
               then map lemmas o (fn expr => [lemmas_simp (SS_base (ST ""))
                                                (get_hierarchy_map (fn name1 => fn name2 => fn name3 => thma (flattena [const_ocliskindof, isub name1, SS_base (ST "_"), name3, SS_base (ST "_"), name2]))
                                                  (fn xa => (xa, ([SS_base (ST "invalid"), SS_base (ST "null")], xa))) expr)])
               else (fn _ => []))
    x;

val pRINT_iskindof_lemmas_strict : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_iskindof.print_iskindof_lemmas_strict"), print_iskindof_lemmas_strict);

fun print_iskindof_from_universe x =
  start_m definition (fn name => fn _ => fn _ => fn l => let
                                                           val const_iskindof = flattena [const_ocliskindof, isub name, SS_base (ST "_\092<AA>")];
                                                         in
                                                           [Definitiona (Term_rewrite (Term_basic [const_iskindof], SS_base (ST "="), term_function l))]
                                                         end)
    (fn _ => fn (_, (name, _)) => fn OclClass (h_name, _, _) =>
      let
        val isub_h = (fn s => flattenb s (isub h_name));
      in
        [(term_app (isub_h datatype_in) [Term_basic [h_name]], term_warning_parenthesis (term_postunary (term_annot_ocl (term_applys term_basety [Term_basic [h_name]]) h_name) (Term_basic [dot_iskindof name])))]
      end)
    x;

val pRINT_iskindof_from_universe : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_iskindof.print_iskindof_from_universe"), print_iskindof_from_universe);

val datatype_ext_namea : abr_string = SS_base (ST "ty2");

val datatype_ext_nameb : abr_string = flattenb datatype_ext_namea (SS_base (ST "\092<E>\092<X>\092<T>"));

val datatype_namea : abr_string = flattenb datatype_ext_namea const_oid;

fun opt s = Typ_apply (Typ_base (SS_base (ST "option")), [Typ_base s]);

fun print_infra_datatype_class_2 x =
  (start_mapb datatypea o
    (fn expr => fn _ => fn base_attr => fn _ =>
      map_class_gen_h
        (fn isub_name => fn name => fn _ => fn l_attr => fn l_inherited => fn l_cons =>
          let
            val (l_attra, l_inheriteda) = base_attr (l_attr, of_inh l_inherited);
            val map_ty = map ((fn xa => Typ_apply (Typ_base (SS_base (ST "option")), [str_hol_of_ty_all (fn a => fn b => Typ_apply (a, b)) Typ_base xa])) o snd);
            val l = [datatypeb (isub_name datatype_ext_nameb) [(isub_name datatype_ext_constr_namea, flatten [map_ty l_attra, (if null l_cons then [] else [opt (isub_name datatype_ext_namea)])])],
                      datatypeb (isub_name datatype_namea) [(isub_name datatype_constr_namea, flatten [raw const_oid :: mapsa map_ty l_inheriteda, [raw (isub_name datatype_ext_nameb)]])]];
          in
            (if null l_cons then l
              else datatypeb (isub_name datatype_ext_namea) (rev_map (fn OclClass (xa, _, _) => (flattenb datatype_ext_constr_namea (mk_constr_name name xa), [raw (flattenb datatype_ext_nameb (isub xa))])) l_cons) :: l)
          end)
        expr))
    x;

val pRINT_infra_datatype_class_2 : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_infra.print_infra_datatype_class_2"), print_infra_datatype_class_2);

val datatype_ext_name : abr_string = flattenb datatype_name (SS_base (ST "\092<E>\092<X>\092<T>"));

fun print_infra_datatype_class_1 x =
  (start_mapb datatypea o
    (fn expr => fn _ => fn base_attr => fn _ =>
      map_class_gen_ha
        (fn isub_name => fn name => fn _ => fn l_attr => fn l_inherited => fn l_cons =>
          let
            val (l_attra, l_inheriteda) = base_attr (l_attr, of_inh l_inherited);
            val map_ty = map ((fn xa => Typ_apply (Typ_base (SS_base (ST "option")), [str_hol_of_ty_all (fn a => fn b => Typ_apply (a, b)) Typ_base xa])) o snd);
          in
            [datatypeb (isub_name datatype_ext_name)
               (append (rev_map (fn xa => (flattenb datatype_ext_constr_name (mk_constr_name name xa), [raw (flattenb datatype_name (isub xa))])) (of_sub l_cons))
                 [(isub_name datatype_ext_constr_name, raw const_oid :: mapsa map_ty l_inheriteda)]),
              datatypeb (isub_name datatype_name) [(isub_name datatype_constr_name, raw (isub_name datatype_ext_name) :: map_ty l_attra)]]
          end)
        expr))
    x;

val pRINT_infra_datatype_class_1 : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_infra.print_infra_datatype_class_1"), print_infra_datatype_class_1);

fun print_istypeof_lemma_cp_set x = (if activate_simp_optimization then map_class (fn isub_name => fn name => fn _ => fn _ => fn _ => fn _ => ((isub_name, name), name)) else (fn _ => [])) x;

fun print_istypeof_lemma_strict expr =
  (start_map lemma o
    get_hierarchy_map
      let
        val check_opt = let
                          val set = print_istypeof_lemma_cp_set expr;
                        in
                          (fn n1 => fn n2 => list_ex (fn (a, b) => let
                                                                     val (_, name1) = a;
                                                                   in
                                                                     (fn name2 => equal_abr_stringa name1 n1 andalso equal_abr_stringa name2 n2)
                                                                   end
                                                                     b)
                                               set)
                        end;
      in
        (fn name1 => fn (name2, name2a) => fn name3 =>
          Lemma (flattena [const_oclistypeof, isub name1, SS_base (ST "_"), name3, SS_base (ST "_"), name2],
                  [Term_rewrite (term_warning_parenthesis (term_postunary (term_annot_ocl (Term_basic [name2]) name3) (Term_basic [dot_istypeof name1])), SS_base (ST "="), Term_basic [name2a])], [],
                  by let
                       val l = map hol_definition (SS_base (ST "bot_option") :: (if equal_abr_stringa name2 (SS_base (ST "invalid")) then [SS_base (ST "invalid")] else [SS_base (ST "null_fun"), SS_base (ST "null_option")]));
                     in
                       [rule (thma (SS_base (ST "ext"))), simp_add (if check_opt name1 name3 then l else flattena [const_oclistypeof, isub name1, SS_base (ST "_"), name3] :: l)]
                     end))
      end
      (fn x => (x, ([(SS_base (ST "invalid"), SS_base (ST "invalid")), (SS_base (ST "null"), SS_base (ST "true"))], x))))
    expr;

val pRINT_istypeof_lemma_strict : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_istypeof.print_istypeof_lemma_strict"), print_istypeof_lemma_strict);

fun print_iskindof_lemma_strict x =
  start_m_gen lemma m_class_default
    (fn _ => fn _ => fn next_dataty => fn _ => fn (_, (name1, _)) => fn OclClass (name3, _, _) =>
      map (fn (name2, name2a) =>
            Lemma (flattena [const_ocliskindof, isub name1, SS_base (ST "_"), name3, SS_base (ST "_"), name2],
                    [Term_rewrite (term_warning_parenthesis (term_postunary (term_annot_ocl (Term_basic [name2]) name3) (Term_basic [dot_iskindof name1])), SS_base (ST "="), Term_basic [name2a])], [],
                    by (simp_only (map thma (flatten [[flattena [const_ocliskindof, isub name1, SS_base (ST "_"), name3]], [flattena [const_oclistypeof, isub name1, SS_base (ST "_"), name3, SS_base (ST "_"), name2]],
                                                       map (fn OclClass (n, _, _) => flattena [const_ocliskindof, isub n, SS_base (ST "_"), name3, SS_base (ST "_"), name2]) next_dataty])) ::
                         (if null next_dataty then [] else [simp]))))
        [(SS_base (ST "invalid"), SS_base (ST "invalid")), (SS_base (ST "null"), SS_base (ST "true"))])
    x;

val pRINT_iskindof_lemma_strict : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_iskindof.print_iskindof_lemma_strict"), print_iskindof_lemma_strict);

fun aux_d_e_p_t_h l_d_e_p_t_h = (case l_d_e_p_t_h of [] => [] | (class, l_b_r_e_a_d_t_h) :: l_d_e_p_t_ha => M_simp_only class :: aux_b_r_e_a_d_t_h class [] l_d_e_p_t_ha (rev l_b_r_e_a_d_t_h))
and aux_b_r_e_a_d_t_h class tactic l_d_e_p_t_h l_b_r_e_a_d_t_h =
  (case l_b_r_e_a_d_t_h of [] => tactic
    | (class0, class0_path_inh) :: l_b_r_e_a_d_t_ha =>
      M_erule (class, class0 :: mapa fst l_b_r_e_a_d_t_ha) ::
        (if null l_b_r_e_a_d_t_ha then (fn a => M_simp_b_r_e_a_d_t_h :: a) else id)
          (aux_b_r_e_a_d_t_h class ((if class0_path_inh then (if null l_d_e_p_t_h then (fn a => M_simp_d_e_p_t_h_1 :: a) else id) (aux_d_e_p_t_h l_d_e_p_t_h) else [M_simp_d_e_p_t_h_2]) @ tactic) l_d_e_p_t_h l_b_r_e_a_d_t_ha));

fun print_iskindof_up_istypeof_name name_pers name_any = flattena [SS_base (ST "not_"), const_ocliskindof, isub name_pers, SS_base (ST "_then_"), name_any, SS_base (ST "_"), const_oclistypeof, SS_base (ST "_others")];

fun print_iskindof_class_name isub_name h_name = flattena [isub_name const_ocliskindof, SS_base (ST "_"), h_name];

fun map_class_nupl2l_inh_gen f =
  map_filter id o
    m_class_gen2 id m_class_default
      (fn l_inh => fn l_subtree => fn _ => fn compare => fn (_, (name, _)) => fn OclClass (h_name, _, _) =>
        [(if equal_position compare GT
           then SOME (f l_subtree name
                       (fst (fold (fn x => fn a =>
                                    (case a of (l, (true, prev_x)) => (l, (true, prev_x))
                                      | (l, (false, prev_x)) => let
                                                                  val OclClass (n, _, next_d) = inh x;
                                                                in
                                                                  ((x, map (fn OclClass (na, la, next_da) => (OclClass (na, la, next_da), equal_abr_stringa na prev_x)) next_d) :: l, (equal_abr_stringa n h_name, n))
                                                                end))
                              l_inh ([], (false, name)))))
           else NONE)]);

fun map_class_nupl2l_inh f = map_class_nupl2l_inh_gen (fn _ => f);

fun term_preunary e1 e2 = Term_apply (e1, [e2]);

fun print_iskindof_up_istypeof x =
  (start_map lemma o
    map_class_nupl2l_inh
      (fn name_pers => fn name_pred0 =>
        let
          val (name_any, _) :: _ = name_pred0;
          val name_anya = let
                            val OclClass (name_anya, _, _) = inh name_any;
                          in
                            name_anya
                          end;
          val var_X = SS_base (ST "X");
          val var_iskin = SS_base (ST "iskin");
          val var_isdef = SS_base (ST "isdef");
          val f = (fn f => f o term_binop (Term_basic [SS_base (ST "\092<tau>")]) (SS_base (ST "\092<Turnstile>")));
        in
          Lemma_assumes
            (print_iskindof_up_istypeof_name name_pers name_anya,
              [(var_iskin, (false, f (term_preunary (Term_basic [SS_base (ST "\092<not>")])) (term_warning_parenthesis (term_postunary (term_annot_ocl (Term_basic [var_X]) name_anya) (Term_basic [dot_iskindof name_pers]))))),
                (var_isdef, (false, f id (term_app (SS_base (ST "\092<delta>")) [Term_basic [var_X]])))],
              term_binopb (SS_base (ST "\092<or>"))
                (flatten (map (fn (f_dot, a) => map (fn name_pred => f id (term_warning_parenthesis (term_postunary (term_annot_ocl (Term_basic [var_X]) name_anya) (Term_basic [f_dot name_pred])))) a)
                           [(dot_istypeof, map (fn (name_pred, _) => let
                                                                       val OclClass (n, _, _) = inh name_pred;
                                                                     in
                                                                       n
                                                                     end)
                                             name_pred0),
                             (dot_iskindof, flatten (map (fn (name_pred, _) => map (fn OclClass (n, _, _) => n) (inh_sib_unflat name_pred)) name_pred0))])),
              using [ofa (thma (print_iskindof_up_eq_asty_name name_anya)) (thma var_isdef)] ::
                map (fn xa => applya [xa])
                  (map (fn a => (case a of M_simp_only name_pred => simp_only [thma (print_iskindof_class_name (fn s => flattenb s (isub name_pred)) name_anya)]
                                  | M_erule (name_pred, next_dataty) => print_iskindof_up_istypeof_erule var_isdef next_dataty name_pred name_anya | M_simp_d_e_p_t_h_1 => simp_add [var_iskin] | M_simp_d_e_p_t_h_2 => simp
                                  | M_simp_b_r_e_a_d_t_h => simp))
                    (aux_d_e_p_t_h (map (map_prod (fn class => let
                                                                 val OclClass (classa, _, _) = inh class;
                                                               in
                                                                 classa
                                                               end)
                                          id)
                                     name_pred0))),
              done)
        end))
    x;

val pRINT_iskindof_up_istypeof : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_iskindof.print_iskindof_up_istypeof"), print_iskindof_up_istypeof);

fun print_astype_lemmas_strict x =
  start_mapa (if activate_simp_optimization
               then map lemmas o (fn expr => [lemmas_simp (SS_base (ST ""))
                                                (get_hierarchy_map (fn name1 => fn name2 => fn name3 => thma (flattena [const_oclastype, isub name1, SS_base (ST "_"), name3, SS_base (ST "_"), name2]))
                                                  (fn xa => (xa, ([SS_base (ST "invalid"), SS_base (ST "null")], xa))) expr)])
               else (fn _ => []))
    x;

val pRINT_astype_lemmas_strict : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_astype.print_astype_lemmas_strict"), print_astype_lemmas_strict);

fun print_astype_from_universe_name name = flattena [const_oclastype, isub name, SS_base (ST "_\092<AA>")];

fun print_astype_from_universe x =
  let
    val f_finish = (fn a => (case a of [] => ((id, term_binop (Term_basic [SS_base (ST "Some")]) (SS_base (ST "o"))), []) | _ :: _ => ((term_some, id), [(Term_basic [wildcard], Term_basic [SS_base (ST "None")])])));
  in
    start_m_gen definition (fn name => fn l_inh => fn _ => fn l => let
                                                                     val const_astype = print_astype_from_universe_name name;
                                                                   in
                                                                     [Definitiona (Term_rewrite (Term_basic [const_astype], SS_base (ST "="), let
                          val ((_, finish_with_some2), last_case_none) = f_finish l_inh;
                        in
                          finish_with_some2 (term_function (flatten [l, last_case_none]))
                        end))]
                                                                   end)
      (fn l_inh => fn _ => fn _ => fn compare => fn (_, (name, nl_attr)) => fn OclClass (h_name, hl_attr, _) =>
        (if equal_position compare UN then []
          else let
                 val a = f_finish l_inh;
                 val (aa, b) = a;
               in
                 let
                   val (finish_with_some1, _) = aa;
                 in
                   (fn _ => let
                              val isub_h = (fn s => flattenb s (isub h_name));
                              val pattern_complex = (fn h_namea => fn namea => fn l_extra => let
                                                                                               val isub_ha = (fn s => flattenb s (isub h_namea));
                                                                                               val isub_name = (fn s => flattenb s (isub namea));
                                                                                               val isub_n = (fn s => isub_name (flattenb s (SS_base (ST "_"))));
                                                                                               val var_name = namea;
                                                                                             in
                                                                                               term_app (isub_ha datatype_constr_name) (term_app (isub_n (isub_ha datatype_ext_constr_name)) [Term_basic [var_name]] :: l_extra)
                                                                                             end);
                              val pattern_simple = (fn namea => let
                                                                  val _ = (fn s => flattenb s (isub namea));
                                                                  val var_name = namea;
                                                                in
                                                                  Term_basic [var_name]
                                                                end);
                              val case_branch = (fn pat => fn res => [(term_app (isub_h datatype_in) [pat], finish_with_some1 res)]);
                            in
                              (case compare of EQ => let
                                                       val n = Term_basic [name];
                                                     in
                                                       case_branch n n
                                                     end
                                | LT => case_branch (pattern_simple h_name) (pattern_complex name h_name (map (fn _ => Term_basic [SS_base (ST "None")]) nl_attr))
                                | GT => case_branch (pattern_complex h_name name (map (fn _ => Term_basic [wildcard]) hl_attr)) (pattern_simple name))
                            end)
                 end
                   b
               end))
  end
    x;

val pRINT_astype_from_universe : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_astype.print_astype_from_universe"), print_astype_from_universe);

fun print_allinst_istypeof_pre x =
  (start_map lemma o
    (fn _ => [Lemma (print_allinst_istypeof_pre_name1,
                      let
                        val var_x = SS_base (ST "x");
                        val var_B = SS_base (ST "B");
                        val var_s = SS_base (ST "s");
                        val var_t = SS_base (ST "t");
                        val var_P = SS_base (ST "P");
                        val b = (fn s => Term_basic [s]);
                        val a = (fn f => fn xa => term_app f [xa]);
                        val bind = (fn symb => (fn aa => Term_bind (symb, term_binop (b var_x) (SS_base (ST "\092<in>")) (b var_B), aa)));
                        val f = (fn v => bind (SS_base (ST "\092<exists>")) (a var_P (a v (b var_x))));
                      in
                        [Term_bind (SS_base (ST "\092<forall>"), term_binop (b var_x) (SS_base (ST "\092<in>")) (b var_B), Term_rewrite (a var_s (b var_x), SS_base (ST "="), a var_t (b var_x))),
                          Term_rewrite (f var_s, SS_base (ST "="), f var_t)]
                      end,
                      [], by [simp]),
               Lemma (print_allinst_istypeof_pre_name2,
                       let
                         val var_x = SS_base (ST "x");
                         val var_X = SS_base (ST "X");
                         val var_y = SS_base (ST "y");
                         val b = (fn s => Term_basic [s]);
                         val c = (fn a => Term_paren (SS_base (ST "\092<lceil>"), SS_base (ST "\092<rceil>"), a));
                         val f = (fn a => Term_paren (SS_base (ST "\092<lfloor>"), SS_base (ST "\092<rfloor>"), a));
                         val p = (fn a => Term_paren (SS_base (ST "{"), SS_base (ST "}"), a));
                       in
                         [term_binop (b var_x) (SS_base (ST "\092<in>"))
                            (c (c (f (f (term_binop (b (SS_base (ST "Some"))) (SS_base (ST "`")) (term_parenthesis (term_binop (b var_X) (SS_base (ST "-")) (p (b (SS_base (ST "None"))))))))))),
                           Term_bind (SS_base (ST "\092<exists>"), b var_y, Term_rewrite (b var_x, SS_base (ST "="), f (f (b var_y))))]
                       end,
                       [], by [auto_simp_add []])]))
    x;

val pRINT_allinst_istypeof_pre : ('a -> 'b -> all_meta list * 'b) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_allinst.print_allinst_istypeof_pre"), print_allinst_istypeof_pre);

val print_access_dot_lemmas_id_name : abr_string = SS_base (ST "dot_accessor");

fun print_access_dot_name isub_name dot_at_when attr_ty isup_attr =
  flattena [isup_attr let
                        val dot_name = isub_name (SS_base (ST "dot"));
                      in
                        (case attr_ty of OclTy_base_void => dot_name | OclTy_base_boolean => dot_name | OclTy_base_integer => dot_name | OclTy_base_unlimitednatural => dot_name | OclTy_base_real => dot_name
                          | OclTy_base_string => dot_name | OclTy_object (OclTyObj (OclTyCore_pre _, _)) => dot_name
                          | OclTy_object (OclTyObj (OclTyCore ty_obj, _)) => flattena [dot_name, SS_base (ST "_"), natural_to_digit10 (tyObjN_ass_switch (tyObj_from ty_obj)), SS_base (ST "_")] | OclTy_collection (_, _) => dot_name
                          | OclTy_pair (_, _) => dot_name | OclTy_binding _ => dot_name | OclTy_arrow (_, _) => dot_name | OclTy_class_syn _ => dot_name | OclTy_enum _ => dot_name | OclTy_raw _ => dot_name)
                      end,
             dot_at_when];

fun apply_optim_ass_arity ty_obj v = (if less_eq_natural (tyObj_ass_arity ty_obj) (Code_Numeral.natural_of_integer (2 : IntInf.int)) then NONE else SOME v);

val var_in_post_state : abr_string = SS_base (ST "in_post_state");

val var_in_pre_state : abr_string = SS_base (ST "in_pre_state");

fun mk_dot_comment s1 s2 s3 = mk_dot s1 (flattena [s2, SS_base (ST " /*"), s3, SS_base (ST "*/")]);

fun map_class_arg_only_var0 x =
  (fn f_expr => fn f_app => fn f_lattr => fn isub_name => fn name => fn l_attr =>
    flatten (flatten (map (fn (var_in_when_state, (dot_at_when, attr_when)) =>
                            flatten (map (map (fn (attr_name, attr_ty) =>
                                                f_app isub_name name (var_in_when_state, dot_at_when) attr_ty (fn s => flattenb s (isup attr_name))
                                                  (fn s => f_expr s [(case (case attr_ty of OclTy_base_void => NONE | OclTy_base_boolean => NONE | OclTy_base_integer => NONE | OclTy_base_unlimitednatural => NONE
                                                                             | OclTy_base_real => NONE | OclTy_base_string => NONE | OclTy_object (OclTyObj (OclTyCore_pre _, _)) => NONE
                                                                             | OclTy_object (OclTyObj (OclTyCore ty_obj, _)) =>
                                                                               apply_optim_ass_arity ty_obj let
                                                                                                              val ty_obja = tyObj_from ty_obj;
                                                                                                            in
                                                                                                              (case tyObjN_role_name ty_obja of NONE => natural_to_digit10 (tyObjN_ass_switch ty_obja) | SOME sa => sa)
                                                                                                            end
                                                                             | OclTy_collection (_, _) => NONE | OclTy_pair (_, _) => NONE | OclTy_binding _ => NONE | OclTy_arrow (_, _) => NONE | OclTy_class_syn _ => NONE
                                                                             | OclTy_enum _ => NONE | OclTy_raw _ => NONE)
                                                                       of NONE => mk_dot attr_name attr_when | SOME a => mk_dot_comment attr_name attr_when a)])))
                                      (f_lattr l_attr)))
                       [(var_in_post_state, (var_at_when_hol_post, var_at_when_ocl_post)), (var_in_pre_state, (var_at_when_hol_pre, var_at_when_ocl_pre))])))
    x;

fun map_class_arg_onlya f =
  map_class_gen
    (fn isub_name => fn name => fn l_attr => fn l_inh => fn l_subtree => fn _ =>
      (case filter (fn a => (case a of OclClass (_, [], _) => false | OclClass (_, _ :: _, _) => true)) (of_linh (of_inh l_inh)) of [] => [] | a :: lista => f isub_name name (l_attr, (Tinh (a :: lista), l_subtree))));

fun map_class_arg_only f = map_class_gen (fn isub_name => fn name => fn l_attr => fn _ => fn _ => fn _ => (case l_attr of [] => [] | a :: lista => f isub_name name (a :: lista)));

fun map_class_arg_only0 f1 f2 u = append (map_class_arg_only f1 u) (map_class_arg_onlya f2 u);

fun map_class_arg_only_var_gena f_expr f = map_class_arg_only0 (map_class_arg_only_var0 f_expr f (fn l => [l])) (map_class_arg_only_var0 f_expr f (fn (_, a) => let
                                            val (aa, _) = a;
                                            val Tinh ab = aa;
                                          in
                                            map (fn OclClass (_, l, _) => l) ab
                                          end));

fun map_class_arg_only_vara x = map_class_arg_only_var_gena (fn s => fn e => term_postunary s (Term_basic e)) x;

fun print_access_dot_lemmas_id_set x =
  (if activate_simp_optimization then map_class_arg_only_vara (fn isub_name => fn _ => fn (_, dot_at_when) => fn attr_ty => fn isup_attr => fn _ => [print_access_dot_name isub_name dot_at_when attr_ty isup_attr]) else (fn _ => [])) x;

fun print_access_dot_lemmas_id x = start_mapa (fn expr => let
                                                            val name_set = print_access_dot_lemmas_id_set expr;
                                                          in
                                                            (case name_set of [] => [] | _ :: _ => map lemmas [lemmas_nosimp print_access_dot_lemmas_id_name (map thma name_set)])
                                                          end)
                                     x;

val pRINT_access_dot_lemmas_id : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_dot_lemmas_id"), print_access_dot_lemmas_id);

fun print_access_dot_lemma_cp_name isub_name dot_at_when attr_ty isup_attr = flattena [SS_base (ST "cp_"), print_access_dot_name isub_name dot_at_when attr_ty isup_attr];

fun print_access_dot_lemmas_cp x =
  (start_map lemmas o
    (fn expr => (case map_class_arg_only_vara (fn isub_name => fn _ => fn (_, dot_at_when) => fn attr_ty => fn isup_attr => fn _ => [thma (print_access_dot_lemma_cp_name isub_name dot_at_when attr_ty isup_attr)]) expr of [] => []
                  | a :: lista => [lemmas_simp (SS_base (ST "")) (a :: lista)])))
    x;

val pRINT_access_dot_lemmas_cp : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_dot_lemmas_cp"), print_access_dot_lemmas_cp);

val var_eval_extract : abr_string = SS_base (ST "eval_extract");

val print_access_dot_cp_lemmas_set : abr_string list = (if activate_simp_optimization then [hol_definition var_eval_extract] else []);

fun print_access_dot_cp_lemmas x = start_mapa (fn _ => map (fn xa => lemmas (lemmas_simp (SS_base (ST "")) [thma xa])) print_access_dot_cp_lemmas_set) x;

val pRINT_access_dot_cp_lemmas : ('a -> 'b -> all_meta list * 'b) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_dot_cp_lemmas"), print_access_dot_cp_lemmas);

fun auto_simp_add_split l = (fn a => Method_auto_simp_add_split (map Thms_single l, a));

fun insertb x = (Method_insert o map Thms_single) x;

fun hol_split s = flattena [s, SS_base (ST ".split")];

fun split_ty name = map (fn s => hol_split (flattenb s (isub name))) [datatype_ext_name, datatype_name];

fun print_iskindof_up_eq_asty x =
  (start_map lemma o
    map_class_gen_hb
      (fn _ => fn name => fn l_attr => fn _ => fn l_subtree => fn next_dataty =>
        let
          val var_X = SS_base (ST "X");
          val var_isdef = SS_base (ST "isdef");
          val f = term_binop (Term_basic [SS_base (ST "\092<tau>")]) (SS_base (ST "\092<Turnstile>"));
        in
          [Lemma_assumes
             (print_iskindof_up_eq_asty_name name, [(var_isdef, (false, f (term_app (SS_base (ST "\092<delta>")) [Term_basic [var_X]])))],
               f (term_warning_parenthesis (term_postunary (term_annot_ocl (Term_basic [var_X]) name) (Term_basic [dot_iskindof name]))),
               map applya [[simp_only [thma (hol_definition (SS_base (ST "OclValid")))], insertb [thma var_isdef]],
                            flatten (fst (mapM (fn OclClass (n, _, next) => fn accu =>
                                                 let
                                                   val a = mapM (fn _ => fn (cpt, l_sub) => let
                                                                                              val l_suba = natural_to_digit10 cpt :: l_sub;
                                                                                            in
                                                                                              (subst_l l_suba (thma (SS_base (ST "cp_OclOr"))), (succ (one_natural, plus_natural) cpt, l_suba))
                                                                                            end)
                                                             next accu;
                                                   val (l_subst, aa) = a;
                                                 in
                                                   (simp_only [thma (flattena [const_ocliskindof, isub n, SS_base (ST "_"), name])] :: l_subst, aa)
                                                 end)
                                           (OclClass (name, l_attr, next_dataty) :: rev l_subtree) (Code_Numeral.one_natural, []))),
                            [auto_simp_add_split
                               let
                                 val l = map thma (flatten ([SS_base (ST "foundation16"), hol_definition (SS_base (ST "bot_option"))] ::
                                                             map (fn OclClass (n, _, _) => [flattena [const_oclistypeof, isub n, SS_base (ST "_"), name]]) l_subtree));
                               in
                                 (if null l_subtree then l else symmetric (thma (SS_base (ST "cp_OclOr"))) :: l)
                               end
                               (SS_base (ST "option.split") :: flatten (split_ty name :: map (fn OclClass (n, _, _) => split_ty n) l_subtree))]],
               by [optiona [simp_all_add (map hol_definition [SS_base (ST "false"), SS_base (ST "true"), SS_base (ST "OclOr"), SS_base (ST "OclAnd"), SS_base (ST "OclNot")])]])]
        end))
    x;

val pRINT_iskindof_up_eq_asty : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_iskindof.print_iskindof_up_eq_asty"), print_iskindof_up_eq_asty);

fun print_astype_lemmas_const x =
  start_mapa (if activate_simp_optimization
               then map lemmas o (fn expr => [lemmas_simp (SS_base (ST ""))
                                                (get_hierarchy_map (fn name1 => fn name2 => fn name3 => thma (flattena [const_oclastype, isub name1, SS_base (ST "_"), name3, SS_base (ST "_"), name2]))
                                                  (fn xa => (xa, ([SS_base (ST "const")], xa))) expr)])
               else (fn _ => []))
    x;

val pRINT_astype_lemmas_const : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_astype.print_astype_lemmas_const"), print_astype_lemmas_const);

fun print_astype_lemma_cp_set x = (if activate_simp_optimization then map_class (fn isub_name => fn name => fn _ => fn _ => fn _ => fn _ => ((isub_name, name), name)) else (fn _ => [])) x;

fun print_astype_lemma_strict expr =
  (start_map lemma o
    get_hierarchy_map
      let
        val check_opt = let
                          val set = print_astype_lemma_cp_set expr;
                        in
                          (fn n1 => fn n2 => list_ex (fn (a, b) => let
                                                                     val (_, name1) = a;
                                                                   in
                                                                     (fn name2 => equal_abr_stringa name1 n1 andalso equal_abr_stringa name2 n2)
                                                                   end
                                                                     b)
                                               set)
                        end;
      in
        (fn name1 => fn name2 => fn name3 =>
          Lemma (flattena [const_oclastype, isub name1, SS_base (ST "_"), name3, SS_base (ST "_"), name2],
                  [Term_rewrite (term_warning_parenthesis (term_postunary (term_annot_ocl (Term_basic [name2]) name3) (Term_basic [dot_astype name1])), SS_base (ST "="), Term_basic [name2])], [],
                  by (if check_opt name1 name3 then [simp]
                       else [rule (thma (SS_base (ST "ext"))),
                              simp_add (flattena [const_oclastype, isub name1, SS_base (ST "_"), name3] ::
                                         hol_definition (SS_base (ST "bot_option")) ::
                                           map hol_definition (if equal_abr_stringa name2 (SS_base (ST "invalid")) then [SS_base (ST "invalid")] else [SS_base (ST "null_fun"), SS_base (ST "null_option")]))])))
      end
      (fn x => (x, ([SS_base (ST "invalid"), SS_base (ST "null")], x))))
    expr;

val pRINT_astype_lemma_strict : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_astype.print_astype_lemma_strict"), print_astype_lemma_strict);

fun print_allinst_iskindof_eq x =
  (start_map lemma o map_class_gen (fn isub_name => fn name => fn _ => fn _ => fn _ => fn _ => print_allinst_istypeof_single isub_name name isub_name name const_ocliskindof dot_iskindof id (fn _ => []))) x;

val pRINT_allinst_iskindof_eq : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_allinst.print_allinst_iskindof_eq"), print_allinst_iskindof_eq);

fun start_mape f fl = (fn env => start_map f (fl (d_output_sorry_dirty env) (d_ocl_semantics env)) env);

fun print_access_repr_allinst x =
  (start_mape lemma o
    (fn expr => fn (sorrya, dirty) => fn _ =>
      (if equal_optiona equal_generation_lemma_mode sorrya (SOME Gen_sorry) orelse is_none sorrya andalso dirty
        then map_class_arg_only_vara
               (fn isub_name => fn name => fn (var_in_when_state, dot_at_when) => fn attr_ty => fn isup_attr => fn dot_attr =>
                 (case attr_ty of OclTy_base_void => [] | OclTy_base_boolean => [] | OclTy_base_integer => [] | OclTy_base_unlimitednatural => [] | OclTy_base_real => [] | OclTy_base_string => []
                   | OclTy_object (OclTyObj (OclTyCore_pre _, _)) => []
                   | OclTy_object (OclTyObj (OclTyCore ty_obj, _)) =>
                     let
                       val var_tau = SS_base (ST "\092<tau>");
                       val f = term_binop (Term_basic [var_tau]) (SS_base (ST "\092<Turnstile>"));
                       val a = (fn fa => fn xa => term_app fa [xa]);
                       val b = (fn s => Term_basic [s]);
                       val var_x = SS_base (ST "x");
                     in
                       [Lemma (flattena [isup_attr (flattena [isub_name (SS_base (ST "dot_repr")), SS_base (ST "_"), natural_to_digit10 (tyObjN_ass_switch (tyObj_from ty_obj)), SS_base (ST "_")]), dot_at_when],
                                [f (a (SS_base (ST "\092<delta>")) (dot_attr (term_annot_ocl (Term_basic [var_x]) name))),
                                  let
                                    val all_inst = (if equal var_in_when_state var_in_pre_state then SS_base (ST "OclAllInstances_at_pre") else SS_base (ST "OclAllInstances_at_post"));
                                  in
                                    term_binop let
                                                 val ty_obja = tyObj_to ty_obj;
                                                 val namea = tyObjN_role_ty ty_obja;
                                                 val obj_mult = tyObjN_role_multip ty_obja;
                                               in
                                                 f (term_app (if single_multip obj_mult then SS_base (ST "UML_Set.OclIncludes") else SS_base (ST "UML_Set.OclIncludesAll"))
                                                     [a all_inst (b namea), let
                                                                              val xa = dot_attr (b var_x);
                                                                            in
                                                                              (if is_sequence obj_mult then a (SS_base (ST "OclAsSet\092<^sub>S\092<^sub>e\092<^sub>q")) xa else xa)
                                                                            end])
                                               end
                                      (SS_base (ST "\092<and>")) (f (term_app (SS_base (ST "UML_Set.OclIncludes")) [a all_inst (b name), b var_x]))
                                  end],
                                [], sorry)]
                     end
                   | OclTy_collection (_, _) => [] | OclTy_pair (_, _) => [] | OclTy_binding _ => [] | OclTy_arrow (_, _) => [] | OclTy_class_syn _ => [] | OclTy_enum _ => [] | OclTy_raw _ => []))
               expr
        else [])))
    x;

val pRINT_access_repr_allinst : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_access.print_access_repr_allinst"), print_access_repr_allinst);

fun print_access_lemma_strict_name isub_name dot_at_when attr_ty isup_attr name_invalid = flattena [print_access_dot_name isub_name dot_at_when attr_ty isup_attr, SS_base (ST "_"), name_invalid];

fun print_access_lemma_strict expr =
  (start_map lemma o
    map_class_arg_only_vara
      (fn isub_name => fn name => fn (_, dot_at_when) => fn attr_ty => fn isup_attr => fn dot_attr =>
        map (fn (name_invalid, meth_invalid) =>
              Lemma (print_access_lemma_strict_name isub_name dot_at_when attr_ty isup_attr name_invalid,
                      [Term_rewrite (dot_attr (term_annot_ocl (Term_basic [name_invalid]) name), SS_base (ST "="), Term_basic [SS_base (ST "invalid")])], [],
                      (if null (print_access_dot_lemmas_id_set expr) orelse null print_access_dot_cp_lemmas_set then sorry
                        else by [rule (thma (SS_base (ST "ext"))),
                                  simp_add2 [thms print_access_dot_lemmas_id_name]
                                    (map hol_definition let
                                                          val l = let
                                                                    val l = SS_base (ST "bot_option") :: meth_invalid;
                                                                  in
                                                                    (if null (print_access_dot_lemmas_id_set expr) then flattena [isup_attr (isub_name (SS_base (ST "dot"))), dot_at_when] :: l else l)
                                                                  end;
                                                        in
                                                          (if null print_access_dot_cp_lemmas_set then SS_base (ST "eval_extract") :: l else l)
                                                        end)])))
          [(SS_base (ST "invalid"), [SS_base (ST "invalid")]), (SS_base (ST "null"), [SS_base (ST "null_fun"), SS_base (ST "null_option")])]))
    expr;

val pRINT_access_lemma_strict : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_lemma_strict"), print_access_lemma_strict);

val var_reconst_basetype_void : abr_string = SS_base (ST "reconst_basetype\092<^sub>V\092<^sub>o\092<^sub>i\092<^sub>d");

val var_reconst_basetype : abr_string = SS_base (ST "reconst_basetype");

val var_Abs_Void : abr_string = SS_base (ST "Abs_Void\092<^sub>b\092<^sub>a\092<^sub>s\092<^sub>e");

fun print_access_eval_extract uu =
  start_map definition
    let
      val lets = (fn var => fn def => Definitiona (Term_rewrite (Term_basic [var], SS_base (ST "="), def)));
      val a = (fn f => fn x => term_app f [x]);
      val b = (fn s => Term_basic [s]);
    in
      [let
         val var_x = SS_base (ST "x");
         val var_f = SS_base (ST "f");
         val some_some = (fn x => term_some (term_some x));
         val var_obj = SS_base (ST "obj");
       in
         Definitiona (Term_rewrite
                       (Term_basic [var_eval_extract, var_x, var_f], SS_base (ST "="),
                         term_lam (SS_base (ST "\092<tau>"))
                           (fn var_tau =>
                             term_case (Term_basic [var_x, var_tau])
                               [(some_some (Term_basic [var_obj]), term_app var_f [term_app (SS_base (ST "oid_of")) [Term_basic [var_obj]], Term_basic [var_tau]]),
                                 (Term_basic [wildcard], Term_basic [SS_base (ST "invalid"), var_tau])])))
       end,
        lets var_in_pre_state (b (SS_base (ST "fst"))), lets var_in_post_state (b (SS_base (ST "snd"))), lets var_reconst_basetype term_basety,
        let
          val var_x = SS_base (ST "x");
        in
          Definitiona (Term_rewrite (Term_basic [var_reconst_basetype_void, var_x], SS_base (ST "="), term_binop (Term_basic [var_Abs_Void]) (SS_base (ST "o")) (a var_reconst_basetype (b var_x))))
        end]
    end;

val pRINT_access_eval_extract : ('a -> 'b -> all_meta list * 'b) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_eval_extract"), print_access_eval_extract);

fun map_class_arg_only_var_gen f_expr f1 f2 = map_class_arg_only0 (map_class_arg_only_var0 f_expr f1 (fn l => [l])) (map_class_arg_only_var0 f_expr f2 (fn (_, a) => let
                                                 val (aa, _) = a;
                                                 val Tinh ab = aa;
                                               in
                                                 map (fn OclClass (_, l, _) => l) ab
                                               end));

fun map_class_arg_only_var x = map_class_arg_only_var_gen (fn s => fn e => term_postunary s (Term_basic e)) x;

fun print_access_dot_lemma_cp x =
  (start_map lemma o
    let
      val auto = (fn l => auto_simp_add2 [thms print_access_dot_lemmas_id_name] (map hol_definition (SS_base (ST "cp") :: l)));
    in
      map_class_arg_only_var
        (fn isub_name => fn name => fn (_, dot_at_when) => fn attr_ty => fn isup_attr => fn dot_attr =>
          [Lemma (print_access_dot_lemma_cp_name isub_name dot_at_when attr_ty isup_attr, [term_app (SS_base (ST "cp")) [term_lam (SS_base (ST "X")) (fn var_x => dot_attr (term_annot_ocl (Term_basic [var_x]) name))]], [],
                   by [auto (if null print_access_dot_cp_lemmas_set then [var_eval_extract, flattena [isup_attr (isub_name (SS_base (ST "dot"))), dot_at_when]] else [])])])
        (fn isub_name => fn name => fn (_, dot_at_when) => fn attr_ty => fn isup_attr => fn dot_attr =>
          [Lemma (print_access_dot_lemma_cp_name isub_name dot_at_when attr_ty isup_attr, [term_app (SS_base (ST "cp")) [term_lam (SS_base (ST "X")) (fn var_x => dot_attr (term_annot_ocl (Term_basic [var_x]) name))]], [],
                   (if null print_access_dot_cp_lemmas_set then sorry else by [auto []]))])
    end)
    x;

val pRINT_access_dot_lemma_cp : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_dot_lemma_cp"), print_access_dot_lemma_cp);

val var_deref : abr_string = SS_base (ST "deref");

fun print_access_deref_assocs_namea name_from isub_name isup_attr = flattena [var_deref, SS_base (ST "_"), isub_name var_assocs, SS_base (ST "_"), natural_to_digit10 name_from, isup_attr (SS_base (ST "_"))];

fun print_access_deref_assocs_name name_from isub_name attr = print_access_deref_assocs_namea name_from isub_name (fn s => flattenb s (isup attr));

val var_deref_assocs : abr_string = SS_base (ST "deref_assocs");

fun start_mapd f fl = (fn env => start_map f (fl (d_ocl_semantics env)) env);

fun print_access_deref_assocs x =
  (start_mapd definition o
    (fn expr => fn design_analysis =>
      (if equal_generation_semantics_ocl design_analysis Gen_only_design then (fn _ => [])
        else (fn expra => flatten (flatten (map_class (fn isub_name => fn _ => fn l_attr => fn l_inherited => fn _ => fn _ =>
                                                        let
                                                          val l_inheriteda = map_class_inh l_inherited;
                                                          val var_fst_snd = SS_base (ST "fst_snd");
                                                          val var_f = SS_base (ST "f");
                                                          val b = (fn s => Term_basic [s]);
                                                        in
                                                          flatten (map (map (fn a => (case a of (_, OclTy_base_void) => [] | (_, OclTy_base_boolean) => [] | (_, OclTy_base_integer) => [] | (_, OclTy_base_unlimitednatural) => []
                                                                                       | (_, OclTy_base_real) => [] | (_, OclTy_base_string) => [] | (_, OclTy_object (OclTyObj (OclTyCore_pre _, _))) => []
                                                                                       | (attr, OclTy_object (OclTyObj (OclTyCore ty_obj, _))) =>
                                                                                         let
                                                                                           val name_from = tyObjN_ass_switch (tyObj_from ty_obj);
                                                                                         in
                                                                                           [Definitiona (Term_rewrite
                                                                                                          (Term_basic [print_access_deref_assocs_name name_from isub_name attr, var_fst_snd, var_f], SS_base (ST "="),
                                                                                                            term_binop (term_app var_deref_assocs
   (map b [var_fst_snd, print_access_choose_name (tyObj_ass_arity ty_obj) name_from (tyObjN_ass_switch (tyObj_to ty_obj)), print_access_oid_uniq_name name_from isub_name attr, var_f]))
                                                                                                              (SS_base (ST "\092<circ>")) (b (SS_base (ST "oid_of")))))]
                                                                                         end
                                                                                       | (_, OclTy_collection (_, _)) => [] | (_, OclTy_pair (_, _)) => [] | (_, OclTy_binding _) => [] | (_, OclTy_arrow (_, _)) => []
                                                                                       | (_, OclTy_class_syn _) => [] | (_, OclTy_enum _) => [] | (_, OclTy_raw _) => [])))
                                                                    (l_attr :: l_inheriteda))
                                                        end)
                                             expra))))
        expr))
    x;

val pRINT_access_deref_assocs : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun =
  Embedding_fun_info (SS_base (ST "Floor1_access.print_access_deref_assocs"), print_access_deref_assocs);

fun print_istypeof_up_larger_name name_pers name_any = flattena [SS_base (ST "actualType"), isub name_pers, SS_base (ST "_larger_staticType"), isub name_any];

fun map_class_nupl2_inh_large f = map_filter id o m_classa id (fn compare => fn (_, (name, _)) => fn OclClass (h_name, _, _) => (if equal_position compare GT orelse equal_position compare UN then SOME (f name h_name) else NONE));

fun print_istypeof_up_larger x =
  (start_map lemma o
    map_class_nupl2_inh_large
      (fn name_pers => fn name_any =>
        let
          val var_X = SS_base (ST "X");
          val var_isdef = SS_base (ST "isdef");
          val f = term_binop (Term_basic [SS_base (ST "\092<tau>")]) (SS_base (ST "\092<Turnstile>"));
        in
          Lemma_assumes
            (print_istypeof_up_larger_name name_pers name_any, [(var_isdef, (false, f (term_app (SS_base (ST "\092<delta>")) [Term_basic [var_X]])))],
              f (term_binop (term_warning_parenthesis (term_postunary (term_annot_ocl (Term_basic [var_X]) name_pers) (Term_basic [dot_istypeof name_any]))) (SS_base (ST "\092<triangleq>")) (Term_basic [SS_base (ST "false")])),
              [using [thma var_isdef]],
              by [auto_simp_add
                    (flattena [const_oclistypeof, isub name_any, SS_base (ST "_"), name_pers] :: SS_base (ST "foundation22") :: SS_base (ST "foundation16") :: map hol_definition [SS_base (ST "null_option"), SS_base (ST "bot_option")])])
        end))
    x;

val pRINT_istypeof_up_larger : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_istypeof.print_istypeof_up_larger"), print_istypeof_up_larger);

fun print_istypeof_up_d_cast_name name_mid name_any name_pers = flattena [SS_base (ST "down_cast_type"), isub name_mid, SS_base (ST "_from_"), name_any, SS_base (ST "_to_"), name_pers];

fun fold_less_gen f_gen f_jump f l = (case l of [] => id | x :: xs => (fn acc => fold_less_gen f_gen f_jump f xs (f_gen (f x) xs (f_jump acc))));

fun fold_less2 x = fold_less_gen fold x;

fun f_less2 x = (fn l => rev (fst (fold_less2 (fn (la, _) => (la, NONE)) (fn xa => fn y => fn (la, _) => ((xa, y) :: la, SOME y)) l ([], NONE)))) x;

fun m_class_gen3_GE base_attr f print =
  let
    val m_base_attr = (fn OclClass (n, l, a) => OclClass (n, base_attr l, a));
    val f_base_attr = map m_base_attr;
  in
    map_class_gen_hb
      (fn _ => fn name => fn _ => fn l_inh => fn l_subtree => fn next_dataty =>
        let
          val print_astype = print (map (map_linh m_base_attr) l_inh) (f_base_attr l_subtree) next_dataty;
        in
          flatten [f (flatten (map (fn (_, a) => map (fn OclClass (h_name, _, _) => print_astype name h_name h_name) a) [(GT, of_linh l_inh)])),
                    f (flatten (map (fn (_, l) => map (fn (a, b) => print_astype name a b) (f_less2 (map (fn OclClass (n, _, _) => n) l))) [(GT, of_linh l_inh)])),
                    f (flatten (map (fn (_, l) => flatten (map (fn OclClass (h_name, _, _) => map (fn OclClass (sib_name, _, _) => print_astype name sib_name h_name) (of_linh_sib l_inh)) l)) [(GT, of_linh l_inh)]))]
        end)
  end;

fun m_class3_GE base_attr f print = m_class_gen3_GE base_attr f (fn _ => fn _ => fn _ => print);

fun map_class_nupl3_GE_inh x = m_class3_GE id id x;

fun print_istypeof_up_d_cast expr =
  (start_map lemma o
    map_class_nupl3_GE_inh
      (fn name_pers => fn name_mid => fn name_any =>
        let
          val var_X = SS_base (ST "X");
          val var_istyp = SS_base (ST "istyp");
          val var_isdef = SS_base (ST "isdef");
          val f = term_binop (Term_basic [SS_base (ST "\092<tau>")]) (SS_base (ST "\092<Turnstile>"));
        in
          Lemma_assumes
            (print_istypeof_up_d_cast_name name_mid name_any name_pers,
              [(var_istyp, (false, f (term_warning_parenthesis (term_postunary (term_annot_ocl (Term_basic [var_X]) name_any) (Term_basic [dot_istypeof name_mid]))))),
                (var_isdef, (false, f (term_app (SS_base (ST "\092<delta>")) [Term_basic [var_X]])))],
              f (term_binop (term_warning_parenthesis (term_postunary (Term_basic [var_X]) (Term_basic [dot_astype name_pers]))) (SS_base (ST "\092<triangleq>")) (Term_basic [SS_base (ST "invalid")])),
              [using (map thma [var_istyp, var_isdef]),
                applya [auto_simp_add_split
                          (map thma (flattena [const_oclastype, isub name_pers, SS_base (ST "_"), name_any] ::
                                      SS_base (ST "foundation22") :: SS_base (ST "foundation16") :: map hol_definition [SS_base (ST "null_option"), SS_base (ST "bot_option")]))
                          (split_ty name_any)]],
              by [simp_add let
                             val l = map hol_definition [SS_base (ST "OclValid"), SS_base (ST "false"), SS_base (ST "true")];
                           in
                             (if equal_abr_stringa name_mid name_any andalso not (null (print_istypeof_lemma_cp_set expr)) then l else flattena [const_oclistypeof, isub name_mid, SS_base (ST "_"), name_any] :: l)
                           end])
        end))
    expr;

val pRINT_istypeof_up_d_cast : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_istypeof.print_istypeof_up_d_cast"), print_istypeof_up_d_cast);

fun print_istypeof_lemmas_id x =
  start_mapa (fn expr => let
                           val name_set = print_istypeof_lemma_cp_set expr;
                         in
                           (case name_set of [] => [] | _ :: _ => map lemmas [lemmas_simp (SS_base (ST "")) (map (fn (a, b) => let
           val (isub_name, _) = a;
         in
           (fn name => thma (flattena [isub_name const_oclistypeof, SS_base (ST "_"), name]))
         end
           b)
                                                                                                              name_set)])
                         end)
    x;

val pRINT_istypeof_lemmas_id : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_istypeof.print_istypeof_lemmas_id"), print_istypeof_lemmas_id);

fun print_istypeof_lemmas_cp x =
  start_mapa (if activate_simp_optimization
               then map lemmas o (fn expr => [lemmas_simp (SS_base (ST ""))
                                                (get_hierarchy_map (fn name1 => fn name2 => fn name3 => thma (flattena [SS_base (ST "cp_"), const_oclistypeof, isub name1, SS_base (ST "_"), name3, SS_base (ST "_"), name2]))
                                                  (fn xa => (xa, (xa, xa))) expr)])
               else (fn _ => []))
    x;

val pRINT_istypeof_lemmas_cp : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_istypeof.print_istypeof_lemmas_cp"), print_istypeof_lemmas_cp);

fun map_class_nupl2_inha f =
  map_filter id o
    m_class_gen2 id m_class_default
      (fn l_inh => fn _ => fn _ => fn compare => fn (_, (name, _)) => fn OclClass (h_name, _, h_subtree) =>
        [(if equal_position compare GT then SOME (f name h_name (map (fn x => (x, member equal_ocl_class (of_linh l_inh) x)) h_subtree)) else NONE)]);

fun print_iskindof_up_larger x =
  (start_map lemma o
    map_class_nupl2_inha
      (fn name_pers => fn name_any => fn name_pred =>
        let
          val var_X = SS_base (ST "X");
          val var_isdef = SS_base (ST "isdef");
          val f = term_binop (Term_basic [SS_base (ST "\092<tau>")]) (SS_base (ST "\092<Turnstile>"));
          val disjI1 = SS_base (ST "foundation25");
          val disjI2 = SS_base (ST "foundation25'");
        in
          Lemma_assumes
            (print_iskindof_up_larger_name name_pers name_any, [(var_isdef, (false, f (term_app (SS_base (ST "\092<delta>")) [Term_basic [var_X]])))],
              f (term_warning_parenthesis (term_postunary (term_annot_ocl (Term_basic [var_X]) name_pers) (Term_basic [dot_iskindof name_any]))),
              [applya [simp_only [thma (flattena [const_ocliskindof, isub name_any, SS_base (ST "_"), name_pers])]]],
              by let
                   val SOME meth_last :: l =
                     fst (foldr (fn cl => fn a =>
                                  (case a of (l, true) => (l, true)
                                    | (l, false) => let
                                                      val v = let
                                                                val (OclClass (n, _, _), inh) = cl;
                                                              in
                                                                (if equal_abr_stringa n name_pers then SOME (print_iskindof_up_eq_asty_name name_pers) else (if inh then SOME (print_iskindof_up_larger_name name_pers n) else NONE))
                                                              end;
                                                    in
                                                      (v :: l, not (is_none v))
                                                    end))
                           name_pred ([], false));
                 in
                   map rule (flatten [map (fn _ => thma disjI1) l, [thma disjI2], [ofa (thma meth_last) (thma var_isdef)]])
                 end)
        end))
    x;

val pRINT_iskindof_up_larger : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_iskindof.print_iskindof_up_larger"), print_iskindof_up_larger);

fun map_class_nupl3_LE_inh f = flatten o map_class_nupl2l_inh_gen (fn l_subtree => fn x => fn l => map (fn name_bot => f name_bot x l) (x :: map (fn OclClass (n, _, _) => n) l_subtree));

fun elim x = Method_elim x;

fun print_iskindof_up_d_cast x =
  (start_map lemma o
    map_class_nupl3_LE_inh
      (fn name_pers => fn name_mid => fn name_pred0 =>
        let
          val (name_any, _) :: _ = name_pred0;
          val name_anya = let
                            val OclClass (name_anya, _, _) = inh name_any;
                          in
                            name_anya
                          end;
          val var_X = SS_base (ST "X");
          val var_iskin = SS_base (ST "iskin");
          val var_isdef = SS_base (ST "isdef");
          val f = (fn f => f o term_binop (Term_basic [SS_base (ST "\092<tau>")]) (SS_base (ST "\092<Turnstile>")));
        in
          Lemma_assumes
            (flattena [SS_base (ST "down_cast_kind"), isub name_mid, SS_base (ST "_from_"), name_anya, SS_base (ST "_to_"), name_pers],
              [(var_iskin, (false, f (term_preunary (Term_basic [SS_base (ST "\092<not>")])) (term_warning_parenthesis (term_postunary (term_annot_ocl (Term_basic [var_X]) name_anya) (Term_basic [dot_iskindof name_mid]))))),
                (var_isdef, (false, f id (term_app (SS_base (ST "\092<delta>")) [Term_basic [var_X]])))],
              f id (term_binop (term_warning_parenthesis (term_postunary (Term_basic [var_X]) (Term_basic [dot_astype name_pers]))) (SS_base (ST "\092<triangleq>")) (Term_basic [SS_base (ST "invalid")])),
              flatten let
                        val name_pred_inh = map (fn (name_pred, _) => inh name_pred) name_pred0;
                        val name_pred_inh_sib_gen = flatten (map (fn (name_pred, _) => inh_sib name_pred) name_pred0);
                        val name_pred_inh_sib = map fst name_pred_inh_sib_gen;
                        val f0 = (fn name_pred => let
                                                    val name_preda = let
                                                                       val OclClass (n, _, _) = name_pred;
                                                                     in
                                                                       n
                                                                     end;
                                                  in
                                                    [rule (thma (print_istypeof_up_d_cast_name name_preda name_anya name_pers)), simp_only [], simp_only [thma var_isdef]]
                                                  end);
                      in
                        [applya (insertb [oF_l (thma (print_iskindof_up_istypeof_name name_mid name_anya)) (map thma [var_iskin, var_isdef])] ::
                                  (case flatten [name_pred_inh, name_pred_inh_sib] of [] => [] | [_] => [] | _ :: _ :: _ => [elim (thma (SS_base (ST "disjE")))]))] ::
                          map (applya o f0) name_pred_inh ::
                            map (fn (OclClass (name_pred, l_attr, next_d), l_subtree) =>
                                  map applya [[drule (ofa (thma (print_iskindof_up_istypeof_unfold_name name_pred name_anya)) (thma var_isdef))],
                                               (if null next_d then f0 (OclClass (name_pred, l_attr, next_d))
                                                 else [auto_simp_add (var_isdef :: map (fn OclClass (name_preda, _, _) => print_istypeof_up_d_cast_name name_preda name_anya name_pers) l_subtree)])])
                              name_pred_inh_sib_gen
                      end,
              done)
        end))
    x;

val pRINT_iskindof_up_d_cast : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_iskindof.print_iskindof_up_d_cast"), print_iskindof_up_d_cast);

fun print_iskindof_lemma_cp_set x = (if activate_simp_optimization then map_class (fn isub_name => fn name => fn _ => fn _ => fn _ => fn _ => ((isub_name, name), name)) else (fn _ => [])) x;

fun print_iskindof_lemmas_id x =
  start_mapa (fn expr => let
                           val name_set = print_iskindof_lemma_cp_set expr;
                         in
                           (case name_set of [] => [] | _ :: _ => map lemmas [lemmas_simp (SS_base (ST "")) (map (fn (a, b) => let
           val (isub_name, _) = a;
         in
           (fn name => thma (flattena [isub_name const_ocliskindof, SS_base (ST "_"), name]))
         end
           b)
                                                                                                              name_set)])
                         end)
    x;

val pRINT_iskindof_lemmas_id : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_iskindof.print_iskindof_lemmas_id"), print_iskindof_lemmas_id);

fun print_iskindof_lemmas_cp x =
  start_mapa (if activate_simp_optimization
               then map lemmas o (fn expr => [lemmas_simp (SS_base (ST ""))
                                                (get_hierarchy_map (fn name1 => fn name2 => fn name3 => thma (flattena [SS_base (ST "cp_"), const_ocliskindof, isub name1, SS_base (ST "_"), name3, SS_base (ST "_"), name2]))
                                                  (fn xa => (xa, (xa, xa))) expr)])
               else (fn _ => []))
    x;

val pRINT_iskindof_lemmas_cp : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_iskindof.print_iskindof_lemmas_cp"), print_iskindof_lemmas_cp);

fun print_infra_enum_synonym uu env =
  ((flatten o map (fn a => (case a of META_enum _ => [] | META_class_raw (_, _) => [] | META_association _ => [] | META_ass_class (_, _) => [] | META_ctxt (_, _) => [] | META_haskell _ => []
                             | META_class_synonym (OclClassSynonym (n1, n2)) => [type_synonym (type_synonyma (pref_ty_syn n1) (Typ_base (str_hol_of_ty_all (fn aa => fn _ => aa) id n2)))] | META_instance _ => [] | META_def_base_l _ => []
                             | META_def_state (_, _) => [] | META_def_transition (_, _) => [] | META_class_tree _ => [] | META_flush_all _ => [] | META_generic _ => [])))
     (fst (find_class_ass env)),
    env);

val pRINT_infra_enum_synonym : ('a -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_infra.print_infra_enum_synonym"), print_infra_enum_synonym);

fun metis0 x = (fn a => Method_metis (x, a));

fun print_astype_lemma_const expr =
  (start_map lemma o
    get_hierarchy_map
      let
        val a = (fn f => fn x => term_app f [x]);
        val b = (fn s => Term_basic [s]);
        val d = hol_definition;
        val _ = let
                  val set = print_astype_lemma_cp_set expr;
                in
                  (fn n1 => fn n2 => list_ex (fn (aa, ba) => let
                                                               val (_, name1) = aa;
                                                             in
                                                               (fn name2 => equal_abr_stringa name1 n1 andalso equal_abr_stringa name2 n2)
                                                             end
                                                               ba)
                                       set)
                end;
        val var_X = SS_base (ST "X");
      in
        (fn name1 => fn name2 => fn name3 =>
          let
            val n = flattena [const_oclastype, isub name1, SS_base (ST "_"), name3];
          in
            Lemma (flattena [n, SS_base (ST "_"), name2], map (a (SS_base (ST "const"))) [term_annot (b var_X) (wrap_oclty name3), term_postunary (b var_X) (Term_basic [dot_astype name1])], [],
                    by [simp_add [d (SS_base (ST "const"))],
                         optiona [metis0 [SS_base (ST "no_types")] (map thma (n :: SS_base (ST "prod.collapse") :: map d [SS_base (ST "bot_option"), SS_base (ST "invalid"), SS_base (ST "null_fun"), SS_base (ST "null_option")]))]])
          end)
      end
      (fn x => (x, ([SS_base (ST "const")], x))))
    expr;

val pRINT_astype_lemma_const : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_astype.print_astype_lemma_const"), print_astype_lemma_const);

fun oidSucAssoc x = (fn Oids (n1, n2, n3) => Oids (n1, succ (one_natural, plus_natural) n2, succ (one_natural, plus_natural) n3)) x;

fun oidGetAssoc x = (fn Oids (_, n, _) => Oid n) x;

fun print_access_oid_uniq_gen thy_def d_ocl_oid_start_upd def_rewrite =
  (fn expr => fn env =>
    let
      val (l, oid_start) =
        let
          val (l, (acc, _)) =
            fold_class (fn isub_name => fn name => fn l_attr => fn l_inh => fn _ => fn _ => fn cpt =>
                         let
                           val l_inha = map (fn OclClass (_, l, _) => l) (of_inh l_inh);
                           val a = mapM (mapM (fn a => (case a of (_, OclTy_base_void) => (fn aa => ([], aa)) | (_, OclTy_base_boolean) => (fn aa => ([], aa)) | (_, OclTy_base_integer) => (fn aa => ([], aa))
                                                         | (_, OclTy_base_unlimitednatural) => (fn aa => ([], aa)) | (_, OclTy_base_real) => (fn aa => ([], aa)) | (_, OclTy_base_string) => (fn aa => ([], aa))
                                                         | (_, OclTy_object (OclTyObj (OclTyCore_pre _, _))) => (fn aa => ([], aa))
                                                         | (attr, OclTy_object (OclTyObj (OclTyCore ty_obj, _))) =>
                                                           let
                                                             val obj_oid = tyObj_ass_id ty_obj;
                                                             val obj_name_from_nat = tyObjN_ass_switch (tyObj_from ty_obj);
                                                           in
                                                             (fn (cpta, rbt) =>
                                                               let
                                                                 val aa = (case lookupa equal_natural rbt obj_oid of NONE => (cpta, (oidSucAssoc cpta, insert equal_natural obj_oid cpta rbt)) | SOME cpt_obj => (cpt_obj, (cpta, rbt)));
                                                                 val (cpt_obj, ab) = aa;
                                                               in
                                                                 ([def_rewrite obj_name_from_nat name isub_name attr (oidGetAssoc cpt_obj)], ab)
                                                               end)
                                                           end
                                                         | (_, OclTy_collection (_, _)) => (fn aa => ([], aa)) | (_, OclTy_pair (_, _)) => (fn aa => ([], aa)) | (_, OclTy_binding _) => (fn aa => ([], aa))
                                                         | (_, OclTy_arrow (_, _)) => (fn aa => ([], aa)) | (_, OclTy_class_syn _) => (fn aa => ([], aa)) | (_, OclTy_enum _) => (fn aa => ([], aa))
                                                         | (_, OclTy_raw _) => (fn aa => ([], aa)))))
                                     (l_attr :: l_inha) cpt;
                           val (l, aa) = a;
                         in
                           (flatten (flatten l), aa)
                         end)
              (d_ocl_oid_start env, emptya) expr;
        in
          (flatten l, acc)
        end;
    in
      (map thy_def l, d_ocl_oid_start_upd env oid_start)
    end);

fun print_access_oid_uniq_mlname name_from_nat name attr = flattena [var_oid_uniq, name, SS_base (ST "_"), natural_to_digit10 name_from_nat, SS_base (ST "_"), attr];

fun rewrite_val e1 s e2 = SML_top [SML_val_fun (SOME Sval, rewrite e1 s e2)];

fun oid s = (fn Oid n => basic [flattenb s (natural_to_digit10 n)]);

fun print_access_oid_uniq_ml x =
  print_access_oid_uniq_gen ml (fn xa => fn _ => xa)
    (fn obj_name_from_nat => fn name => fn _ => fn attr => fn cpt_obj => SMLa (rewrite_val (basic [print_access_oid_uniq_mlname obj_name_from_nat name attr]) (SS_base (ST "=")) (oid (SS_base (ST "")) cpt_obj))) x;

val pRINT_access_oid_uniq_ml : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_oid_uniq_ml"), print_access_oid_uniq_ml);

fun print_istypeof_lemma_cp expr =
  (start_map lemma o
    get_hierarchy_map
      let
        val check_opt = let
                          val set = print_istypeof_lemma_cp_set expr;
                        in
                          (fn n1 => fn n2 => list_ex (fn (a, b) => let
                                                                     val (_, name1) = a;
                                                                   in
                                                                     (fn name2 => equal_abr_stringa name1 n1 andalso equal_abr_stringa name2 n2)
                                                                   end
                                                                     b)
                                               set)
                        end;
      in
        (fn name1 => fn name2 => fn name3 =>
          Lemma (flattena [SS_base (ST "cp_"), const_oclistypeof, isub name1, SS_base (ST "_"), name3, SS_base (ST "_"), name2],
                  let
                    val var_p = SS_base (ST "p");
                  in
                    map (fn x => term_app (SS_base (ST "cp")) [x])
                      [Term_basic [var_p],
                        term_lam (SS_base (ST "x")) (fn var_x => term_warning_parenthesis (term_postunary (term_annot_ocl (term_app var_p [term_annot_ocl (Term_basic [var_x]) name3]) name2) (Term_basic [dot_istypeof name1])))]
                  end,
                  [], by [rule (thma (SS_base (ST "cpI1"))), (if check_opt name1 name2 then simp else simp_add [flattena [const_oclistypeof, isub name1, SS_base (ST "_"), name2]])]))
      end
      (fn x => (x, (x, x))))
    expr;

val pRINT_istypeof_lemma_cp : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_istypeof.print_istypeof_lemma_cp"), print_istypeof_lemma_cp);

fun print_istypeof_defined_name isub_name h_name = flattena [isub_name const_oclistypeof, SS_base (ST "_"), h_name, SS_base (ST "_defined")];

fun thena x = (fn a => Thm_THEN (x, a));

fun print_istypeof_defineda x =
  start_m lemma m_class_default
    (fn _ => fn (isub_name, (name, _)) => fn OclClass (h_name, _, _) =>
      let
        val var_X = SS_base (ST "X");
        val var_isdef = SS_base (ST "isdef");
        val f = (fn e => term_binop (Term_basic [SS_base (ST "\092<tau>")]) (SS_base (ST "\092<Turnstile>")) (term_app (SS_base (ST "\092<delta>")) [e]));
      in
        [Lemma_assumes
           (print_istypeof_defined_namea isub_name h_name, [(var_isdef, (false, f (Term_basic [var_X])))], f (term_postunary (term_annot_ocl (Term_basic [var_X]) h_name) (Term_basic [dot_istypeof name])), [],
             by [rule (ofa (thma (print_istypeof_defined_name isub_name h_name)) (thena (thma var_isdef) (thma (SS_base (ST "foundation20")))))])]
      end)
    x;

val pRINT_istypeof_defineda : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_istypeof.print_istypeof_defined'"), print_istypeof_defineda);

fun m_class_gen3 base_attr f print =
  let
    val m_base_attr = (fn OclClass (n, l, a) => OclClass (n, base_attr l, a));
    val f_base_attr = map m_base_attr;
  in
    map_class_gen_hb
      (fn _ => fn name => fn nl_attr => fn l_inh => fn l_subtree => fn next_dataty =>
        let
          val print_astype = print (map (map_linh m_base_attr) l_inh) (f_base_attr l_subtree) next_dataty;
        in
          f (flatten let
                       val l_tree = map (fn (cmp, l) => (cmp, f_base_attr l)) [(EQ, [OclClass (name, nl_attr, next_dataty)]), (GT, of_linh l_inh), (LT, l_subtree), (UN, of_linh_sib l_inh)];
                     in
                       flatten (map (fn (_, a) => map (fn OclClass (h_name, _, _) => flatten (map (fn (_, aa) => map (fn OclClass (hh_name, _, _) => print_astype name h_name hh_name) aa) l_tree)) a) l_tree)
                     end)
        end)
  end;

fun start_m_3_gen final print = start_mapb final o (fn expr => fn base_attr => fn _ => fn _ => m_class_gen3 base_attr id print expr);

fun plus x = Method_plus x;

fun print_iskindof_lemma_cp x =
  start_m_3_gen lemma
    (fn _ => fn _ => fn next_dataty => fn name1 => fn name2 => fn name3 =>
      let
        val lemma_name = flattena [SS_base (ST "cp_"), const_ocliskindof, isub name1, SS_base (ST "_"), name3, SS_base (ST "_"), name2];
        val lemma_spec =
          let
            val var_p = SS_base (ST "p");
          in
            map (fn xa => term_app (SS_base (ST "cp")) [xa])
              [Term_basic [var_p],
                term_lam (SS_base (ST "x")) (fn var_x => term_warning_parenthesis (term_postunary (term_annot_ocl (term_app var_p [term_annot_ocl (Term_basic [var_x]) name3]) name2) (Term_basic [dot_iskindof name1])))]
          end;
        val lem_simp1 = simp_only [thma (flattena [const_ocliskindof, isub name1, SS_base (ST "_"), name2])];
        val lem_simp2 = simp_only [thma (flattena [SS_base (ST "cp_"), const_oclistypeof, isub name1, SS_base (ST "_"), name3, SS_base (ST "_"), name2])];
        val a = (if null next_dataty then ([], by [lem_simp1, lem_simp2])
                  else ([[lem_simp1],
                          [plus [rule (wherea (thma (SS_base (ST "cpI2"))) [(SS_base (ST "f"), term_parenthesis (Term_basic [SS_base (ST "or")]))]), plus [rule (thma (SS_base (ST "allI")))], rule (thma (SS_base (ST "cp_OclOr")))]],
                          [lem_simp2]],
                         by (map (fn OclClass (n, _, _) => simp_only [thma (flattena [SS_base (ST "cp_"), const_ocliskindof, isub n, SS_base (ST "_"), name3, SS_base (ST "_"), name2])]) next_dataty)));
        val (aa, b) = a;
      in
        Lemma (lemma_name, lemma_spec, aa, b)
      end)
    x;

val pRINT_iskindof_lemma_cp : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_iskindof.print_iskindof_lemma_cp"), print_iskindof_lemma_cp);

fun print_iskindof_defined_name isub_name h_name = flattena [isub_name const_ocliskindof, SS_base (ST "_"), h_name, SS_base (ST "_defined")];

fun print_iskindof_defineda x =
  start_m lemma m_class_default
    (fn _ => fn (isub_name, (name, _)) => fn OclClass (h_name, _, _) =>
      let
        val var_X = SS_base (ST "X");
        val var_isdef = SS_base (ST "isdef");
        val f = (fn e => term_binop (Term_basic [SS_base (ST "\092<tau>")]) (SS_base (ST "\092<Turnstile>")) (term_app (SS_base (ST "\092<delta>")) [e]));
      in
        [Lemma_assumes
           (print_iskindof_defined_namea isub_name h_name, [(var_isdef, (false, f (Term_basic [var_X])))], f (term_postunary (term_annot_ocl (Term_basic [var_X]) h_name) (Term_basic [dot_iskindof name])), [],
             by [rule (ofa (thma (print_iskindof_defined_name isub_name h_name)) (thena (thma var_isdef) (thma (SS_base (ST "foundation20")))))])]
      end)
    x;

val pRINT_iskindof_defineda : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_iskindof.print_iskindof_defined'"), print_iskindof_defineda);

fun print_examp_def_st_defs x = (fn _ => start_map lemmas [Lemmas_simp_thms (SS_base (ST ""), [SS_base (ST "state.defs"), SS_base (ST "const_ss")])]) x;

val pRINT_examp_def_st_defs : ('a -> 'b -> all_meta list * 'b) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_examp.print_examp_def_st_defs"), print_examp_def_st_defs);

fun print_astype_up_d_cast0_name name_any name_pers = flattena [SS_base (ST "up"), isub name_any, SS_base (ST "_down"), isub name_pers, SS_base (ST "_cast0")];

fun print_astype_up_d_cast0 x =
  (start_map lemma o
    map_class_nupl2_inh
      (fn name_pers => fn name_any =>
        let
          val var_X = SS_base (ST "X");
          val var_isdef = SS_base (ST "isdef");
          val f = term_binop (Term_basic [SS_base (ST "\092<tau>")]) (SS_base (ST "\092<Turnstile>"));
        in
          Lemma_assumes
            (print_astype_up_d_cast0_name name_any name_pers, [(var_isdef, (false, f (term_app (SS_base (ST "\092<delta>")) [Term_basic [var_X]])))],
              f (term_binop let
                              val asty = (fn xa => fn ty => term_warning_parenthesis (term_postunary xa (Term_basic [dot_astype ty])));
                            in
                              asty (asty (term_annot_ocl (Term_basic [var_X]) name_pers) name_any) name_pers
                            end
                  (SS_base (ST "\092<triangleq>")) (Term_basic [var_X])),
              [using [thma var_isdef]],
              by [auto_simp_add_split
                    (map thma (flattena [const_oclastype, isub name_any, SS_base (ST "_"), name_pers] ::
                                flattena [const_oclastype, isub name_pers, SS_base (ST "_"), name_any] ::
                                  SS_base (ST "foundation22") :: SS_base (ST "foundation16") :: map hol_definition [SS_base (ST "null_option"), SS_base (ST "bot_option")]))
                    (split_ty name_pers)])
        end))
    x;

val pRINT_astype_up_d_cast0 : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_astype.print_astype_up_d_cast0"), print_astype_up_d_cast0);

fun print_astype_lemma_cp_set2 x =
  (if activate_simp_optimization
    then (fn expr => fn base_attr =>
           flatten (m_classa base_attr (fn compare => fn (isub_name, (name, _)) => fn OclClass (name2, _, _) => (if equal_position compare EQ then [] else [((isub_name, name), ((fn s => flattenb s (isub name2)), name2))])) expr))
    else (fn _ => fn _ => []))
    x;

fun print_astype_lemmas_id2 x =
  (start_mapb id o
    (fn expr => fn base_attr => fn _ => fn _ =>
      let
        val name_set = print_astype_lemma_cp_set2 expr base_attr;
      in
        (case name_set of [] => [] | _ :: _ => map lemmas [lemmas_simp (SS_base (ST "")) (map (fn (a, b) => let
                                                                                                              val (isub_name_h, _) = a;
                                                                                                            in
                                                                                                              (fn (_, name) => thma (flattena [isub_name_h const_oclastype, SS_base (ST "_"), name]))
                                                                                                            end
                                                                                                              b)
                                                                                           name_set)])
      end))
    x;

val pRINT_astype_lemmas_id2 : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_astype.print_astype_lemmas_id2"), print_astype_lemmas_id2);

fun print_allinst_lemmas_id x =
  start_mapa (if activate_simp_optimization then (fn expr => let
                                                               val name_set = map_class (fn _ => fn name => fn _ => fn _ => fn _ => fn _ => name) expr;
                                                             in
                                                               (case name_set of [] => [] | _ :: _ => map lemmas [lemmas_simp (SS_base (ST "")) (map (thma o hol_definition) name_set)])
                                                             end)
               else (fn _ => []))
    x;

val pRINT_allinst_lemmas_id : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_allinst.print_allinst_lemmas_id"), print_allinst_lemmas_id);

val var_select_object_sequence_any : abr_string = SS_base (ST "select_object_any\092<^sub>S\092<^sub>e\092<^sub>q");

val var_select_object_sequence : abr_string = SS_base (ST "select_object\092<^sub>S\092<^sub>e\092<^sub>q");

val var_select_object_set_any : abr_string = SS_base (ST "select_object_any\092<^sub>S\092<^sub>e\092<^sub>t");

val var_select_object_set : abr_string = SS_base (ST "select_object\092<^sub>S\092<^sub>e\092<^sub>t");

fun lookup2 A_ B_ rbt = (fn (x1, x2) => binda (lookup A_ rbt x1) (fn rbta => lookup B_ rbta x2));

fun lookup2a m = (fn (k1, k2) => lookup2 (equal_list equal_integer) (equal_list equal_integer) m (to_list k1, to_list k2));

fun insert2 A_ B_ = (fn (x1, x2) => fn v => modify_def A_ empty x1 (updatea B_ x2 v));

fun insert2a x = (fn (k1, k2) => insert2 (equal_list equal_integer) (equal_list equal_integer) (to_list k1, to_list k2)) x;

val var_select : abr_string = SS_base (ST "select");

fun print_access_select_obj x =
  (start_mapd definition o
    (fn expr => fn design_analysis =>
      (if equal_generation_semantics_ocl design_analysis Gen_only_design then (fn _ => [])
        else (fn expra => flatten (flatten (map_class (fn isub_name => fn name => fn l_attr => fn l_inh => fn _ => fn _ =>
                                                        let
                                                          val l_inha = map_class_inh l_inh;
                                                        in
                                                          flatten (fst (mapM (mapM (fn a => (case a of (_, OclTy_base_void) => (fn aa => ([], aa)) | (_, OclTy_base_boolean) => (fn aa => ([], aa))
                                                                                              | (_, OclTy_base_integer) => (fn aa => ([], aa)) | (_, OclTy_base_unlimitednatural) => (fn aa => ([], aa))
                                                                                              | (_, OclTy_base_real) => (fn aa => ([], aa)) | (_, OclTy_base_string) => (fn aa => ([], aa))
                                                                                              | (_, OclTy_object (OclTyObj (OclTyCore_pre _, _))) => (fn aa => ([], aa))
                                                                                              | (attr, OclTy_object (OclTyObj (OclTyCore ty_obj, _))) =>
                                                                                                (fn rbt => (if is_none (lookup2a rbt (name, attr))
                                                                                                             then ([Definitiona
let
  val b = (fn s => Term_basic [s]);
in
  Term_rewrite (b (flattenb (isub_name var_select) (isup attr)), SS_base (ST "="),
                 b let
                     val obj_mult = tyObjN_role_multip (tyObj_to ty_obj);
                   in
                     (case (is_sequence obj_mult, single_multip obj_mult) of (true, true) => var_select_object_sequence_any | (true, false) => var_select_object_sequence | (false, true) => var_select_object_set_any
                       | (false, false) => var_select_object_set)
                   end)
end],
                                                                                                                    insert2a (name, attr) () rbt)
                                                                                                             else ([], rbt)))
                                                                                              | (_, OclTy_collection (_, _)) => (fn aa => ([], aa)) | (_, OclTy_pair (_, _)) => (fn aa => ([], aa))
                                                                                              | (_, OclTy_binding _) => (fn aa => ([], aa)) | (_, OclTy_arrow (_, _)) => (fn aa => ([], aa)) | (_, OclTy_class_syn _) => (fn aa => ([], aa))
                                                                                              | (_, OclTy_enum _) => (fn aa => ([], aa)) | (_, OclTy_raw _) => (fn aa => ([], aa)))))
                                                                         (l_attr :: l_inha) emptya))
                                                        end)
                                             expra))))
        expr))
    x;

val pRINT_access_select_obj : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_select_obj"), print_access_select_obj);

fun print_access_dot_consts x =
  (mapM (fn (f_update, xa) => fn env => (consts xa, d_ocl_accessor_update (fn _ => f_update (d_ocl_accessor env)) env)) o
    (flatten o flatten o
      map_class (fn _ => fn _ => fn l_attr => fn _ => fn _ => fn _ =>
                  map (fn (attr_n, attr_ty) =>
                        map (fn (var_at_when_hol, (var_at_when_ocl, f_update_ocl)) =>
                              let
                                val name = flattena [SS_base (ST "dot"),
                                                      (case attr_ty of OclTy_base_void => SS_base (ST "") | OclTy_base_boolean => SS_base (ST "") | OclTy_base_integer => SS_base (ST "") | OclTy_base_unlimitednatural => SS_base (ST "")
                                                        | OclTy_base_real => SS_base (ST "") | OclTy_base_string => SS_base (ST "") | OclTy_object (OclTyObj (OclTyCore_pre _, _)) => SS_base (ST "")
                                                        | OclTy_object (OclTyObj (OclTyCore ty_obj, _)) => flattena [SS_base (ST "_"), natural_to_digit10 (tyObjN_ass_switch (tyObj_from ty_obj)), SS_base (ST "_")]
                                                        | OclTy_collection (_, _) => SS_base (ST "") | OclTy_pair (_, _) => SS_base (ST "") | OclTy_binding _ => SS_base (ST "") | OclTy_arrow (_, _) => SS_base (ST "")
                                                        | OclTy_class_syn _ => SS_base (ST "") | OclTy_enum _ => SS_base (ST "") | OclTy_raw _ => SS_base (ST "")),
                                                      isup attr_n, var_at_when_hol];
                              in
                                (f_update_ocl (fn a => to_String_b_a_s_e name :: a),
                                  consts_raw0 name (ty_arrow (Typ_apply (Typ_base (SS_base (ST "val")), [Typ_base (SS_base (ST "\092<AA>")), Typ_base (SS_base (ST "'\092<alpha>"))])) (print_access_dot_consts_ty attr_ty))
                                    let
                                      val dot_name = mk_dot attr_n var_at_when_ocl;
                                      val mk_par = (fn s1 => fn s2 => flattena [s1, SS_base (ST " '/* "), s2, SS_base (ST " *'/")]);
                                    in
                                      (case attr_ty of OclTy_base_void => dot_name | OclTy_base_boolean => dot_name | OclTy_base_integer => dot_name | OclTy_base_unlimitednatural => dot_name | OclTy_base_real => dot_name
                                        | OclTy_base_string => dot_name | OclTy_object (OclTyObj (OclTyCore_pre _, _)) => dot_name
                                        | OclTy_object (OclTyObj (OclTyCore ty_obj, _)) =>
                                          (case apply_optim_ass_arity ty_obj (mk_par dot_name let
                                                                                                val ty_obja = tyObj_from ty_obj;
                                                                                              in
                                                                                                (case tyObjN_role_name ty_obja of NONE => natural_to_digit10 (tyObjN_ass_switch ty_obja) | SOME s => s)
                                                                                              end)
                                            of NONE => dot_name | SOME dot_namea => dot_namea)
                                        | OclTy_collection (_, _) => dot_name | OclTy_pair (_, _) => dot_name | OclTy_binding _ => dot_name | OclTy_arrow (_, _) => dot_name | OclTy_class_syn _ => dot_name | OclTy_enum _ => dot_name
                                        | OclTy_raw _ => dot_name)
                                    end
                                    NONE)
                              end)
                          [(var_at_when_hol_post, (var_at_when_ocl_post, update_D_ocl_accessor_post)), (var_at_when_hol_pre, (var_at_when_ocl_pre, update_D_ocl_accessor_pre))])
                    l_attr)))
    x;

val pRINT_access_dot_consts : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_dot_consts"), print_access_dot_consts);

fun print_istypeof_defined x =
  start_m lemma m_class_default
    (fn _ => fn (isub_name, (name, _)) => fn OclClass (h_name, _, _) =>
      let
        val var_X = SS_base (ST "X");
        val var_isdef = SS_base (ST "isdef");
        val f = (fn symb => fn e => term_binop (Term_basic [SS_base (ST "\092<tau>")]) (SS_base (ST "\092<Turnstile>")) (term_app symb [e]));
      in
        [Lemma_assumes
           (print_istypeof_defined_name isub_name h_name, [(var_isdef, (false, f (SS_base (ST "\092<upsilon>")) (Term_basic [var_X])))],
             f (SS_base (ST "\092<delta>")) (term_postunary (term_annot_ocl (Term_basic [var_X]) h_name) (Term_basic [dot_istypeof name])),
             [applya [insertb [simplified (thma var_isdef) (thma (SS_base (ST "foundation18'")))], simp_only [thma (hol_definition (SS_base (ST "OclValid")))], subst (thma (SS_base (ST "cp_defined")))]],
             by [auto_simp_add_split (symmetric (thma (SS_base (ST "cp_defined"))) :: map thma [hol_definition (SS_base (ST "bot_option")), flattena [isub_name const_oclistypeof, SS_base (ST "_"), h_name]])
                   (SS_base (ST "option.split") :: split_ty h_name)])]
      end)
    x;

val pRINT_istypeof_defined : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_istypeof.print_istypeof_defined"), print_istypeof_defined);

fun print_iskindof_defined x =
  start_m_gen lemma m_class_default
    (fn _ => fn _ => fn next_dataty => fn _ => fn (isub_name, (name, _)) => fn OclClass (h_name, _, _) =>
      let
        val var_X = SS_base (ST "X");
        val var_isdef = SS_base (ST "isdef");
        val f = (fn symb => fn e => term_binop (Term_basic [SS_base (ST "\092<tau>")]) (SS_base (ST "\092<Turnstile>")) (term_app symb [e]));
      in
        [Lemma_assumes
           (print_iskindof_defined_name isub_name h_name, [(var_isdef, (false, f (SS_base (ST "\092<upsilon>")) (Term_basic [var_X])))],
             f (SS_base (ST "\092<delta>")) (term_postunary (term_annot_ocl (Term_basic [var_X]) h_name) (Term_basic [dot_iskindof name])), [],
             by [simp_only [thma (flattena [isub_name const_ocliskindof, SS_base (ST "_"), h_name])],
                  rule let
                         val mk_OF = (fn fa => ofa (thma (fa h_name)) (thma var_isdef));
                       in
                         fold (fn OclClass (n, _, _) => fn prf => oF_l (thma (SS_base (ST "defined_or_I"))) [prf, mk_OF (print_iskindof_defined_name (fn namea => flattenb namea (isub n)))]) next_dataty
                           (mk_OF (print_istypeof_defined_name isub_name))
                       end])]
      end)
    x;

val pRINT_iskindof_defined : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_iskindof.print_iskindof_defined"), print_iskindof_defined);

fun rename_tac x = Method_rename_tac x;

fun case_tac x = Method_case_tac x;

fun print_astype_up_d_cast x =
  (start_map lemma o
    map_class_nupl2_inh
      (fn name_pers => fn name_any =>
        let
          val var_X = SS_base (ST "X");
          val var_tau = SS_base (ST "\092<tau>");
        in
          Lemma_assumes
            (flattena [SS_base (ST "up"), isub name_any, SS_base (ST "_down"), isub name_pers, SS_base (ST "_cast")], [],
              term_binop let
                           val asty = (fn xa => fn ty => term_warning_parenthesis (term_postunary xa (Term_basic [dot_astype ty])));
                         in
                           asty (asty (term_annot_ocl (Term_basic [var_X]) name_pers) name_any) name_pers
                         end
                (SS_base (ST "=")) (Term_basic [var_X]),
              map applya [[rule (thma (SS_base (ST "ext"))), rename_tac [var_tau]], [rule (thena (thma (SS_base (ST "foundation22"))) (thma (SS_base (ST "iffD1"))))],
                           [case_tac (term_binop (Term_basic [var_tau]) (SS_base (ST "\092<Turnstile>")) (term_app (SS_base (ST "\092<delta>")) [Term_basic [var_X]])), simp_add [print_astype_up_d_cast0_name name_any name_pers]],
                           [simp_add [SS_base (ST "defined_split")], elim (thma (SS_base (ST "disjE")))], [plus [erule (thma (SS_base (ST "StrongEq_L_subst2_rev"))), simp, simp]]],
              done)
        end))
    x;

val pRINT_astype_up_d_cast : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_astype.print_astype_up_d_cast"), print_astype_up_d_cast);

fun print_astype_lemmas_id x =
  start_mapa (fn expr => let
                           val name_set = print_astype_lemma_cp_set expr;
                         in
                           (case name_set of [] => [] | _ :: _ => map lemmas [lemmas_simp (SS_base (ST "")) (map (fn (a, b) => let
           val (isub_name, _) = a;
         in
           (fn name => thma (flattena [isub_name const_oclastype, SS_base (ST "_"), name]))
         end
           b)
                                                                                                              name_set)])
                         end)
    x;

val pRINT_astype_lemmas_id : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_astype.print_astype_lemmas_id"), print_astype_lemmas_id);

fun print_astype_lemmas_cp x =
  start_mapa (if activate_simp_optimization
               then map lemmas o (fn expr => [lemmas_simp (SS_base (ST ""))
                                                (get_hierarchy_map (fn name1 => fn name2 => fn name3 => thma (flattena [SS_base (ST "cp_"), const_oclastype, isub name1, SS_base (ST "_"), name3, SS_base (ST "_"), name2]))
                                                  (fn xa => (xa, (xa, xa))) expr)])
               else (fn _ => []))
    x;

val pRINT_astype_lemmas_cp : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_astype.print_astype_lemmas_cp"), print_astype_lemmas_cp);

fun print_astype_up_d_cast_name name_any name_pers = flattena [SS_base (ST "up"), isub name_any, SS_base (ST "_down"), isub name_pers, SS_base (ST "_cast")];

fun print_astype_d_up_cast x =
  (start_map lemma o
    map_class_nupl2_inh
      (fn name_pers => fn name_any =>
        let
          val var_X = SS_base (ST "X");
          val var_Y = SS_base (ST "Y");
          val a = (fn f => fn xa => term_app f [xa]);
          val b = (fn s => Term_basic [s]);
          val var_tau = SS_base (ST "\092<tau>");
          val f_tau = (fn s => term_warning_parenthesis (term_binop (b var_tau) (SS_base (ST "\092<Turnstile>")) (term_warning_parenthesis s)));
          val var_def_X = SS_base (ST "def_X");
          val asty = (fn xa => fn ty => term_warning_parenthesis (term_postunary xa (Term_basic [dot_astype ty])));
          val not_val = a (SS_base (ST "not")) (a (SS_base (ST "\092<upsilon>")) (b var_X));
        in
          Lemma_assumes
            (flattena [SS_base (ST "down"), isub name_pers, SS_base (ST "_up"), isub name_any, SS_base (ST "_cast")],
              [(var_def_X, (false, term_binop (Term_basic [var_X]) (SS_base (ST "=")) (asty (term_annot_ocl (Term_basic [var_Y]) name_pers) name_any)))],
              f_tau (term_binop not_val (SS_base (ST "or")) (term_binop (asty (asty (Term_basic [var_X]) name_pers) name_any) (SS_base (ST "\092<doteq>")) (b var_X))),
              map applya [[case_tac (f_tau not_val), rule (thma (SS_base (ST "foundation25"))), simp]],
              by [rule (thma (SS_base (ST "foundation25'"))), simp_add [var_def_X, print_astype_up_d_cast_name name_any name_pers, SS_base (ST "StrictRefEq\092<^sub>O\092<^sub>b\092<^sub>j\092<^sub>e\092<^sub>c\092<^sub>t_sym")]])
        end))
    x;

val pRINT_astype_d_up_cast : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_astype.print_astype_d_up_cast"), print_astype_d_up_cast);

fun term_exists x f = Term_bind (SS_base (ST "\092<exists>"), Term_basic [x], f x);

fun term_pat b = Term_basic [flattenb (SS_base (ST "?")) b];

fun letb x = (fn a => Command_let (x, a));

fun fix l = Command_fix_let (l, [], NONE, []);

fun print_allinst_istypeof x =
  (start_mapb lemma o
    (fn expr => fn base_attr => fn _ => fn _ =>
      map_class_gen
        (fn isub_name => fn name => fn l_attr => fn _ => fn _ => fn next_dataty =>
          let
            val l_attra = base_attr l_attr;
            val b = (fn s => Term_basic [s]);
            val d = hol_definition;
            val s = subst_l [SS_base (ST "1"), SS_base (ST "2"), SS_base (ST "3")];
            val var_tau = SS_base (ST "\092<tau>");
          in
            (case next_dataty of [] => print_allinst_istypeof_single isub_name name isub_name name const_oclistypeof dot_istypeof (fn _ => []) id
              | OclClass (name_next, _, _) :: _ =>
                flatten [gen_pre_post (fn sa => flattena [name, SS_base (ST "_"), sa, SS_base (ST "_"), isub_name const_oclistypeof, SS_base (ST "1")])
                           (fn f_expr => fn _ => fn _ =>
                             term_exists (SS_base (ST "\092<tau>")) (fn var_taua => term_binop (b var_taua) (SS_base (ST "\092<Turnstile>")) (term_app var_OclForall_set [f_expr [b name], b (isub_name const_oclistypeof)])))
                           (fn lem_tit => fn lem_spec => fn var_pre_post => fn _ => fn _ =>
                             Lemma_assumes
                               (lem_tit, [(SS_base (ST ""),
                                            (true, term_And (SS_base (ST "x")) (fn var_x => Term_rewrite (term_app var_pre_post [term_parenthesis (term_binop (b var_x) (SS_base (ST ",")) (b var_x))], SS_base (ST "="), b var_x))))],
                                 lem_spec, map applya [let
                                                         val var_tau0 = flattenb var_tau (isub (SS_base (ST "0")));
                                                       in
                                                         [rule (wherea (thma (SS_base (ST "exI"))) [(SS_base (ST "x"), b var_tau0)]), simp_add_del (map d [var_tau0, SS_base (ST "OclValid")]) [d (SS_base (ST "OclAllInstances_generic"))]]
                                                       end,
                                                        [simp_only (flatten [map thma [d var_OclForall_set, SS_base (ST "refl"), SS_base (ST "if_True")],
                                                                              [simplified (thma (SS_base (ST "OclAllInstances_generic_defined"))) (thma (d (SS_base (ST "OclValid"))))]])],
                                                        [simp_only [thma (d (SS_base (ST "OclAllInstances_generic")))]], [s (thma var_Abs_Set_inverse), simp_add [d (SS_base (ST "bot_option"))]]],
                                 by [simp]))
                           [simp],
                          gen_pre_post (fn sa => flattena [name, SS_base (ST "_"), sa, SS_base (ST "_"), isub_name const_oclistypeof, SS_base (ST "2")])
                            (fn f_expr => fn _ => fn _ =>
                              term_exists (SS_base (ST "\092<tau>"))
                                (fn var_taua => term_binop (b var_taua) (SS_base (ST "\092<Turnstile>")) (term_app (SS_base (ST "not")) [term_app var_OclForall_set [f_expr [b name], b (isub_name const_oclistypeof)]])))
                            (fn lem_tit => fn lem_spec => fn var_pre_post => fn _ => fn _ =>
                              Lemma_assumes
                                (lem_tit, [(SS_base (ST ""),
                                             (true, term_And (SS_base (ST "x")) (fn var_x => Term_rewrite (term_app var_pre_post [term_parenthesis (term_binop (b var_x) (SS_base (ST ",")) (b var_x))], SS_base (ST "="), b var_x))))],
                                  lem_spec, let
                                              val var_oid = SS_base (ST "oid");
                                              val var_a = SS_base (ST "a");
                                              val var_t0 = SS_base (ST "t0");
                                              val s_empty = SS_base (ST "Map.empty");
                                            in
                                              [fix [var_oid, var_a],
                                                letb (term_pat var_t0)
                                                  (term_app (SS_base (ST "state.make"))
                                                    [term_app s_empty
                                                       [term_binop (b var_oid) (SS_base (ST "\092<mapsto>"))
                                                          (term_app (isub_name datatype_in)
                                                            [term_app (isub_name datatype_constr_name)
                                                               (term_app (flattenb datatype_ext_constr_name (mk_constr_name name name_next)) [b var_a] :: map (fn _ => b (SS_base (ST "None"))) l_attra)])],
                                                      b s_empty]),
                                                applya [rule (wherea (thma (SS_base (ST "exI"))) [(SS_base (ST "x"), term_parenthesis (term_binop (term_pat var_t0) (SS_base (ST ",")) (term_pat var_t0)))]),
                                                         simp_add_del [d (SS_base (ST "OclValid"))] [d (SS_base (ST "OclAllInstances_generic"))]],
                                                applya [simp_only (flatten [map thma [d var_OclForall_set, SS_base (ST "refl"), SS_base (ST "if_True")],
                                                                             [simplified (thma (SS_base (ST "OclAllInstances_generic_defined"))) (thma (d (SS_base (ST "OclValid"))))]])],
                                                applya [simp_only (map (fn xa => thma (d xa)) [SS_base (ST "OclAllInstances_generic"), flattena [isub_name const_oclastype, SS_base (ST "_\092<AA>")]])],
                                                applya [s (thma var_Abs_Set_inverse), simp_add [d (SS_base (ST "bot_option"))]]]
                                            end,
                                  by [simp_add [d (SS_base (ST "state.make")), d (SS_base (ST "OclNot"))]]))
                            [simp]])
          end)
        expr))
    x;

val pRINT_allinst_istypeof : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_allinst.print_allinst_istypeof"), print_allinst_istypeof);

val var_deref_oid : abr_string = SS_base (ST "deref_oid");

fun print_access_deref_oid_name isub_name = isub_name var_deref_oid;

fun print_access_deref_oid x =
  (start_map definition o
    map_class (fn isub_name => fn _ => fn _ => fn _ => fn _ => fn _ =>
                let
                  val var_fs = SS_base (ST "fst_snd");
                  val var_f = SS_base (ST "f");
                  val var_oid = SS_base (ST "oid");
                  val var_obj = SS_base (ST "obj");
                in
                  Definitiona (Term_rewrite
                                (Term_basic [print_access_deref_oid_name isub_name, var_fs, var_f, var_oid], SS_base (ST "="),
                                  term_lam (SS_base (ST "\092<tau>"))
                                    (fn var_tau =>
                                      term_case (term_app (SS_base (ST "heap")) [Term_basic [var_fs, var_tau], Term_basic [var_oid]])
                                        [(term_some (Term_basic [isub_name datatype_in, var_obj]), Term_basic [var_f, var_obj, var_tau]), (Term_basic [wildcard], Term_basic [SS_base (ST "invalid"), var_tau])])))
                end))
    x;

val pRINT_access_deref_oid : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_deref_oid"), print_access_deref_oid);

fun class_arity x =
  (keys o (fn l => fold (fn xa => insert equal_natural xa ()) l emptya) o flatten o flatten o
    map_class (fn _ => fn _ => fn l_attr => fn _ => fn _ => fn _ =>
                map (fn a => (case a of (_, OclTy_base_void) => [] | (_, OclTy_base_boolean) => [] | (_, OclTy_base_integer) => [] | (_, OclTy_base_unlimitednatural) => [] | (_, OclTy_base_real) => [] | (_, OclTy_base_string) => []
                               | (_, OclTy_object (OclTyObj (OclTyCore_pre _, _))) => [] | (_, OclTy_object (OclTyObj (OclTyCore ty_obj, _))) => [tyObj_ass_arity ty_obj] | (_, OclTy_collection (_, _)) => []
                               | (_, OclTy_pair (_, _)) => [] | (_, OclTy_binding _) => [] | (_, OclTy_arrow (_, _)) => [] | (_, OclTy_class_syn _) => [] | (_, OclTy_enum _) => [] | (_, OclTy_raw _) => []))
                  l_attr))
    x;

fun print_access_choose_switch lets mk_var expr print_access_choose_n sexpr_list sexpr_function sexpr_pair =
  flatten (map (fn n => let
                          val l = uptob Code_Numeral.zero_natural (Code_Numeral.minus_natural n Code_Numeral.one_natural);
                        in
                          map let
                                val la = sexpr_list (map mk_var l);
                              in
                                (fn (i, j) => lets (print_access_choose_n n i j) (sexpr_function [(la, sexpr_pair (mk_var i) (mk_var j))]))
                              end
                            ((flatten o flatten) (map (fn i => map (fn j => (if equal_naturala i j then [] else [(i, j)])) l) l))
                        end)
            (class_arity expr));

fun print_access_choose_mlname n i j = flattena [var_switch, natural_to_digit10 n, SS_base (ST "_"), natural_to_digit10 i, natural_to_digit10 j];

fun function x = SML_function x;

fun print_access_choose_ml x = (start_mapd ml o (fn expr => fn _ => let
                                                                      val b = (fn s => basic [s]);
                                                                      val lets = (fn var => fn exp => SMLa (rewrite_val (basic [var]) (SS_base (ST "=")) exp));
                                                                      val mk_var = (fn i => b (flattena [SS_base (ST "x"), natural_to_digit10 i]));
                                                                    in
                                                                      flatten [print_access_choose_switch lets mk_var expr print_access_choose_mlname lista function pair]
                                                                    end))
                                 x;

val pRINT_access_choose_ml : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_choose_ml"), print_access_choose_ml);

fun const_mixfix dot_ocl name = flattena [dot_ocl, SS_base (ST "'("), name, SS_base (ST "')")];

fun constsa s l e = consts_raw0 s (ty_arrow (Typ_base (SS_base (ST "'\092<alpha>"))) l) e NONE;

fun print_istypeof_consts x = (start_map consts o map_class (fn isub_name => fn name => fn _ => fn _ => fn _ => fn _ => constsa (isub_name const_oclistypeof) (Typ_base ty_boolean) (const_mixfix dot_oclistypeof name))) x;

val pRINT_istypeof_consts : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_istypeof.print_istypeof_consts"), print_istypeof_consts);

fun print_iskindof_consts x = (start_map consts o map_class (fn isub_name => fn name => fn _ => fn _ => fn _ => fn _ => constsa (isub_name const_ocliskindof) (Typ_base ty_boolean) (const_mixfix dot_ocliskindof name))) x;

val pRINT_iskindof_consts : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_iskindof.print_iskindof_consts"), print_iskindof_consts);

fun print_astype_lemma_cp expr =
  (start_map lemma o
    get_hierarchy_map
      let
        val check_opt = let
                          val set = print_astype_lemma_cp_set expr;
                        in
                          (fn n1 => fn n2 => list_ex (fn (a, b) => let
                                                                     val (_, name1) = a;
                                                                   in
                                                                     (fn name2 => equal_abr_stringa name1 n1 andalso equal_abr_stringa name2 n2)
                                                                   end
                                                                     b)
                                               set)
                        end;
      in
        (fn name1 => fn name2 => fn name3 =>
          Lemma (flattena [SS_base (ST "cp_"), const_oclastype, isub name1, SS_base (ST "_"), name3, SS_base (ST "_"), name2],
                  let
                    val var_p = SS_base (ST "p");
                  in
                    map (fn x => term_app (SS_base (ST "cp")) [x])
                      [Term_basic [var_p],
                        term_lam (SS_base (ST "x")) (fn var_x => term_warning_parenthesis (term_postunary (term_annot_ocl (term_app var_p [term_annot_ocl (Term_basic [var_x]) name3]) name2) (Term_basic [dot_astype name1])))]
                  end,
                  [], by [rule (thma (SS_base (ST "cpI1"))), (if check_opt name1 name2 then simp else simp_add [flattena [const_oclastype, isub name1, SS_base (ST "_"), name2]])]))
      end
      (fn x => (x, (x, x))))
    expr;

val pRINT_astype_lemma_cp : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_astype.print_astype_lemma_cp"), print_astype_lemma_cp);

fun print_access_oid_uniq x =
  print_access_oid_uniq_gen definition (fn env => fn oid_start => d_ocl_oid_start_update (fn _ => oid_start) env)
    (fn obj_name_from_nat => fn _ => fn isub_name => fn attr => fn cpt_obj => Definitiona (Term_rewrite (Term_basic [print_access_oid_uniq_name obj_name_from_nat isub_name attr], SS_base (ST "="), term_oid (SS_base (ST "")) cpt_obj)))
    x;

val pRINT_access_oid_uniq : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_oid_uniq"), print_access_oid_uniq);

fun print_access_def_mono_name isub_name dot_at_when attr_ty isup_attr = flattena [SS_base (ST "defined_mono_"), print_access_dot_name isub_name dot_at_when attr_ty isup_attr];

fun print_access_def_mono x =
  (start_mapd lemma o
    (fn expr => fn _ =>
      map_class_arg_only_vara
        (fn isub_name => fn name => fn (_, dot_at_when) => fn attr_ty => fn isup_attr => fn dot_attr =>
          let
            val var_X = SS_base (ST "X");
            val var_tau = SS_base (ST "\092<tau>");
            val a = (fn f => fn xa => term_app f [xa]);
            val b = (fn s => Term_basic [s]);
            val f0 = term_binop (Term_basic [var_tau]) (SS_base (ST "\092<Turnstile>"));
            val f = (fn e => f0 (term_app (SS_base (ST "\092<delta>")) [e]));
          in
            [Lemma (print_access_def_mono_name isub_name dot_at_when attr_ty isup_attr, map f [dot_attr (term_annot_ocl (b var_X) name), b var_X],
                     let
                       val f_tac = (fn s => [case_tac (f0 (term_warning_parenthesis (Term_rewrite (b var_X, SS_base (ST "\092<triangleq>"), b s)))),
                                              insertb [wherea (thma (SS_base (ST "StrongEq_L_subst2")))
                                                         [(SS_base (ST "P"), term_lam (SS_base (ST "x")) (fn var_Xa => a (SS_base (ST "\092<delta>")) (dot_attr (b var_Xa)))), (SS_base (ST "\092<tau>"), b (SS_base (ST "\092<tau>"))),
                                                           (SS_base (ST "x"), b var_X), (SS_base (ST "y"), b s)]],
                                              simp_add [SS_base (ST "foundation16'"), print_access_lemma_strict_name isub_name dot_at_when attr_ty isup_attr s]]);
                     in
                       [f_tac (SS_base (ST "invalid")), f_tac (SS_base (ST "null"))]
                     end,
                     by [simp_add [SS_base (ST "defined_split")]])]
          end)
        expr))
    x;

val pRINT_access_def_mono : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_def_mono"), print_access_def_mono);

fun print_istypeof_class x =
  start_m_gen overloading m_class_default
    (fn l_inh => fn _ => fn _ => fn compare => fn (isub_name, (name, _)) => fn OclClass (h_name, hl_attr, h_last) =>
      [overloadinga (isub_name const_oclistypeof) (ty_arrowb (ty_paren (Typ_base (wrap_oclty h_name)))) (flattena [isub_name const_oclistypeof, SS_base (ST "_"), h_name])
         let
           val var_x = SS_base (ST "x");
         in
           Term_rewrite (term_postunary (term_annot_ocl (Term_basic [var_x]) h_name) (Term_basic [dot_istypeof name]), SS_base (ST "\092<equiv>"),
                          term_lam (SS_base (ST "\092<tau>"))
                            (fn var_tau =>
                              let
                                val app_tau = (fn v => term_app v [Term_basic [var_tau]]);
                              in
                                term_case (app_tau var_x)
                                  ((Term_basic [SS_base (ST "\092<bottom>")], app_tau (SS_base (ST "invalid"))) ::
                                    (term_some (Term_basic [SS_base (ST "\092<bottom>")]), app_tau (SS_base (ST "true"))) ::
                                      let
                                        val l_false = [(Term_basic [wildcard], app_tau (SS_base (ST "false")))];
                                        val pattern_complex_gen =
                                          (fn f1 => fn f2 =>
                                            let
                                              val isub_h = (fn s => flattenb s (isub h_name));
                                            in
                                              (term_some (term_some (term_app (isub_h datatype_constr_name)
                                                                      (term_app (f2 (fn s => isub_name (flattenb s (SS_base (ST "_")))) (isub_h datatype_ext_constr_name)) (Term_basic [wildcard] :: f1) ::
                                                                        map (fn _ => Term_basic [wildcard]) hl_attr))),
                                                app_tau (SS_base (ST "true"))) ::
                                                (if null h_last then [] else l_false)
                                            end);
                                      in
                                        (case compare of EQ => pattern_complex_gen (flatten (map (map (fn _ => Term_basic [wildcard]) o (fn OclClass (_, l, _) => l)) (of_linh l_inh))) (fn _ => id) | LT => l_false
                                          | GT => pattern_complex_gen [] id | UN => l_false)
                                      end)
                              end))
         end])
    x;

val pRINT_istypeof_class : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_istypeof.print_istypeof_class"), print_istypeof_class);

fun print_iskindof_class x =
  start_m_gen overloading m_class_default
    (fn _ => fn _ => fn next_dataty => fn _ => fn (isub_name, (name, _)) => fn OclClass (h_name, _, _) =>
      [overloadinga (isub_name const_ocliskindof) (ty_arrowb (ty_paren (Typ_base (wrap_oclty h_name)))) (print_iskindof_class_name isub_name h_name)
         let
           val var_x = SS_base (ST "x");
         in
           Term_rewrite (term_postunary (term_annot_ocl (Term_basic [var_x]) h_name) (Term_basic [dot_iskindof name]), SS_base (ST "\092<equiv>"),
                          let
                            val isof = (fn f => fn namea => term_warning_parenthesis (term_postunary (Term_basic [var_x]) (Term_basic [f namea])));
                          in
                            term_binopa (SS_base (ST "or")) (isof dot_istypeof name :: map (fn OclClass (name_past, _, _) => isof dot_iskindof name_past) next_dataty)
                          end)
         end])
    x;

val pRINT_iskindof_class : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_iskindof.print_iskindof_class"), print_iskindof_class);

fun print_infra_enum_syn uu env =
  (flatten [(flatten o map (fn a => (case a of META_enum (OclEnum (name_ty, _)) => [type_synonym (type_synonyma name_ty (Typ_apply (Typ_base (pref_generic_enum name_ty), [Typ_base (SS_base (ST "\092<AA>"))])))]
                                      | META_class_raw (_, _) => [] | META_association _ => [] | META_ass_class (_, _) => [] | META_ctxt (_, _) => [] | META_haskell _ => [] | META_class_synonym _ => [] | META_instance _ => []
                                      | META_def_base_l _ => [] | META_def_state (_, _) => [] | META_def_transition (_, _) => [] | META_class_tree _ => [] | META_flush_all _ => [] | META_generic _ => [])))
              (d_input_meta env),
             (flatten o map (fn a => (case a of META_enum _ => [] | META_class_raw (_, _) => [] | META_association _ => [] | META_ass_class (_, _) => [] | META_ctxt (_, _) => [] | META_haskell _ => []
                                       | META_class_synonym (OclClassSynonym (name_ty, ty)) => [type_synonym (type_synonyma name_ty (Typ_base (str_of_ty ty)))] | META_instance _ => [] | META_def_base_l _ => []
                                       | META_def_state (_, _) => [] | META_def_transition (_, _) => [] | META_class_tree _ => [] | META_flush_all _ => [] | META_generic _ => [])))
               (fst (find_class_ass env))],
    env);

val pRINT_infra_enum_syn : ('a -> 'b compiler_env_config_ext -> all_meta list * 'b compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_infra.print_infra_enum_syn"), print_infra_enum_syn);

fun print_astype_defined x =
  start_m lemma m_class_default
    (fn compare => fn (isub_name, (name, _)) => fn OclClass (h_name, _, _) =>
      let
        val var_X = SS_base (ST "X");
        val var_isdef = SS_base (ST "isdef");
        val f = (fn e => term_binop (Term_basic [SS_base (ST "\092<tau>")]) (SS_base (ST "\092<Turnstile>")) (term_app (SS_base (ST "\092<delta>")) [e]));
      in
        (case compare of EQ => []
          | LT => [Lemma_assumes
                     (flattena [isub_name const_oclastype, SS_base (ST "_"), h_name, SS_base (ST "_defined")], [(var_isdef, (false, f (Term_basic [var_X])))],
                       f (term_postunary (term_annot_ocl (Term_basic [var_X]) h_name) (Term_basic [dot_astype name])), [using [thma var_isdef]],
                       by [auto_simp_add (flattena [isub_name const_oclastype, SS_base (ST "_"), h_name] :: SS_base (ST "foundation16") :: map hol_definition [SS_base (ST "null_option"), SS_base (ST "bot_option")])])]
          | GT => [] | UN => [])
      end)
    x;

val pRINT_astype_defined : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_astype.print_astype_defined"), print_astype_defined);

fun print_allinst_def_id x = (start_map definition o map_class (fn _ => fn name => fn _ => fn _ => fn _ => fn _ => let
                                                                                                                     val const_astype = flattena [const_oclastype, isub name, SS_base (ST "_\092<AA>")];
                                                                                                                   in
                                                                                                                     Definitiona (Term_rewrite (Term_basic [name], SS_base (ST "="), Term_basic [const_astype]))
                                                                                                                   end))
                               x;

val pRINT_allinst_def_id : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_allinst.print_allinst_def_id"), print_allinst_def_id);

fun print_allinst_astype_name isub_name = flattena [isub_name const_oclastype, SS_base (ST "_\092<AA>"), SS_base (ST "_some")];

fun map_class_one f_l f expr =
  let
    val a :: _ = f_l (fst (fold_class (fn isub_name => fn name => fn l_attr => fn l_inh => fn l_inh_sib => fn next_dataty => fn _ => ((isub_name, (name, (l_attr, (l_inh, (l_inh_sib, next_dataty))))), ())) () expr));
    val (isub_name, aa) = a;
    val (name, ab) = aa;
    val (l_attr, ac) = ab;
    val (l_inh, ad) = ac;
    val (ae, b) = ad;
  in
    f isub_name name l_attr l_inh ae b
  end;

fun map_class_top x = map_class_one rev x;

fun print_allinst_astype x =
  (start_map lemma o
    map_class_top
      (fn isub_name => fn _ => fn _ => fn _ => fn _ => fn _ =>
        let
          val b = (fn s => Term_basic [s]);
          val var_x = SS_base (ST "x");
          val d = hol_definition;
        in
          [Lemma (print_allinst_astype_name isub_name, [Term_rewrite (term_app (flattena [isub_name const_oclastype, SS_base (ST "_\092<AA>")]) [b var_x], SS_base (ST "\092<noteq>"), b (SS_base (ST "None")))], [],
                   by [simp_add [d (flattena [isub_name const_oclastype, SS_base (ST "_\092<AA>")])]])]
        end))
    x;

val pRINT_allinst_astype : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_allinst.print_allinst_astype"), print_allinst_astype);

val var_select_object_sequence_any_exec : abr_string = SS_base (ST "select_object_any_exec\092<^sub>S\092<^sub>e\092<^sub>q");

fun print_access_select_obj_name isub_name attr = flattenb (isub_name var_select) attr;

val var_select_object_set_any_exec : abr_string = SS_base (ST "select_object_any_exec\092<^sub>S\092<^sub>e\092<^sub>t");

fun print_access_is_repr_name isub_name dot_at_when attr_ty isup_attr = flattena [SS_base (ST "is_repr_"), print_access_dot_name isub_name dot_at_when attr_ty isup_attr];

fun print_access_select_name isup_attr isub_name = isup_attr (isub_name var_select);

fun map_class_arg_only_var_genb f_expr f = map_class_arg_only (map_class_arg_only_var0 f_expr f (fn l => [l]));

fun map_class_arg_only_varb x = map_class_arg_only_var_genb (fn s => fn e => term_postunary s (Term_basic e)) x;

fun meth_gen_simp_add_split l1 l2 = Method_simp_add_del_split (map Thms_single l1, [], map Thms_single l2);

fun simp_add_split l1 l2 = Method_one (meth_gen_simp_add_split l1 l2);

fun apply_end x = Command_apply_end x;

val clarify : semi_method = Method_clarify;

fun fix_let x = (fn a => fn b => fn c => Command_fix_let (x, a, b, c));

val rulea : semi_method = Method_rule NONE;

fun print_access_is_repr x =
  (start_mapd lemma o
    (fn expr => fn design_analysis =>
      let
        val is_design = equal_generation_semantics_ocl design_analysis Gen_only_design;
        val app_a = (fn l => applya (if is_design then [] else l));
        val app_d = (fn l => applya (if is_design then l else []));
      in
        (if is_design then map_class_arg_only_varb else map_class_arg_only_vara)
          (fn isub_name => fn name => fn (var_in_when_state, dot_at_when) => fn attr_ty => fn isup_attr => fn dot_attr =>
            (case attr_ty of OclTy_base_void => [] | OclTy_base_boolean => [] | OclTy_base_integer => [] | OclTy_base_unlimitednatural => [] | OclTy_base_real => [] | OclTy_base_string => []
              | OclTy_object (OclTyObj (OclTyCore_pre _, _)) => []
              | OclTy_object (OclTyObj (OclTyCore ty_obj, _)) =>
                let
                  val ty_mult = tyObjN_role_multip (tyObj_to ty_obj);
                in
                  (if single_multip ty_mult
                    then let
                           val var_X = SS_base (ST "X");
                           val var_tau = SS_base (ST "\092<tau>");
                           val var_def_dot = SS_base (ST "def_dot");
                           val a = (fn f => fn xa => term_app f [xa]);
                           val ap = (fn f => fn xa => term_applys (term_pat f) [xa]);
                           val apa = (fn f => term_applys (term_pat f));
                           val b = (fn s => Term_basic [s]);
                           val f0 = term_binop (Term_basic [var_tau]) (SS_base (ST "\092<Turnstile>"));
                           val f = (fn e => f0 (term_app (SS_base (ST "\092<delta>")) [e]));
                           val attr_tya = is_sequence ty_mult;
                           val name_from = tyObjN_ass_switch (tyObj_from ty_obj);
                           val name_to = tyObjN_role_ty (tyObj_to ty_obj);
                           val isub_name_to = (fn s => flattenb s (isub name_to));
                         in
                           [Lemma_assumes
                              (print_access_is_repr_name isub_name dot_at_when attr_ty isup_attr, [(var_def_dot, (false, f (dot_attr (term_annot_ocl (b var_X) name))))],
                                term_app (SS_base (ST "is_represented_in_state")) [b var_in_when_state, dot_attr (Term_basic [var_X]), b name_to, b var_tau],
                                let
                                  val v_a0 = SS_base (ST "a0");
                                  val v_a = SS_base (ST "a");
                                  val v_b = SS_base (ST "b");
                                  val v_r = SS_base (ST "r");
                                  val v_typeoid = SS_base (ST "typeoid");
                                  val v_opt = SS_base (ST "opt");
                                  val v_aa = SS_base (ST "aa");
                                  val v_e = SS_base (ST "e");
                                  val v_aaa = SS_base (ST "aaa");
                                  val vs_t = SS_base (ST "t");
                                  val vs_sel_any = SS_base (ST "sel_any");
                                  val l_thes = (fn l => fn l_when => SOME (append l [term_pat (SS_base (ST "thesis"))], l_when));
                                  val l_thes0 = (fn l => fn l_when => SOME (append l [term_pat (SS_base (ST "t"))], l_when));
                                  val hol_d = map hol_definition;
                                  val thol_d = map (thma o hol_definition);
                                  val app_f = (fn l => fn e => fix_let l [] e []);
                                  val app_d_f = (fn l => fn e => (if is_design then app_f l e else applya []));
                                  val app_fa = (fn l => fix_let l []);
                                  val f_ss = (fn v => a (SS_base (ST "Some")) (a (SS_base (ST "Some")) (b v)));
                                  val insert_that = insertb [thms (SS_base (ST "that"))];
                                in
                                  [applya [insertb [simplified (ofa (thma (print_access_def_mono_name isub_name dot_at_when attr_ty isup_attr)) (thma var_def_dot)) (thma (SS_base (ST "foundation16")))]],
                                    applya [case_tac (a var_X (b var_tau)), simp_add [hol_definition (SS_base (ST "bot_option"))]],
                                    app_fa [v_a0]
                                      (l_thes [term_binop (a var_X (b var_tau)) (SS_base (ST "=")) (a (SS_base (ST "Some")) (b v_a0))] [term_binop (a var_X (b var_tau)) (SS_base (ST "\092<noteq>")) (b (SS_base (ST "null")))])
                                      [apply_end [simp_all]],
                                    applya [insert_that, case_tac (b v_a0), simp_add (map hol_definition [SS_base (ST "null_option"), SS_base (ST "bot_option")]), clarify],
                                    app_f [v_a] (l_thes [term_binop (a var_X (b var_tau)) (SS_base (ST "=")) (f_ss v_a)] []),
                                    applya [case_tac (term_app (SS_base (ST "heap")) [a var_in_when_state (b var_tau), a (SS_base (ST "oid_of")) (b v_a)]), simp_add (hol_d [SS_base (ST "invalid"), SS_base (ST "bot_option")])],
                                    applya [insertb [thma (SS_base (ST "def_dot"))],
                                             simp_add_split
                                               (thma (print_access_dot_name isub_name dot_at_when attr_ty isup_attr) ::
                                                 thol_d [SS_base (ST "is_represented_in_state"), print_access_select_name isup_attr isub_name, print_access_deref_oid_name isub_name, var_in_when_state, SS_base (ST "defined"),
                                                          SS_base (ST "OclValid"), SS_base (ST "false"), SS_base (ST "true"), SS_base (ST "invalid"), SS_base (ST "bot_fun")])
                                               [thma (SS_base (ST "if_split_asm"))]],
                                    app_f [v_b] (l_thes [term_binop (a var_X (b var_tau)) (SS_base (ST "=")) (f_ss v_a),
                                                          Term_rewrite (term_app (SS_base (ST "heap")) [a var_in_when_state (b var_tau), a (SS_base (ST "oid_of")) (b v_a)], SS_base (ST "="), a (SS_base (ST "Some")) (b v_b))]
                                                  []),
                                    applya [insertb [simplified (thma (SS_base (ST "def_dot"))) (thma (SS_base (ST "foundation16")))],
                                             auto_simp_add
                                               (print_access_dot_name isub_name dot_at_when attr_ty isup_attr ::
                                                 hol_d [SS_base (ST "is_represented_in_state"), print_access_deref_oid_name isub_name, SS_base (ST "bot_option"), SS_base (ST "null_option")])],
                                    applya [case_tac (b v_b), simp_all_add (hol_d [SS_base (ST "invalid"), SS_base (ST "bot_option")])],
                                    app_a [simp_add (hol_d [print_access_deref_assocs_namea name_from isub_name isup_attr, var_deref_assocs])],
                                    app_a [case_tac (term_app (SS_base (ST "assocs")) [a var_in_when_state (b var_tau), b (print_access_oid_uniq_namea name_from isub_name (isup_attr (SS_base (ST ""))))]),
                                            simp_add (hol_d [SS_base (ST "invalid"), SS_base (ST "bot_option")]), simp_add (hol_d [print_access_select_obj_name isub_name (isup_attr (SS_base (ST "")))])],
                                    fix_let [v_r, v_typeoid]
                                      [(term_pat vs_t,
                                         Term_rewrite (f_ss v_r, SS_base (ST "\092<in>"),
                                                        term_binop (term_lam (SS_base (ST "x")) (fn xa => term_app (SS_base (ST "Some")) [term_app (print_astype_from_universe_name name_to) [b xa]])) (SS_base (ST "`"))
                                                          (a (SS_base (ST "ran")) (a (SS_base (ST "heap")) (a var_in_when_state (b var_tau)))))),
                                        (term_pat vs_sel_any,
                                          term_app (if attr_tya then var_select_object_sequence_any else var_select_object_set_any) [term_app (print_access_deref_oid_name isub_name_to) [b var_in_when_state, b var_reconst_basetype]])]
                                      (SOME ([Term_rewrite ((if is_design then term_app (print_access_select_name isup_attr isub_name) [term_pat vs_sel_any, b v_typeoid, b var_tau]
                                                              else term_applys (term_pat vs_sel_any) [b v_typeoid, b var_tau]),
                                                             SS_base (ST "="), f_ss v_r),
                                               term_pat vs_t],
                                              []))
                                      [],
                                    app_d [case_tac (b v_typeoid), simp_add (hol_d [print_access_select_name isup_attr isub_name])],
                                    app_d_f [v_opt]
                                      (l_thes0 [Term_rewrite (term_applys (term_case (b v_opt) [(b (SS_base (ST "None")), b (SS_base (ST "null"))), let
                                val var_x = SS_base (ST "x");
                              in
                                (a (SS_base (ST "Some")) (b var_x), ap vs_sel_any (b var_x))
                              end])
                                                                [b var_tau],
                                                               SS_base (ST "="), f_ss v_r)]
                                        []),
                                    app_d [case_tac (b v_opt), auto_simp_add (hol_d [SS_base (ST "null_fun"), SS_base (ST "null_option"), SS_base (ST "bot_option")])],
                                    app_fa [v_aa]
                                      (l_thes0 [Term_rewrite (apa vs_sel_any [b v_aa, b var_tau], SS_base (ST "="), f_ss v_r)]
                                        [term_binop (b var_tau) (SS_base (ST "\092<Turnstile>")) (a (SS_base (ST "\092<delta>")) (ap vs_sel_any (b v_aa)))])
                                      [apply_end [simp_add (SS_base (ST "foundation16") :: hol_d [SS_base (ST "bot_option"), SS_base (ST "null_option")])]],
                                    applya [insert_that, drule (simplified (thma (if attr_tya then var_select_object_sequence_any_exec else var_select_object_set_any_exec)) (thma (SS_base (ST "foundation22")))),
                                             erule (thma (SS_base (ST "exE")))],
                                    app_fa [v_e] (l_thes0 [] [Term_rewrite (apa vs_sel_any [b v_aa, b var_tau], SS_base (ST "="), f_ss v_r),
                                                               Term_rewrite (apa vs_sel_any [b v_aa, b var_tau], SS_base (ST "="),
                                                                              term_app (print_access_deref_oid_name isub_name_to) (map b [var_in_when_state, var_reconst_basetype, v_e, var_tau]))])
                                      [apply_end [plus [blast NONE]]],
                                    applya [insert_that, simp_add (hol_d [print_access_deref_oid_name isub_name_to])],
                                    applya [case_tac (term_app (SS_base (ST "heap")) [a var_in_when_state (b var_tau), b v_e]), simp_add (hol_d [SS_base (ST "invalid"), SS_base (ST "bot_option")]), simp],
                                    app_f [v_aaa]
                                      (l_thes0 [Term_rewrite (term_case (b v_aaa)
                                                                [let
                                                                   val var_obj = SS_base (ST "obj");
                                                                 in
                                                                   (a (isub_name_to datatype_in) (b var_obj), term_app var_reconst_basetype [b var_obj, b var_tau])
                                                                 end,
                                                                  (b wildcard, a (SS_base (ST "invalid")) (b var_tau))],
                                                               SS_base (ST "="), f_ss v_r),
                                                 Term_rewrite (term_app (SS_base (ST "heap")) [a var_in_when_state (b var_tau), b v_e], SS_base (ST "="), a (SS_base (ST "Some")) (b v_aaa))]
                                        []),
                                    applya [case_tac (b v_aaa), auto_simp_add (hol_d [SS_base (ST "invalid"), SS_base (ST "bot_option"), SS_base (ST "image"), SS_base (ST "ran")])],
                                    applya [rule (wherea (thma (SS_base (ST "exI"))) [(SS_base (ST "x"), a (isub_name_to datatype_in) (b v_r))]),
                                             simp_add_split (thol_d [print_astype_from_universe_name name_to, SS_base (ST "Let"), var_reconst_basetype]) [thma (SS_base (ST "if_split_asm"))]]]
                                end,
                                by [rulea])]
                         end
                    else [])
                end
              | OclTy_collection (_, _) => [] | OclTy_pair (_, _) => [] | OclTy_binding _ => [] | OclTy_arrow (_, _) => [] | OclTy_class_syn _ => [] | OclTy_enum _ => [] | OclTy_raw _ => []))
      end
        expr))
    x;

val pRINT_access_is_repr : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_is_repr"), print_access_is_repr);

fun print_astype_consts x = (start_map consts o map_class (fn isub_name => fn name => fn _ => fn _ => fn _ => fn _ => constsa (isub_name const_oclastype) (Typ_base (wrap_oclty name)) (const_mixfix dot_oclastype name))) x;

val pRINT_astype_consts : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_astype.print_astype_consts"), print_astype_consts);

fun lowercase x = mapb (fn n => (if n < (97 : IntInf.int) then n + (32 : IntInf.int) else n)) x;

fun print_access_select x =
  (start_mapb definition o
    (fn expr => fn base_attr => fn _ => fn base_attra =>
      let
        val b = (fn s => Term_basic [s]);
      in
        map_class_arg_only0
          (fn isub_name => fn _ => fn l_attr =>
            let
              val l_attra = base_attr l_attr;
              val var_f = SS_base (ST "f");
              val wildc = Term_basic [wildcard];
              val a = foldl (fn (l_wildl, (l_wildr, l_acc)) => fn (attr, _) =>
                              let
                                val isup_attr = (fn s => flattenb s (isup attr));
                              in
                                (wildc :: l_wildl,
                                  (tl l_wildr, Definitiona (Term_rewrite
                                                             (Term_basic [print_access_select_name isup_attr isub_name, var_f], SS_base (ST "="),
                                                               let
                                                                 val var_attr = b (flattenb (SS_base (ST "x_")) (isup attr));
                                                               in
                                                                 term_function
                                                                   (map (fn (lhs, a) => (term_app (isub_name datatype_constr_name) (wildc :: flatten [l_wildl, [lhs], l_wildr]), a))
                                                                     [(Term_basic [SS_base (ST "\092<bottom>")], Term_basic [SS_base (ST "null")]), (term_some var_attr, term_app var_f [var_attr])])
                                                               end)) ::
                                                 l_acc))
                              end)
                        ([], (map (fn _ => wildc) (tl l_attra), [])) l_attra;
              val (_, aa) = a;
              val (_, ab) = aa;
            in
              rev ab
            end)
          (fn isub_name => fn name => fn (l_attr, (l_inherited, l_cons)) =>
            let
              val l_inheriteda = flatten (map (fn OclClass (_, l, _) => l) (of_inh l_inherited));
              val (l_attra, l_inheritedb) = base_attra (l_attr, l_inheriteda);
              val var_f = SS_base (ST "f");
              val wildc = Term_basic [wildcard];
              val a = foldl (fn (l_wildl, (l_wildr, l_acc)) => fn (attr, _) =>
                              let
                                val isup_attr = (fn s => flattenb s (isup attr));
                              in
                                (wildc :: l_wildl,
                                  (tl l_wildr, Definitiona (Term_rewrite
                                                             (Term_basic [isup_attr (isub_name var_select), var_f], SS_base (ST "="),
                                                               let
                                                                 val var_attr = b (flattenb (SS_base (ST "x_")) (isup attr));
                                                               in
                                                                 term_function
                                                                   (flatten [map (fn (lhs, a) =>
                                                                                   (term_app (isub_name datatype_constr_name)
                                                                                      (term_app (isub_name datatype_ext_constr_name) (wildc :: flatten [l_wildl, [lhs], l_wildr]) :: map (fn _ => wildc) l_attra),
                                                                                     a))
                                                                               [(Term_basic [SS_base (ST "\092<bottom>")], Term_basic [SS_base (ST "null")]), (term_some var_attr, term_app var_f [var_attr])],
                                                                              map (fn OclClass (xa, _, _) =>
                                                                                    let
                                                                                      val var_x = lowercase xa;
                                                                                    in
                                                                                      (term_app (isub_name datatype_constr_name)
                                                                                         (term_app (flattenb datatype_ext_constr_name (mk_constr_name name xa)) [Term_basic [var_x]] :: map (fn _ => wildc) l_attra),
                                                                                        term_app (isup_attr (flattenb var_select (isub xa))) (map (fn xb => Term_basic [xb]) [var_f, var_x]))
                                                                                    end)
                                                                                (of_sub l_cons)])
                                                               end)) ::
                                                 l_acc))
                              end)
                        ([], (map (fn _ => wildc) (tl l_inheritedb), [])) l_inheritedb;
              val (_, aa) = a;
              val (_, ab) = aa;
            in
              rev ab
            end)
          expr
      end))
    x;

val pRINT_access_select : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_select"), print_access_select);

fun print_access_choose x =
  (start_mapd definition o
    (fn expr => fn _ =>
      let
        val a = (fn f => fn xa => term_app f [xa]);
        val b = (fn s => Term_basic [s]);
        val lets = (fn var => fn exp => Definitiona (Term_rewrite (Term_basic [var], SS_base (ST "="), exp)));
        val _ = (fn var => fn exp => Definitiona (Term_rewrite (Term_basic [var], SS_base (ST "="), b exp)));
        val _ = (fn var => fn exp => Definitiona (Term_rewrite (Term_basic [var], SS_base (ST "="), term_lam (SS_base (ST "l")) (fn var_l => term_binop (b var_l) (SS_base (ST "!")) (b exp)))));
        val _ = let
                  val l_flatten = SS_base (ST "L.flatten");
                in
                  [lets l_flatten let
                                    val fun_foldl = (fn f => fn base => term_lam (SS_base (ST "l")) (fn var_l => term_app (SS_base (ST "foldl")) [term_lam (SS_base (ST "acc")) f, base, a (SS_base (ST "rev")) (b var_l)]));
                                  in
                                    fun_foldl (fn var_acc => fun_foldl (fn var_acca => term_lam (SS_base (ST "l")) (fn var_l => term_app (SS_base (ST "Cons")) (map b [var_l, var_acca]))) (b var_acc)) (b (SS_base (ST "Nil")))
                                  end,
                    lets var_map_of_list
                      (term_app (SS_base (ST "foldl"))
                        [term_lam (SS_base (ST "map"))
                           (fn var_map =>
                             let
                               val var_x = SS_base (ST "x");
                               val var_l0 = SS_base (ST "l0");
                               val var_l1 = SS_base (ST "l1");
                               val f_map = a var_map;
                             in
                               term_lambdas0 (term_pair (b var_x) (b var_l1))
                                 (term_case (f_map (b var_x))
                                   (map (fn (pat, e) => (pat, f_map (term_binop (b var_x) (SS_base (ST "\092<mapsto>")) e)))
                                     [(b (SS_base (ST "None")), b var_l1), (term_some (b var_l0), a l_flatten (term_list (map b [var_l0, var_l1])))]))
                             end),
                          b (SS_base (ST "Map.empty"))])]
                end;
      in
        flatten [let
                   val _ = (fn f => fn xa => term_app f [xa]);
                   val ba = (fn s => Term_basic [s]);
                   val letsa = (fn var => fn exp => Definitiona (Term_rewrite (Term_basic [var], SS_base (ST "="), exp)));
                   val mk_var = (fn i => ba (flattena [SS_base (ST "x"), natural_to_digit10 i]));
                 in
                   print_access_choose_switch letsa mk_var expr print_access_choose_name term_list term_function term_pair
                 end,
                  [let
                     val var_pre_post = SS_base (ST "pre_post");
                     val var_to_from = SS_base (ST "to_from");
                     val var_assoc_oid = SS_base (ST "assoc_oid");
                     val var_f = SS_base (ST "f");
                     val var_oid = SS_base (ST "oid");
                   in
                     Definitiona (Term_rewrite
                                   (Term_basic [var_deref_assocs, var_pre_post, var_to_from, var_assoc_oid, var_f, var_oid], SS_base (ST "="),
                                     term_lam (SS_base (ST "\092<tau>"))
                                       (fn var_tau =>
                                         term_case (term_app var_assocs [term_app var_pre_post [Term_basic [var_tau]], Term_basic [var_assoc_oid]])
                                           [let
                                              val var_S = SS_base (ST "S");
                                            in
                                              (term_some (Term_basic [var_S]), term_app var_f [term_app var_deref_assocs_list (map b [var_to_from, var_oid, var_S]), Term_basic [var_tau]])
                                            end,
                                             (Term_basic [wildcard], term_app (SS_base (ST "invalid")) [Term_basic [var_tau]])])))
                   end]]
      end))
    x;

val pRINT_access_choose : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_choose"), print_access_choose);

fun start_ma final print = start_mapb final o (fn expr => fn base_attr => fn _ => fn _ => m_classa base_attr print expr);

fun print_astype_class x =
  start_ma overloading
    (fn compare => fn (isub_name, (name, nl_attr)) => fn OclClass (h_name, hl_attr, _) =>
      overloadinga (isub_name const_oclastype) (ty_arrowb (ty_paren (Typ_base (wrap_oclty h_name)))) (flattena [isub_name const_oclastype, SS_base (ST "_"), h_name])
        let
          val var_x = SS_base (ST "x");
        in
          Term_rewrite (term_postunary (term_annot_ocl (Term_basic [var_x]) h_name) (Term_basic [dot_astype name]), SS_base (ST "\092<equiv>"),
                         (case compare of EQ => Term_basic [var_x]
                           | LT => term_lam (SS_base (ST "\092<tau>"))
                                     (fn var_tau =>
                                       let
                                         val val_invalid = term_app (SS_base (ST "invalid")) [Term_basic [var_tau]];
                                       in
                                         term_case (term_app var_x [Term_basic [var_tau]])
                                           ((Term_basic [SS_base (ST "\092<bottom>")], val_invalid) ::
                                             (term_some (Term_basic [SS_base (ST "\092<bottom>")]), term_app (SS_base (ST "null")) [Term_basic [var_tau]]) ::
                                               let
                                                 val pattern_complex =
                                                   (fn h_namea => fn namea => fn l_extra => let
                                                                                              val isub_h = (fn s => flattenb s (isub h_namea));
                                                                                              val isub_namea = (fn s => flattenb s (isub namea));
                                                                                              val isub_n = (fn s => isub_namea (flattenb s (SS_base (ST "_"))));
                                                                                              val var_name = namea;
                                                                                            in
                                                                                              term_app (isub_h datatype_constr_name) (term_app (isub_n (isub_h datatype_ext_constr_name)) [Term_basic [var_name]] :: l_extra)
                                                                                            end);
                                                 val pattern_simple = (fn namea => let
                                                                                     val _ = (fn s => flattenb s (isub namea));
                                                                                     val var_name = namea;
                                                                                   in
                                                                                     Term_basic [var_name]
                                                                                   end);
                                                 val some_some = (fn xa => term_some (term_some xa));
                                               in
                                                 (if equal_position LT LT then [(some_some (pattern_simple h_name), some_some (pattern_complex name h_name (map (fn _ => Term_basic [SS_base (ST "None")]) nl_attr)))]
                                                   else let
                                                          val l = [(Term_basic [wildcard], val_invalid)];
                                                        in
                                                          (if equal_position LT GT then (some_some (pattern_complex h_name name (map (fn _ => Term_basic [wildcard]) hl_attr)), some_some (pattern_simple name)) :: l else l)
                                                        end)
                                               end)
                                       end)
                           | GT => term_lam (SS_base (ST "\092<tau>"))
                                     (fn var_tau =>
                                       let
                                         val val_invalid = term_app (SS_base (ST "invalid")) [Term_basic [var_tau]];
                                       in
                                         term_case (term_app var_x [Term_basic [var_tau]])
                                           ((Term_basic [SS_base (ST "\092<bottom>")], val_invalid) ::
                                             (term_some (Term_basic [SS_base (ST "\092<bottom>")]), term_app (SS_base (ST "null")) [Term_basic [var_tau]]) ::
                                               let
                                                 val pattern_complex =
                                                   (fn h_namea => fn namea => fn l_extra => let
                                                                                              val isub_h = (fn s => flattenb s (isub h_namea));
                                                                                              val isub_namea = (fn s => flattenb s (isub namea));
                                                                                              val isub_n = (fn s => isub_namea (flattenb s (SS_base (ST "_"))));
                                                                                              val var_name = namea;
                                                                                            in
                                                                                              term_app (isub_h datatype_constr_name) (term_app (isub_n (isub_h datatype_ext_constr_name)) [Term_basic [var_name]] :: l_extra)
                                                                                            end);
                                                 val pattern_simple = (fn namea => let
                                                                                     val _ = (fn s => flattenb s (isub namea));
                                                                                     val var_name = namea;
                                                                                   in
                                                                                     Term_basic [var_name]
                                                                                   end);
                                                 val some_some = (fn xa => term_some (term_some xa));
                                               in
                                                 (if equal_position GT LT then [(some_some (pattern_simple h_name), some_some (pattern_complex name h_name (map (fn _ => Term_basic [SS_base (ST "None")]) nl_attr)))]
                                                   else let
                                                          val l = [(Term_basic [wildcard], val_invalid)];
                                                        in
                                                          (if equal_position GT GT then (some_some (pattern_complex h_name name (map (fn _ => Term_basic [wildcard]) hl_attr)), some_some (pattern_simple name)) :: l else l)
                                                        end)
                                               end)
                                       end)
                           | UN => term_lam (SS_base (ST "\092<tau>"))
                                     (fn var_tau =>
                                       let
                                         val val_invalid = term_app (SS_base (ST "invalid")) [Term_basic [var_tau]];
                                       in
                                         term_case (term_app var_x [Term_basic [var_tau]])
                                           ((Term_basic [SS_base (ST "\092<bottom>")], val_invalid) ::
                                             (term_some (Term_basic [SS_base (ST "\092<bottom>")]), term_app (SS_base (ST "null")) [Term_basic [var_tau]]) ::
                                               let
                                                 val pattern_complex =
                                                   (fn h_namea => fn namea => fn l_extra => let
                                                                                              val isub_h = (fn s => flattenb s (isub h_namea));
                                                                                              val isub_namea = (fn s => flattenb s (isub namea));
                                                                                              val isub_n = (fn s => isub_namea (flattenb s (SS_base (ST "_"))));
                                                                                              val var_name = namea;
                                                                                            in
                                                                                              term_app (isub_h datatype_constr_name) (term_app (isub_n (isub_h datatype_ext_constr_name)) [Term_basic [var_name]] :: l_extra)
                                                                                            end);
                                                 val pattern_simple = (fn namea => let
                                                                                     val _ = (fn s => flattenb s (isub namea));
                                                                                     val var_name = namea;
                                                                                   in
                                                                                     Term_basic [var_name]
                                                                                   end);
                                                 val some_some = (fn xa => term_some (term_some xa));
                                               in
                                                 (if equal_position UN LT then [(some_some (pattern_simple h_name), some_some (pattern_complex name h_name (map (fn _ => Term_basic [SS_base (ST "None")]) nl_attr)))]
                                                   else let
                                                          val l = [(Term_basic [wildcard], val_invalid)];
                                                        in
                                                          (if equal_position UN GT then (some_some (pattern_complex h_name name (map (fn _ => Term_basic [wildcard]) hl_attr)), some_some (pattern_simple name)) :: l else l)
                                                        end)
                                               end)
                                       end)))
        end)
    x;

val pRINT_astype_class : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_astype.print_astype_class"), print_astype_class);

val auto : semi_method = auto_simp_add [];

fun have n = (fn a => fn b => Command_have (n, false, a, b));

fun print_allinst_exec x =
  (start_map lemma o
    map_class_top
      (fn isub_name => fn name => fn _ => fn _ => fn _ => fn _ =>
        let
          val b = (fn s => Term_basic [s]);
          val a = (fn f => fn xa => term_app f [xa]);
          val d = hol_definition;
          val f = (fn aa => Term_paren (SS_base (ST "\092<lfloor>"), SS_base (ST "\092<rfloor>"), aa));
          val f_img = (fn e1 => term_binop (b e1) (SS_base (ST "`")));
          val ran_heap = (fn var_pre_post => fn var_tau => f_img name (a (SS_base (ST "ran")) (a (SS_base (ST "heap")) (term_app var_pre_post [b var_tau]))));
          val f_incl = (fn v1 => fn v2 => let
                                            val var_tau = SS_base (ST "\092<tau>");
                                          in
                                            Term_bind (SS_base (ST "\092<And>"), b var_tau, term_binop (term_applys (term_pat v1) [b var_tau]) (SS_base (ST "\092<subseteq>")) (term_applys (term_pat v2) [b var_tau]))
                                          end);
          val var_B = SS_base (ST "B");
          val var_C = SS_base (ST "C");
        in
          gen_pre_post (fn s => flattena [isub_name s, SS_base (ST "_exec")])
            (fn f_expr => fn _ => fn var_pre_post =>
              Term_rewrite (f_expr [b name], SS_base (ST "="), term_lam (SS_base (ST "\092<tau>")) (fn var_tau => term_app var_Abs_Set [f (f (f_img (SS_base (ST "Some")) (ran_heap var_pre_post var_tau)))])))
            (fn lem_tit => fn lem_spec => fn var_pre_post => fn _ => fn _ =>
              Lemma_assumes
                (lem_tit, [], lem_spec,
                  let
                    val var_S1 = SS_base (ST "S1");
                    val var_S2 = SS_base (ST "S2");
                  in
                    [letb (term_pat var_S1) (term_lam (SS_base (ST "\092<tau>")) (ran_heap var_pre_post)),
                      letb (term_pat var_S2)
                        (term_lam (SS_base (ST "\092<tau>")) (fn var_tau => term_binop (term_applys (term_pat var_S1) [b var_tau]) (SS_base (ST "-")) (Term_paren (SS_base (ST "{"), SS_base (ST "}"), b (SS_base (ST "None")))))),
                      have var_B (f_incl var_S2 var_S1) (by [auto]), have var_C (f_incl var_S1 var_S2) (by [auto_simp_add [print_allinst_astype_name isub_name]]),
                      applya [simp_add_del [d (SS_base (ST "OclValid"))] [d (SS_base (ST "OclAllInstances_generic")), flattena [isub_name const_ocliskindof, SS_base (ST "_"), name]]]]
                  end,
                  by [insertb [oF_l (thma (SS_base (ST "equalityI"))) (map thma [var_B, var_C])], simp]))
            []
        end))
    x;

val pRINT_allinst_exec : (ocl_class -> 'a -> all_meta list * 'a) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_allinst.print_allinst_exec"), print_allinst_exec);

val var_select_object_pair : abr_string = SS_base (ST "select_object\092<^sub>P\092<^sub>a\092<^sub>i\092<^sub>r");

fun print_access_dot_aux deref_oid x =
  (case x of OclTy_base_void => Term_basic [var_reconst_basetype_void] | OclTy_base_boolean => Term_basic [var_reconst_basetype] | OclTy_base_integer => Term_basic [var_reconst_basetype]
    | OclTy_base_unlimitednatural => Term_basic [var_reconst_basetype] | OclTy_base_real => Term_basic [var_reconst_basetype] | OclTy_base_string => Term_basic [var_reconst_basetype]
    | OclTy_object (OclTyObj (OclTyCore_pre s, _)) => deref_oid (SOME s) [Term_basic [var_reconst_basetype]] | OclTy_object (OclTyObj (OclTyCore _, _)) => Term_basic [var_reconst_basetype]
    | OclTy_collection (c, ty) => term_app (if is_sequence c then var_select_object_sequence else var_select_object_set) [print_access_dot_aux deref_oid ty]
    | OclTy_pair (ty1, ty2) => term_app var_select_object_pair [print_access_dot_aux deref_oid ty1, print_access_dot_aux deref_oid ty2] | OclTy_binding _ => Term_basic [var_reconst_basetype]
    | OclTy_arrow (_, _) => Term_basic [var_reconst_basetype] | OclTy_class_syn _ => Term_basic [var_reconst_basetype] | OclTy_enum _ => Term_basic [var_reconst_basetype] | OclTy_raw _ => Term_basic [var_reconst_basetype]);

fun print_access_dot x =
  (start_mapd overloading o
    (fn expr => fn design_analysis =>
      map_class_arg_only_vara
        (fn isub_name => fn name => fn (var_in_when_state, dot_at_when) => fn attr_ty => fn isup_attr => fn dot_attr =>
          let
            val overloading_name = print_access_dot_name id dot_at_when attr_ty isup_attr;
          in
            [Overloading (overloading_name, Term_annot (Term_basic [overloading_name], ty_arrowb (ty_paren (Typ_base (wrap_oclty name)))), print_access_dot_name isub_name dot_at_when attr_ty isup_attr,
                           let
                             val var_x = SS_base (ST "x");
                           in
                             Term_rewrite (dot_attr (term_annot_ocl (Term_basic [var_x]) name), SS_base (ST "\092<equiv>"),
                                            term_app var_eval_extract
                                              [Term_basic [var_x],
                                                let
                                                  val deref_oid =
                                                    (fn attr_orig => fn l => term_app (case attr_orig of NONE => isub_name var_deref_oid | SOME orig_n => flattenb var_deref_oid (isub orig_n)) (Term_basic [var_in_when_state] :: l));
                                                in
                                                  deref_oid NONE
                                                    [(case attr_ty of OclTy_base_void => id | OclTy_base_boolean => id | OclTy_base_integer => id | OclTy_base_unlimitednatural => id | OclTy_base_real => id | OclTy_base_string => id
                                                       | OclTy_object (OclTyObj (OclTyCore_pre _, _)) => id
                                                       | OclTy_object (OclTyObj (OclTyCore ty_obj, _)) =>
                                                         (if equal_generation_semantics_ocl design_analysis Gen_only_design then id
                                                           else (fn l => term_app (print_access_deref_assocs_namea (tyObjN_ass_switch (tyObj_from ty_obj)) isub_name isup_attr) [Term_basic [var_in_when_state], l]))
                                                       | OclTy_collection (_, _) => id | OclTy_pair (_, _) => id | OclTy_binding _ => id | OclTy_arrow (_, _) => id | OclTy_class_syn _ => id | OclTy_enum _ => id | OclTy_raw _ => id)
                                                       (term_app (isup_attr (isub_name var_select))
                                                         [(case attr_ty of OclTy_base_void => print_access_dot_aux deref_oid OclTy_base_void | OclTy_base_boolean => print_access_dot_aux deref_oid OclTy_base_boolean
                                                            | OclTy_base_integer => print_access_dot_aux deref_oid OclTy_base_integer | OclTy_base_unlimitednatural => print_access_dot_aux deref_oid OclTy_base_unlimitednatural
                                                            | OclTy_base_real => print_access_dot_aux deref_oid OclTy_base_real | OclTy_base_string => print_access_dot_aux deref_oid OclTy_base_string
                                                            | OclTy_object (OclTyObj (OclTyCore_pre abr_string, xa)) => print_access_dot_aux deref_oid (OclTy_object (OclTyObj (OclTyCore_pre abr_string, xa)))
                                                            | OclTy_object (OclTyObj (OclTyCore ty_obj, _)) =>
                                                              let
                                                                val ty_obja = tyObj_to ty_obj;
                                                                val der_name = deref_oid (SOME (tyObjN_role_ty ty_obja)) [Term_basic [var_reconst_basetype]];
                                                              in
                                                                (if equal_generation_semantics_ocl design_analysis Gen_only_design
                                                                  then let
                                                                         val obj_mult = tyObjN_role_multip ty_obja;
                                                                         val (var_select_object_name_any, var_select_object_name) =
                                                                           (if is_sequence obj_mult then (var_select_object_sequence_any, var_select_object_sequence) else (var_select_object_set_any, var_select_object_set));
                                                                       in
                                                                         term_app (if single_multip obj_mult then var_select_object_name_any else var_select_object_name) [der_name]
                                                                       end
                                                                  else der_name)
                                                              end
                                                            | OclTy_collection (ocl_multiplicity_ext, ocl_ty) => print_access_dot_aux deref_oid (OclTy_collection (ocl_multiplicity_ext, ocl_ty))
                                                            | OclTy_pair (ocl_ty1, ocl_ty2) => print_access_dot_aux deref_oid (OclTy_pair (ocl_ty1, ocl_ty2)) | OclTy_binding prod => print_access_dot_aux deref_oid (OclTy_binding prod)
                                                            | OclTy_arrow (ocl_ty1, ocl_ty2) => print_access_dot_aux deref_oid (OclTy_arrow (ocl_ty1, ocl_ty2))
                                                            | OclTy_class_syn abr_string => print_access_dot_aux deref_oid (OclTy_class_syn abr_string) | OclTy_enum abr_string => print_access_dot_aux deref_oid (OclTy_enum abr_string)
                                                            | OclTy_raw _ => Term_basic [var_reconst_basetype])])]
                                                end])
                           end)]
          end)
        expr))
    x;

val pRINT_access_dot : (ocl_class -> 'a compiler_env_config_ext -> all_meta list * 'a compiler_env_config_ext) embedding_fun = Embedding_fun_info (SS_base (ST "Floor1_access.print_access_dot"), print_access_dot);

fun txt_raw_d s = txt_raw (fn n_thy => fn a => (case a of Gen_only_design => flattena (s n_thy) | Gen_only_analysis => SS_base (ST "") | Gen_default => SS_base (ST "")));

fun txt_raw_a s = txt_raw (fn n_thy => fn a => (case a of Gen_only_design => SS_base (ST "") | Gen_only_analysis => flattena (s n_thy) | Gen_default => flattena (s n_thy)));

fun subsection x = section_aux Code_Numeral.one_natural x;

fun subsectiona x = (Embedding_fun_simple o subsection) x;

val thy_class : (ocl_class, unit compiler_env_config_ext) embedding =
  let
    val section = sectiona o flattenb (SS_base (ST "Class Model: "));
    val subsection = subsectiona;
    val subsection_def = subsection (SS_base (ST "Definition"));
    val subsection_cp = subsection (SS_base (ST "Context Passing"));
    val subsection_exec = subsection (SS_base (ST "Execution with Invalid or Null as Argument"));
    val subsection_defined = subsection (SS_base (ST "Validity and Definedness Properties"));
    val subsection_up = subsection (SS_base (ST "Up Down Casting"));
    val subsection_const = subsection (SS_base (ST "Const"));
  in
    (Embed_theories o flatten)
      [[pRINT_infra_enum_synonym],
        [txt_d (fn n_thy => [flattenb (SS_base (ST "\n   \092label{ex:")) (flattenb (n_thy (SS_base (ST "employee-design:uml"))) (SS_base (ST "} ")))]),
          txt_aa (fn n_thy => [flattenb (SS_base (ST "\n   \092label{ex:")) (flattenb (n_thy (SS_base (ST "employee-analysis:uml"))) (SS_base (ST "} ")))]), section (SS_base (ST "Introduction")),
          txtb [SS_base (ST "\n\n  For certain concepts like classes and class-types, only a generic\n  definition for its resulting semantics can be given. Generic means,\n  there is a function outside \092HOL that ``compiles'' a concrete,\n  closed-world class diagram into a ``theory'' of this data model,\n  consisting of a bunch of definitions for classes, accessors, method,\n  casts, and tests for actual types, as well as proofs for the\n  fundamental properties of these operations in this concrete data\n  model. ")],
          txtb [SS_base (ST "\n   Such generic function or ``compiler'' can be implemented in\n  Isabelle on the \092ML level.  This has been done, for a semantics\n  following the open-world assumption, for \092UML 2.0\n  in~\092cite{brucker.ea:extensible:2008-b, brucker:interactive:2007}. In\n  this paper, we follow another approach for \092UML 2.4: we define the\n  concepts of the compilation informally, and present a concrete\n  example which is verified in Isabelle/\092HOL. ")],
          subsection (SS_base (ST "Outlining the Example")),
          txt_d (fn n_thy => [flattenb (SS_base (ST "\n   We are presenting here a ``design-model'' of the (slightly\nmodified) example Figure 7.3, page 20 of\nthe \092OCL standard~\092cite{omg:ocl:2012}. To be precise, this theory contains the formalization of\nthe data-part covered by the \092UML class model (see \092autoref{fig:"))
                                (flattenb (n_thy (SS_base (ST "person"))) (SS_base (ST "}):")))]),
          txt_aa (fn n_thy => [flattenb (SS_base (ST "\n   We are presenting here an ``analysis-model'' of the (slightly\nmodified) example Figure 7.3, page 20 of\nthe \092OCL standard~\092cite{omg:ocl:2012}.\nHere, analysis model means that associations\nwere really represented as relation on objects on the state---as is\nintended by the standard---rather by pointers between objects as is\ndone in our ``design model''.\nTo be precise, this theory contains the formalization of the data-part\ncovered by the \092UML class model (see \092autoref{fig:"))
                                 (flattenb (n_thy (SS_base (ST "person-ana"))) (SS_base (ST "}):")))]),
          txt_raw_d (fn n_thy => [flattenb (SS_base (ST "\n\n\092begin{figure}\n  \092centering\092scalebox{.3}{\092includegraphics{figures/person.png}}%\n  \092caption{A simple \092UML class model drawn from Figure 7.3,\n  page 20 of~\092cite{omg:ocl:2012}. \092label{fig:"))
                                    (flattenb (n_thy (SS_base (ST "person"))) (SS_base (ST "}}\n\092end{figure}\n")))]),
          txt_raw_a (fn n_thy => [flattenb (SS_base (ST "\n\n\092begin{figure}\n  \092centering\092scalebox{.3}{\092includegraphics{figures/person.png}}%\n  \092caption{A simple \092UML class model drawn from Figure 7.3,\n  page 20 of~\092cite{omg:ocl:2012}. \092label{fig:"))
                                    (flattenb (n_thy (SS_base (ST "person-ana"))) (SS_base (ST "}}\n\092end{figure}\n")))]),
          txtb [SS_base (ST "\n   This means that the association (attached to the association class\n\092inlineocl{EmployeeRanking}) with the association ends \092inlineocl+boss+ and \092inlineocl+employees+ is implemented\nby the attribute  \092inlineocl+boss+ and the operation \092inlineocl+employees+ (to be discussed in the \092OCL part\ncaptured by the subsequent theory).\n")],
          section (SS_base (ST "The Construction of the Object Universe")),
          txtb [SS_base (ST "\n   Our data universe  consists in the concrete class diagram just of node's,\nand implicitly of the class object. Each class implies the existence of a class\ntype defined for the corresponding object representations as follows: ")],
          pRINT_infra_datatype_class_1, pRINT_infra_datatype_class_2, pRINT_infra_datatype_equiv_2of1, pRINT_infra_datatype_equiv_1of2,
          txtb [SS_base (ST "\n   Now, we construct a concrete ``universe of OclAny types'' by injection into a\nsum type containing the class types. This type of OclAny will be used as instance\nfor all respective type-variables. ")],
          pRINT_infra_datatype_universe,
          txtb [SS_base (ST "\n   Having fixed the object universe, we can introduce type synonyms that exactly correspond\nto \092OCL types. Again, we exploit that our representation of \092OCL is a ``shallow embedding'' with a\none-to-one correspondance of \092OCL-types to types of the meta-language \092HOL. ")],
          pRINT_infra_type_synonym_class, pRINT_infra_type_synonym_class_higher, pRINT_infra_type_synonym_class_rec, pRINT_infra_enum_syn,
          txtb [SS_base (ST "\n   To reuse key-elements of the library like referential equality, we have\nto show that the object universe belongs to the type class ``oclany,'' \092ie,\n each class type has to provide a function @{term oid_of} yielding the Object ID (oid) of the object. ")],
          pRINT_infra_instantiation_class, pRINT_infra_instantiation_universe, section (SS_base (ST "Instantiation of the Generic Strict Equality")),
          txtb [SS_base (ST "\n   We instantiate the referential equality\non @{text \"Person\"} and @{text \"OclAny\"} ")], pRINT_instantia_def_strictrefeq, pRINT_instantia_lemmas_strictrefeq,
          txtb [SS_base (ST "\n   For each Class \092emph{C}, we will have a casting operation \092inlineocl{.oclAsType($C$)},\n   a test on the actual type \092inlineocl{.oclIsTypeOf($C$)} as well as its relaxed form\n   \092inlineocl{.oclIsKindOf($C$)} (corresponding exactly to Java's \092verb+instanceof+-operator.\n")],
          txtb [SS_base (ST "\n   Thus, since we have two class-types in our concrete class hierarchy, we have\ntwo operations to declare and to provide two overloading definitions for the two static types.\n")]],
        flatten (map (fn (title, (body_def, (body_cp, (body_exec, (body_defined, (body_up, body_const)))))) =>
                       section title :: flatten [subsection_def :: body_def, subsection_cp :: body_cp, subsection_exec :: body_exec, subsection_defined :: body_defined, subsection_up :: body_up, subsection_const :: body_const])
                  [(SS_base (ST "OclAsType"),
                     ([pRINT_astype_consts, pRINT_astype_class, pRINT_astype_from_universe, pRINT_astype_lemmas_id],
                       ([pRINT_astype_lemma_cp, pRINT_astype_lemmas_cp],
                         ([pRINT_astype_lemma_strict, pRINT_astype_lemmas_strict],
                           ([pRINT_astype_defined], ([pRINT_astype_up_d_cast0, pRINT_astype_up_d_cast, pRINT_astype_d_up_cast], [pRINT_astype_lemma_const, pRINT_astype_lemmas_const])))))),
                    (SS_base (ST "OclIsTypeOf"),
                      ([pRINT_istypeof_consts, pRINT_istypeof_class, pRINT_istypeof_from_universe, pRINT_istypeof_lemmas_id],
                        ([pRINT_istypeof_lemma_cp, pRINT_istypeof_lemmas_cp],
                          ([pRINT_istypeof_lemma_strict, pRINT_istypeof_lemmas_strict], ([pRINT_istypeof_defined, pRINT_istypeof_defineda], ([pRINT_istypeof_up_larger, pRINT_istypeof_up_d_cast], [])))))),
                    (SS_base (ST "OclIsKindOf"),
                      ([pRINT_iskindof_consts, pRINT_iskindof_class, pRINT_iskindof_from_universe, pRINT_iskindof_lemmas_id],
                        ([pRINT_iskindof_lemma_cp, pRINT_iskindof_lemmas_cp],
                          ([pRINT_iskindof_lemma_strict, pRINT_iskindof_lemmas_strict],
                            ([pRINT_iskindof_defined, pRINT_iskindof_defineda], ([pRINT_iskindof_up_eq_asty, pRINT_iskindof_up_larger, pRINT_iskindof_up_istypeof_unfold, pRINT_iskindof_up_istypeof, pRINT_iskindof_up_d_cast], []))))))]),
        [section (SS_base (ST "OclAllInstances")),
          txtb [SS_base (ST "\n   To denote \092OCL-types occurring in \092OCL expressions syntactically---as, for example,  as\n``argument'' of \092inlineisar{oclAllInstances()}---we use the inverses of the injection\nfunctions into the object universes; we show that this is sufficient ``characterization.'' ")],
          pRINT_allinst_def_id, pRINT_allinst_lemmas_id, pRINT_allinst_astype, pRINT_allinst_exec, subsection (SS_base (ST "OclIsTypeOf")), pRINT_allinst_istypeof_pre, pRINT_allinst_istypeof, subsection (SS_base (ST "OclIsKindOf")),
          pRINT_allinst_iskindof_eq, pRINT_allinst_iskindof_larger, section (SS_base (ST "The Accessors")),
          txt_d (fn n_thy => [flattenb (SS_base (ST "\n  \092label{sec:")) (flattenb (n_thy (SS_base (ST "edm-accessors"))) (SS_base (ST "}")))]),
          txt_aa (fn n_thy => [flattenb (SS_base (ST "\n  \092label{sec:")) (flattenb (n_thy (SS_base (ST "eam-accessors"))) (SS_base (ST "}")))]), subsection_def,
          txt_a [SS_base (ST "\n   We start with a oid for the association; this oid can be used\nin presence of association classes to represent the association inside an object,\npretty much similar to the \092inlineisar+Employee_DesignModel_UMLPart+, where we stored\nan \092verb+oid+ inside the class as ``pointer.'' ")],
          pRINT_access_oid_uniq_ml, pRINT_access_oid_uniq,
          txt_a [SS_base (ST "\n   From there on, we can already define an empty state which must contain\nfor $\092mathit{oid}_{Person}\092mathcal{BOSS}$ the empty relation (encoded as association list, since there are\nassociations with a Sequence-like structure).")],
          pRINT_access_eval_extract,
          txt_a [SS_base (ST "\n   The @{text pre_post}-parameter is configured with @{text fst} or\n@{text snd}, the @{text to_from}-parameter either with the identity @{term id} or\nthe following combinator @{text switch}: ")],
          pRINT_access_choose_ml, pRINT_access_choose, pRINT_access_deref_oid, pRINT_access_deref_assocs, txtb [SS_base (ST "\n   pointer undefined in state or not referencing a type conform object representation ")],
          pRINT_access_select, pRINT_access_select_obj, pRINT_access_dot_consts, pRINT_access_dot, pRINT_access_dot_lemmas_id, subsection_cp, pRINT_access_dot_cp_lemmas, pRINT_access_dot_lemma_cp, pRINT_access_dot_lemmas_cp,
          subsection_exec, pRINT_access_lemma_strict, subsection (SS_base (ST "Representation in States")), pRINT_access_def_mono, pRINT_access_is_repr, pRINT_access_repr_allinst, section (SS_base (ST "Towards the Object Instances")),
          txt_d (fn n_thy => [flattenb (SS_base (ST "\n\nThe example we are defining in this section comes from the \092autoref{fig:")) (flattenb (n_thy (SS_base (ST "edm1_system-states"))) (SS_base (ST "}.\n")))]),
          txt_raw_d (fn n_thy => [flattenb (SS_base (ST "\n\092begin{figure}\n\092includegraphics[width=\092textwidth]{figures/pre-post.pdf}\n\092caption{(a) pre-state $\092sigma_1$ and\n  (b) post-state $\092sigma_1'$.}\n\092label{fig:"))
                                    (flattenb (n_thy (SS_base (ST "edm1_system-states"))) (SS_base (ST "}\n\092end{figure}\n")))]),
          txt_aa (fn n_thy => [flattenb (SS_base (ST "\n\nThe example we are defining in this section comes from the \092autoref{fig:")) (flattenb (n_thy (SS_base (ST "eam1_system-states"))) (SS_base (ST "}.\n")))]),
          txt_raw_a (fn n_thy => [flattenb (SS_base (ST "\n\092begin{figure}\n\092includegraphics[width=\092textwidth]{figures/pre-post.pdf}\n\092caption{(a) pre-state $\092sigma_1$ and\n  (b) post-state $\092sigma_1'$.}\n\092label{fig:"))
                                    (flattenb (n_thy (SS_base (ST "eam1_system-states"))) (SS_base (ST "}\n\092end{figure}\n")))]),
          pRINT_examp_def_st_defs, pRINT_astype_lemmas_id2]]
  end;

fun map_semi_theory f =
  (fn a => (case a of META_semi_theories (Theories_one x) => META_semi_theories (Theories_one (f x)) | META_semi_theories (Theories_locale (data, l)) => META_semi_theories (Theories_locale (data, map (map f) l))
             | META_boot_generation_syntax aa => META_boot_generation_syntax aa | META_boot_setup_env aa => META_boot_setup_env aa | META_all_meta_embedding aa => META_all_meta_embedding aa));

fun map_lemma f =
  (fn a => (case a of Theory_datatype aa => Theory_datatype aa | Theory_type_synonym aa => Theory_type_synonym aa | Theory_type_notation aa => Theory_type_notation aa | Theory_instantiation aa => Theory_instantiation aa
             | Theory_overloading aa => Theory_overloading aa | Theory_consts aa => Theory_consts aa | Theory_definition aa => Theory_definition aa | Theory_lemmas aa => Theory_lemmas aa | Theory_lemma x => Theory_lemma (f x)
             | Theory_axiomatization aa => Theory_axiomatization aa | Theory_section aa => Theory_section aa | Theory_text aa => Theory_text aa | Theory_text_raw aa => Theory_text_raw aa | Theory_ML aa => Theory_ML aa
             | Theory_setup aa => Theory_setup aa | Theory_thm aa => Theory_thm aa | Theory_interpretation aa => Theory_interpretation aa | Theory_hide_const aa => Theory_hide_const aa | Theory_abbreviation aa => Theory_abbreviation aa
             | Theory_code_reflect aa => Theory_code_reflect aa));

fun fold_thy0 meta thy_object0 f =
  l_fold (fn x => fn (acc1, acc2) =>
           let
             val (sorrya, dirty) = d_output_sorry_dirty acc1;
             val (msg, xa) = (case x of Embedding_fun_info (msg, a) => (SOME msg, a) | Embedding_fun_simple a => (NONE, a));
             val (l, acc1a) = xa meta acc1;
           in
             f msg (if equal_optiona equal_generation_lemma_mode sorrya (SOME Gen_sorry) orelse is_none sorrya andalso dirty
                     then map (map_semi_theory (map_lemma (fn a => (case a of Lemma (n, spec, _, _) => Lemma (n, spec, [], sorry) | Lemma_assumes (n, spec1, spec2, _, _) => Lemma_assumes (n, spec1, spec2, [], sorry))))) l else l)
               acc1a
               acc2
           end)
    thy_object0;

fun comp_env_input_class_mk f_try f_accu_reset f_fold f =
  (fn (env, accu) =>
    f_fold f (case d_input_class env
               of NONE => let
                            val (l_class, l_env) = find_class_ass env;
                            val (l_enum, l_enva) =
                              partition (fn a => (case a of META_enum _ => true | META_class_raw (_, _) => false | META_association _ => false | META_ass_class (_, _) => false | META_ctxt (_, _) => false | META_haskell _ => false
                                                   | META_class_synonym _ => false | META_instance _ => false | META_def_base_l _ => false | META_def_state (_, _) => false | META_def_transition (_, _) => false
                                                   | META_class_tree _ => false | META_flush_all _ => false | META_generic _ => false))
                                l_env;
                          in
                            f_try (fn () => let
                                              val d_input_meta0 = d_input_meta env;
                                              val (enva, accua) =
                                                let
                                                  val meta = class_unflata (arrange_ass true (not (equal_generation_semantics_ocl (d_ocl_semantics env) Gen_default)) l_class (map (fn META_enum e => e) l_enum));
                                                  val (enva, accua) =
                                                    fold (fn ast => comp_env_save ast let
                                                                                        val META_enum metaa = ast;
                                                                                      in
                                                                                        fold_thy0 metaa thy_enum
                                                                                      end
                                                                      f)
                                                      l_enum let
                                                               val enva = compiler_env_config_reset_no_env env;
                                                             in
                                                               (d_input_meta_update
                                                                  (fn _ => filter (fn a => (case a of META_enum _ => false | META_class_raw (_, _) => true | META_association _ => true | META_ass_class (_, _) => true
                                                                                             | META_ctxt (_, _) => true | META_haskell _ => true | META_class_synonym _ => true | META_instance _ => true | META_def_base_l _ => true
                                                                                             | META_def_state (_, _) => true | META_def_transition (_, _) => true | META_class_tree _ => true | META_flush_all _ => true
                                                                                             | META_generic _ => true))
                                                                             (d_input_meta enva))
                                                                  enva,
                                                                 f_accu_reset enva accu)
                                                             end;
                                                  val a = fold_thy0 meta thy_class f (enva, accua);
                                                  val (envb, aa) = a;
                                                in
                                                  (d_input_class_update (fn _ => SOME meta) envb, aa)
                                                end;
                                              val a = fold (fn ast => comp_env_save ast
                                                                        (case ast of META_ctxt (floor, meta) => fold_thy0 meta (thy_ctxt floor) | META_haskell meta => fold_thy0 meta thy_haskell
                                                                          | META_instance meta => fold_thy0 meta thy_instance | META_def_base_l meta => fold_thy0 meta thy_def_base_l
                                                                          | META_def_state (floor, meta) => fold_thy0 meta (thy_def_state floor) | META_def_transition (floor, meta) => fold_thy0 meta (thy_def_transition floor)
                                                                          | META_flush_all meta => fold_thy0 meta thy_flush_all)
                                                                        f)
                                                        l_enva (d_input_meta_update (fn _ => flatten [l_class, l_enum]) enva, accua);
                                              val (envb, aa) = a;
                                            in
                                              (d_input_meta_update (fn _ => d_input_meta0) envb, aa)
                                            end)
                          end
               | SOME _ => (env, accu)));

val thy_class_synonym : ('a, 'b) embedding = Embed_theories [];

val thy_association : ('a, 'b) embedding = Embed_theories [];

val thy_class_tree : ('a, 'b) embedding = Embed_theories [];

val thy_class_flat : ('a, 'b) embedding = Embed_theories [];

val thy_enum_flat : ('a, 'b) embedding = Embed_theories [];

val thy_generic : ('a, 'b) embedding = Embed_theories [];

fun fold_thy f_env_save f_try f_accu_reset =
  let
    val comp_env_input_class_mka = comp_env_input_class_mk f_try f_accu_reset;
  in
    (fn f => let
               val fold_m = (fn ast => f_env_save ast
                                         (case ast of META_enum meta => comp_env_input_class_rm (fold_thy0 meta thy_enum_flat) | META_class_raw (Floor1, meta) => comp_env_input_class_rm (fold_thy0 meta thy_class_flat)
                                           | META_association meta => comp_env_input_class_rm (fold_thy0 meta thy_association)
                                           | META_ass_class (Floor1, OclAssClass (meta_ass, meta_class)) => comp_env_input_class_rm (comp_env_input_class_bind [fold_thy0 meta_ass thy_association, fold_thy0 meta_class thy_class_flat])
                                           | META_ctxt (floor, meta) => comp_env_input_class_mka (fold_thy0 meta (thy_ctxt floor)) | META_haskell meta => comp_env_input_class_mka (fold_thy0 meta thy_haskell)
                                           | META_class_synonym meta => comp_env_input_class_rm (fold_thy0 meta thy_class_synonym) | META_instance meta => comp_env_input_class_mka (fold_thy0 meta thy_instance)
                                           | META_def_base_l meta => fold_thy0 meta thy_def_base_l | META_def_state (floor, meta) => comp_env_input_class_mka (fold_thy0 meta (thy_def_state floor))
                                           | META_def_transition (floor, meta) => fold_thy0 meta (thy_def_transition floor) | META_class_tree meta => comp_env_input_class_rm (fold_thy0 meta thy_class_tree)
                                           | META_flush_all meta => comp_env_input_class_mka (fold_thy0 meta thy_flush_all) | META_generic meta => fold_thy0 meta thy_generic)
                                         f);
             in
               (fn a => (case a of Fold_meta aa => fold_m aa
                          | Fold_custom aa =>
                            fold (fn ab => (case ab of META_semi_theories semi_theories => fold_thy0 () (Embed_theories [Embedding_fun_simple (fn _ => (fn ac => ([META_semi_theories semi_theories], ac)))]) f
                                             | META_boot_generation_syntax boot_generation_syntax => fold_thy0 () (Embed_theories [Embedding_fun_simple (fn _ => (fn ac => ([META_boot_generation_syntax boot_generation_syntax], ac)))]) f
                                             | META_boot_setup_env boot_setup_env => fold_thy0 () (Embed_theories [Embedding_fun_simple (fn _ => (fn ac => ([META_boot_setup_env boot_setup_env], ac)))]) f
                                             | META_all_meta_embedding ac => fold_m ac))
                              aa))
             end)
  end;

fun fold_thya f_env_save f_try f_accu_reset f = fold (fold_thy f_env_save f_try f_accu_reset f) o mapa Fold_meta;

fun replace_gen f_res l c0 lby = let
                                   val nsplit_text = (fn la => fn lgen => (if null la then lgen else Nsplit_text la :: lgen));
                                   val (la, lgen) = foldr (fn c1 => fn (la, lgen) => (if c0 c1 then (lby, Nsplit_sep c1 :: nsplit_text la lgen) else (c1 :: la, lgen))) l ([], []);
                                 in
                                   f_res (nsplit_text la lgen)
                                 end;

fun nsplit_f l c0 = replace_gen id l c0 [];

fun escape_sml x = replace_integersa (fn n => (if n = (34 : IntInf.int) then SS_base (ST "\092\"") else SS_base (STa [n]))) x;

fun is_special x = member equal_integer ((List.map (fn c => let val k = Char.ord c in if k < 128 then IntInf.fromInt k else raise Fail "Non-ASCII character in literal" end)  o String.explode) " <>^_=-./(){}") x;

fun ap1 a v0 f1 v1 = a v0 [f1 v1];

fun ap2 a v0 f1 f2 v1 v2 = a v0 [f1 v1, f2 v2];

fun ap3 a v0 f1 f2 f3 v1 v2 v3 = a v0 [f1 v1, f2 v2, f3 v3];

fun ap4 a v0 f1 f2 f3 f4 v1 v2 v3 v4 = a v0 [f1 v1, f2 v2, f3 v3, f4 v4];

fun ap5 a v0 f1 f2 f3 f4 f5 v1 v2 v3 v4 v5 = a v0 [f1 v1, f2 v2, f3 v3, f4 v4, f5 v5];

fun ap6 a v0 f1 f2 f3 f4 f5 f6 v1 v2 v3 v4 v5 v6 = a v0 [f1 v1, f2 v2, f3 v3, f4 v4, f5 v5, f6 v6];

fun ar1 a v0 z = a v0 [z];

fun ar2 a v0 f1 v1 z = a v0 [f1 v1, z];

fun ar3 a v0 f1 f2 v1 v2 z = a v0 [f1 v1, f2 v2, z];

fun co1 x = (fn a => x o a);

fun co2 f g x1 x2 = f (g x1 x2);

fun cIf x = (fn a => fn b => fn c => CIf0 (x, a, b, c));

fun ap16 a v0 f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 v1 v2 v3 v4 v5 v6 v7 v8 v9 v10 v11 v12 v13 v14 v15 v16 =
  a v0 [f1 v1, f2 v2, f3 v3, f4 v4, f5 v5, f6 v6, f7 v7, f8 v8, f9 v9, f10 v10, f11 v11, f12 v12, f13 v13, f14 v14, f15 v15, f16 v16];

fun cAsm x = (fn a => CAsm0 (x, a));

fun cFor x = (fn a => fn b => fn c => fn d => CFor0 (x, a, b, c, d));

fun cVar x = (fn a => CVar0 (x, a));

fun name x = Name0 x;

fun cAttr x = (fn a => fn b => CAttr0 (x, a, b));

fun cAuto x = CAuto0 x;

fun cCall x = (fn a => fn b => CCall0 (x, a, b));

fun cCase x = (fn a => fn b => CCase0 (x, a, b));

fun cCast x = (fn a => fn b => CCast0 (x, a, b));

fun cChar x = (fn a => CChar0 (x, a));

fun cCond x = (fn a => fn b => fn c => CCond0 (x, a, b, c));

fun cCont x = CCont0 x;

fun cDecl x = (fn a => fn b => CDecl0 (x, a, b));

fun cEnum x = (fn a => fn b => fn c => CEnum0 (x, a, b, c));

val cEqOp : cBinaryOp = CEqOp0;

fun cExpr x = (fn a => CExpr0 (x, a));

fun cGoto x = (fn a => CGoto0 (x, a));

val cGrOp : cBinaryOp = CGrOp0;

val cLeOp : cBinaryOp = CLeOp0;

val cOrOp : cBinaryOp = COrOp0;

fun flags x = Flags0 x;

fun identc x = (fn a => fn b => Ident0 (x, a, b));

fun d_output_position_update d_output_positiona
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = Compiler_env_config_ext
      (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_positiona d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap,
        d_ocl_accessor, d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more);

fun d_output_position
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = d_output_position;

fun print_meta_setup_def_transition s env = snd (print_transition_gen s env) env;

fun print_meta_setup_def_state s env = snd (print_examp_def_st1_gen s env) env;

fun comp_env_save_deep ast f_fold =
  comp_env_save ast
    (fn f => map_prod (case ast of META_enum _ => id | META_class_raw (_, _) => id | META_association _ => id | META_ass_class (_, _) => id | META_ctxt (_, _) => id | META_haskell _ => id | META_class_synonym _ => id
                        | META_instance _ => id | META_def_base_l _ => id | META_def_state (Floor1, meta) => print_meta_setup_def_state meta | META_def_state (Floor2, _) => id | META_def_state (Floor3, _) => id
                        | META_def_transition (Floor1, meta) => print_meta_setup_def_transition meta | META_def_transition (Floor2, _) => id | META_def_transition (Floor3, _) => id | META_class_tree _ => id | META_flush_all _ => id
                        | META_generic _ => id)
               id o
               f_fold f);

fun fold_thy_deep obj env =
  let
    val (enva, output_position) =
      fold_thy comp_env_save_deep (fn f => f ()) (fn enva => fn _ => d_output_position enva)
        (fn _ => fn l => fn acc1 => fn (i, cpt) => (acc1, (succ (one_natural, plus_natural) i, Code_Numeral.plus_natural (natural_of_nat (size_list l)) cpt))) obj (env, d_output_position env);
  in
    d_output_position_update (fn _ => output_position) enva
  end;

fun rec_list f1 f2 [] = f1
  | rec_list f1 f2 (x21 :: x22) = f2 x21 x22 (rec_list f1 f2 x22);

fun list_iterM f l = fold (fn x => fn m => CodeConst.Monad.bind m (fn () => f x)) l (CodeConst.Monad.return ());

fun d_output_header_force
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = d_output_header_force;

fun d_hsk_constr
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = d_hsk_constr;

fun compiler_env_config_rec0 f env =
  f (d_output_disable_thy env) (d_output_header_thy env) (d_ocl_oid_start env) (d_output_position env) (d_ocl_semantics env) (d_input_class env) (d_input_meta env) (d_input_instance env) (d_input_state env) (d_output_header_force env)
    (d_output_auto_bootstrap env)
    (d_ocl_accessor env)
    (d_ocl_HO_type env)
    (d_hsk_constr env)
    (d_output_sorry_dirty env);

fun moreg (Compiler_env_config_ext
            (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
              d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = more;

fun compiler_env_config_rec f env = compiler_env_config_rec0 f env (moreg env);

fun truncate x = compiler_env_config_rec (co15 k makea) x;

fun extend x =
  (fn env => fn v =>
    compiler_env_config_rec0
      (co15 (fn f => f v) (fn a => fn b => fn c => fn d => fn e => fn f => fn g => fn h => fn i => fn j => fn k => fn l => fn m => fn n => fn oa => fn p => Compiler_env_config_ext (a, b, c, d, e, f, g, h, i, j, k, l, m, n, oa, p))) env)
    x;

fun compiler_env_config_more_map f ocl = extend (truncate ocl) (f (moreg ocl));

fun of_semi_typ to_string e =
  (case e of Typ_apply (name, l) => CodeConst.Printf.sprintf2 "%s %s" let
                                                                        val s = CodeConst.String.concat ", " (mapa (of_semi_typ to_string) l);
                                                                      in
                                                                        (case l of [] => CodeConst.Printf.sprintf1 "(%s)" s | [_] => s | _ :: _ :: _ => CodeConst.Printf.sprintf1 "(%s)" s)
                                                                      end
                                      (of_semi_typ to_string name)
    | Typ_apply_bin (s, ty1, ty2) => CodeConst.Printf.sprintf3 "%s %s %s" (of_semi_typ to_string ty1) (to_string s) (of_semi_typ to_string ty2)
    | Typ_apply_paren (s1, s2, ty) => CodeConst.Printf.sprintf3 "%s%s%s" (to_string s1) (of_semi_typ to_string ty) (to_string s2) | Typ_base a => to_string a);

fun of_pure_typa to_string e =
  (case e of Typeb (s, l) =>
            (if equal s (SS_base (ST "fun")) then CodeConst.Printf.sprintf1 "(%s)" (CodeConst.String.concat " \092<Rightarrow> " (mapa (of_pure_typa to_string) l))
              else (if equal s (SS_base (ST "Product_Type.prod")) then CodeConst.Printf.sprintf1 "(%s)" (CodeConst.String.concat " \092<times> " (mapa (of_pure_typa to_string) l))
                     else CodeConst.Printf.sprintf2 "%s%s" (case l of [] => "" | _ :: _ => CodeConst.Printf.sprintf1 "(%s) " (CodeConst.String.concat ", " (mapa (of_pure_typa to_string) l))) (to_string s)))
    | TFree (_, _) => "_");

fun pure_typ0 to_string show_t s t = let
                                       val sa = to_string s;
                                     in
                                       (if show_t then CodeConst.Printf.sprintf2 "(%s :: %s)" sa (of_pure_typa to_string t) else sa)
                                     end;

fun of_pure_terma to_string show_t l e =
  (case e of Consta (a, b) => pure_typ0 to_string show_t a b | Free (a, b) => pure_typ0 to_string show_t a b | Bound n => CodeConst.Printf.sprintf1 "%s" (nth l (nat_of_natural n))
    | Absa (s, st, t) => CodeConst.Printf.sprintf2 "(\092<lambda> %s. %s)" (pure_typ0 to_string show_t s st) (of_pure_terma to_string show_t (to_string s :: l) t)
    | Appa (t1, t2) => CodeConst.Printf.sprintf2 "(%s) (%s)" (of_pure_terma to_string show_t l t1) (of_pure_terma to_string show_t l t2));

fun of_semi_terma to_string e =
  (case e of Term_rewrite (e1, symb, e2) => CodeConst.Printf.sprintf3 "%s %s %s" (of_semi_terma to_string e1) (to_string symb) (of_semi_terma to_string e2)
    | Term_basic l => CodeConst.Printf.sprintf1 "%s" (CodeConst.String.concat " " (map to_string l)) | Term_annot (ea, s) => CodeConst.Printf.sprintf2 "(%s::%s)" (of_semi_terma to_string ea) (of_semi_typ to_string s)
    | Term_bind (symb, e1, e2) => CodeConst.Printf.sprintf3 "(%s%s. %s)" (to_string symb) (of_semi_terma to_string e1) (of_semi_terma to_string e2)
    | Term_fun_case (e_case, l) =>
      CodeConst.Printf.sprintf2 "(%s %s)" (case e_case of NONE => "\092<lambda>" | SOME ea => CodeConst.Printf.sprintf1 "case %s of" (of_semi_terma to_string ea))
        (CodeConst.String.concat "\n    | " (mapa (fn (s1, s2) => CodeConst.Printf.sprintf2 "%s \092<Rightarrow> %s" (of_semi_terma to_string s1) (of_semi_terma to_string s2)) l))
    | Term_apply (ea, l) => CodeConst.Printf.sprintf2 "%s %s" (of_semi_terma to_string ea) (CodeConst.String.concat " " (mapa (fn x => CodeConst.Printf.sprintf1 "%s" (of_semi_terma to_string x)) l))
    | Term_paren (p_left, p_right, ea) => CodeConst.Printf.sprintf3 "%s%s%s" (to_string p_left) (of_semi_terma to_string ea) (to_string p_right)
    | Term_if_then_else (e_if, e_then, e_else) => CodeConst.Printf.sprintf3 "if %s then %s else %s" (of_semi_terma to_string e_if) (of_semi_terma to_string e_then) (of_semi_terma to_string e_else)
    | Term_let (l, e_body) =>
      CodeConst.Printf.sprintf2 "let %s in %s" (CodeConst.String.concat "; " (mapa (fn (e1, e2) => CodeConst.Printf.sprintf2 "%s = %s" (of_semi_terma to_string e1) (of_semi_terma to_string e2)) l)) (of_semi_terma to_string e_body)
    | Term_term (l, a) => of_pure_terma to_string true (map to_string l) a);

fun of_section to_string uu =
  (fn Section (n, section_title) =>
    CodeConst.Printf.sprintf2 "%s \092<open>%s\092<close>" (CodeConst.Printf.sprintf1 "%ssection" (if equal_naturala n Code_Numeral.zero_natural then "" else (if equal_naturala n Code_Numeral.one_natural then "sub" else "subsub")))
      (to_string section_title));

fun of_e_n_v_section to_string env = (if d_output_disable_thy env then (fn _ => "") else of_section to_string env);

fun of_semi_thm_attribute_aux_gen_where to_string l = ("where", CodeConst.String.concat " and " (map (fn (var, expr) => CodeConst.Printf.sprintf2 "%s = \"%s\"" (to_string var) (of_semi_terma to_string expr)) l));

fun of_semi_thm_attribute_aux_gen_of to_string l = ("of", CodeConst.String.concat " " (map (fn expr => CodeConst.Printf.sprintf1 "\"%s\"" (of_semi_terma to_string expr)) l));

fun of_semi_thm_attribute_aux_gen to_string m lacc s =
  let
    val s_base = (fn sa => fn lacca => CodeConst.Printf.sprintf2 "%s[%s]" (to_string sa) (CodeConst.String.concat ", " (map (fn (a, b) => CodeConst.Printf.sprintf2 "%s %s" a b) lacca)));
  in
    s_base s (m :: lacc)
  end;

fun of_semi_thm_attribute_aux to_string lacc e =
  (case e of Thm_thm a => to_string a | Thm_thms a => to_string a | Thm_THEN (Thm_thm a, e2) => of_semi_thm_attribute_aux_gen to_string ("THEN", of_semi_thm_attribute_aux to_string [] e2) lacc a
    | Thm_THEN (Thm_thms a, e2) => of_semi_thm_attribute_aux_gen to_string ("THEN", of_semi_thm_attribute_aux to_string [] e2) lacc a
    | Thm_THEN (Thm_THEN (semi_thm_attribute1, semi_thm_attribute2a), e2) => of_semi_thm_attribute_aux to_string (("THEN", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_THEN (semi_thm_attribute1, semi_thm_attribute2a))
    | Thm_THEN (Thm_simplified (semi_thm_attribute1, semi_thm_attribute2a), e2) =>
      of_semi_thm_attribute_aux to_string (("THEN", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_simplified (semi_thm_attribute1, semi_thm_attribute2a))
    | Thm_THEN (Thm_symmetric semi_thm_attribute, e2) => of_semi_thm_attribute_aux to_string (("THEN", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_symmetric semi_thm_attribute)
    | Thm_THEN (Thm_where (semi_thm_attribute, lista), e2) => of_semi_thm_attribute_aux to_string (("THEN", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_where (semi_thm_attribute, lista))
    | Thm_THEN (Thm_of (semi_thm_attribute, lista), e2) => of_semi_thm_attribute_aux to_string (("THEN", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_of (semi_thm_attribute, lista))
    | Thm_THEN (Thm_OF (semi_thm_attribute1, semi_thm_attribute2a), e2) => of_semi_thm_attribute_aux to_string (("THEN", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_OF (semi_thm_attribute1, semi_thm_attribute2a))
    | Thm_simplified (Thm_thm a, e2) => of_semi_thm_attribute_aux_gen to_string ("simplified", of_semi_thm_attribute_aux to_string [] e2) lacc a
    | Thm_simplified (Thm_thms a, e2) => of_semi_thm_attribute_aux_gen to_string ("simplified", of_semi_thm_attribute_aux to_string [] e2) lacc a
    | Thm_simplified (Thm_THEN (semi_thm_attribute1, semi_thm_attribute2a), e2) =>
      of_semi_thm_attribute_aux to_string (("simplified", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_THEN (semi_thm_attribute1, semi_thm_attribute2a))
    | Thm_simplified (Thm_simplified (semi_thm_attribute1, semi_thm_attribute2a), e2) =>
      of_semi_thm_attribute_aux to_string (("simplified", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_simplified (semi_thm_attribute1, semi_thm_attribute2a))
    | Thm_simplified (Thm_symmetric semi_thm_attribute, e2) => of_semi_thm_attribute_aux to_string (("simplified", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_symmetric semi_thm_attribute)
    | Thm_simplified (Thm_where (semi_thm_attribute, lista), e2) => of_semi_thm_attribute_aux to_string (("simplified", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_where (semi_thm_attribute, lista))
    | Thm_simplified (Thm_of (semi_thm_attribute, lista), e2) => of_semi_thm_attribute_aux to_string (("simplified", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_of (semi_thm_attribute, lista))
    | Thm_simplified (Thm_OF (semi_thm_attribute1, semi_thm_attribute2a), e2) =>
      of_semi_thm_attribute_aux to_string (("simplified", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_OF (semi_thm_attribute1, semi_thm_attribute2a))
    | Thm_symmetric a =>
      (case a of Thm_thm aa => of_semi_thm_attribute_aux_gen to_string ("symmetric", "") lacc aa | Thm_thms aa => of_semi_thm_attribute_aux_gen to_string ("symmetric", "") lacc aa
        | Thm_THEN (semi_thm_attribute1, semi_thm_attribute2) => of_semi_thm_attribute_aux to_string (("symmetric", "") :: lacc) (Thm_THEN (semi_thm_attribute1, semi_thm_attribute2))
        | Thm_simplified (semi_thm_attribute1, semi_thm_attribute2) => of_semi_thm_attribute_aux to_string (("symmetric", "") :: lacc) (Thm_simplified (semi_thm_attribute1, semi_thm_attribute2))
        | Thm_symmetric semi_thm_attribute => of_semi_thm_attribute_aux to_string (("symmetric", "") :: lacc) (Thm_symmetric semi_thm_attribute)
        | Thm_where (semi_thm_attribute, lista) => of_semi_thm_attribute_aux to_string (("symmetric", "") :: lacc) (Thm_where (semi_thm_attribute, lista))
        | Thm_of (semi_thm_attribute, lista) => of_semi_thm_attribute_aux to_string (("symmetric", "") :: lacc) (Thm_of (semi_thm_attribute, lista))
        | Thm_OF (semi_thm_attribute1, semi_thm_attribute2) => of_semi_thm_attribute_aux to_string (("symmetric", "") :: lacc) (Thm_OF (semi_thm_attribute1, semi_thm_attribute2)))
    | Thm_where (Thm_thm a, l) => of_semi_thm_attribute_aux_gen to_string (of_semi_thm_attribute_aux_gen_where to_string l) lacc a
    | Thm_where (Thm_thms a, l) => of_semi_thm_attribute_aux_gen to_string (of_semi_thm_attribute_aux_gen_where to_string l) lacc a
    | Thm_where (Thm_THEN (semi_thm_attribute1, semi_thm_attribute2), l) => of_semi_thm_attribute_aux to_string (of_semi_thm_attribute_aux_gen_where to_string l :: lacc) (Thm_THEN (semi_thm_attribute1, semi_thm_attribute2))
    | Thm_where (Thm_simplified (semi_thm_attribute1, semi_thm_attribute2), l) => of_semi_thm_attribute_aux to_string (of_semi_thm_attribute_aux_gen_where to_string l :: lacc) (Thm_simplified (semi_thm_attribute1, semi_thm_attribute2))
    | Thm_where (Thm_symmetric semi_thm_attribute, l) => of_semi_thm_attribute_aux to_string (of_semi_thm_attribute_aux_gen_where to_string l :: lacc) (Thm_symmetric semi_thm_attribute)
    | Thm_where (Thm_where (semi_thm_attribute, lista), l) => of_semi_thm_attribute_aux to_string (of_semi_thm_attribute_aux_gen_where to_string l :: lacc) (Thm_where (semi_thm_attribute, lista))
    | Thm_where (Thm_of (semi_thm_attribute, lista), l) => of_semi_thm_attribute_aux to_string (of_semi_thm_attribute_aux_gen_where to_string l :: lacc) (Thm_of (semi_thm_attribute, lista))
    | Thm_where (Thm_OF (semi_thm_attribute1, semi_thm_attribute2), l) => of_semi_thm_attribute_aux to_string (of_semi_thm_attribute_aux_gen_where to_string l :: lacc) (Thm_OF (semi_thm_attribute1, semi_thm_attribute2))
    | Thm_of (Thm_thm a, l) => of_semi_thm_attribute_aux_gen to_string (of_semi_thm_attribute_aux_gen_of to_string l) lacc a
    | Thm_of (Thm_thms a, l) => of_semi_thm_attribute_aux_gen to_string (of_semi_thm_attribute_aux_gen_of to_string l) lacc a
    | Thm_of (Thm_THEN (semi_thm_attribute1, semi_thm_attribute2), l) => of_semi_thm_attribute_aux to_string (of_semi_thm_attribute_aux_gen_of to_string l :: lacc) (Thm_THEN (semi_thm_attribute1, semi_thm_attribute2))
    | Thm_of (Thm_simplified (semi_thm_attribute1, semi_thm_attribute2), l) => of_semi_thm_attribute_aux to_string (of_semi_thm_attribute_aux_gen_of to_string l :: lacc) (Thm_simplified (semi_thm_attribute1, semi_thm_attribute2))
    | Thm_of (Thm_symmetric semi_thm_attribute, l) => of_semi_thm_attribute_aux to_string (of_semi_thm_attribute_aux_gen_of to_string l :: lacc) (Thm_symmetric semi_thm_attribute)
    | Thm_of (Thm_where (semi_thm_attribute, lista), l) => of_semi_thm_attribute_aux to_string (of_semi_thm_attribute_aux_gen_of to_string l :: lacc) (Thm_where (semi_thm_attribute, lista))
    | Thm_of (Thm_of (semi_thm_attribute, lista), l) => of_semi_thm_attribute_aux to_string (of_semi_thm_attribute_aux_gen_of to_string l :: lacc) (Thm_of (semi_thm_attribute, lista))
    | Thm_of (Thm_OF (semi_thm_attribute1, semi_thm_attribute2), l) => of_semi_thm_attribute_aux to_string (of_semi_thm_attribute_aux_gen_of to_string l :: lacc) (Thm_OF (semi_thm_attribute1, semi_thm_attribute2))
    | Thm_OF (Thm_thm a, e2) => of_semi_thm_attribute_aux_gen to_string ("OF", of_semi_thm_attribute_aux to_string [] e2) lacc a
    | Thm_OF (Thm_thms a, e2) => of_semi_thm_attribute_aux_gen to_string ("OF", of_semi_thm_attribute_aux to_string [] e2) lacc a
    | Thm_OF (Thm_THEN (semi_thm_attribute1, semi_thm_attribute2a), e2) => of_semi_thm_attribute_aux to_string (("OF", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_THEN (semi_thm_attribute1, semi_thm_attribute2a))
    | Thm_OF (Thm_simplified (semi_thm_attribute1, semi_thm_attribute2a), e2) =>
      of_semi_thm_attribute_aux to_string (("OF", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_simplified (semi_thm_attribute1, semi_thm_attribute2a))
    | Thm_OF (Thm_symmetric semi_thm_attribute, e2) => of_semi_thm_attribute_aux to_string (("OF", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_symmetric semi_thm_attribute)
    | Thm_OF (Thm_where (semi_thm_attribute, lista), e2) => of_semi_thm_attribute_aux to_string (("OF", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_where (semi_thm_attribute, lista))
    | Thm_OF (Thm_of (semi_thm_attribute, lista), e2) => of_semi_thm_attribute_aux to_string (("OF", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_of (semi_thm_attribute, lista))
    | Thm_OF (Thm_OF (semi_thm_attribute1, semi_thm_attribute2a), e2) => of_semi_thm_attribute_aux to_string (("OF", of_semi_thm_attribute_aux to_string [] e2) :: lacc) (Thm_OF (semi_thm_attribute1, semi_thm_attribute2a)));

fun of_semi_thm_attribute to_string = of_semi_thm_attribute_aux to_string [];

fun of_semi_thm_attribute_l1 to_string l = CodeConst.String.concat " " (map (of_semi_thm_attribute to_string) l);

fun of_semi_attrib_genA f attr l = (if null l then "" else CodeConst.Printf.sprintf2 " %s: %s" attr (f l));

fun of_semi_thm to_string = (fn a => (case a of Thms_single aa => of_semi_thm_attribute to_string aa | Thms_mult aa => of_semi_thm_attribute to_string aa));

fun of_semi_thm_l to_string l = CodeConst.String.concat " " (map (of_semi_thm to_string) l);

fun of_semi_attrib to_string = of_semi_attrib_genA (of_semi_thm_l to_string);

fun of_semi_method_simp to_string s =
  (fn a => (case a of Method_simp_only l => CodeConst.Printf.sprintf2 "%s only: %s" s (of_semi_thm_l to_string l)
             | Method_simp_add_del_split (l1, l2, aa) =>
               (case aa of [] => CodeConst.Printf.sprintf3 "%s%s%s" s (of_semi_attrib to_string "add" l1) (of_semi_attrib to_string "del" l2)
                 | ab :: lista => CodeConst.Printf.sprintf4 "%s%s%s%s" s (of_semi_attrib to_string "add" l1) (of_semi_attrib to_string "del" l2) (of_semi_attrib to_string "split" (ab :: lista)))));

fun of_semi_attrib_genB f attr l = (if null l then "" else CodeConst.Printf.sprintf2 " %s: %s" attr (f l));

fun of_semi_attrib1 to_string = of_semi_attrib_genB (fn l => CodeConst.String.concat " " (map to_string l));

fun of_semi_method to_string to_nat expr =
  (case expr of Method_rule o_s => CodeConst.Printf.sprintf1 "rule%s" (case o_s of NONE => "" | SOME s => CodeConst.Printf.sprintf1 " %s" (of_semi_thm_attribute to_string s))
    | Method_drule s => CodeConst.Printf.sprintf1 "drule %s" (of_semi_thm_attribute to_string s) | Method_erule s => CodeConst.Printf.sprintf1 "erule %s" (of_semi_thm_attribute to_string s)
    | Method_intro l => CodeConst.Printf.sprintf1 "intro %s" (of_semi_thm_attribute_l1 to_string l) | Method_elim s => CodeConst.Printf.sprintf1 "elim %s" (of_semi_thm_attribute to_string s)
    | Method_subst (asm, l, s) =>
      let
        val s_asm = (if asm then "(asm) " else "");
      in
        (if equal_lista equal_literal (map meta_of_logic l) ["0"] then CodeConst.Printf.sprintf2 "subst %s%s" s_asm (of_semi_thm_attribute to_string s)
          else CodeConst.Printf.sprintf3 "subst %s(%s) %s" s_asm (CodeConst.String.concat " " (map to_string l)) (of_semi_thm_attribute to_string s))
      end
    | Method_insert l => CodeConst.Printf.sprintf1 "insert %s" (of_semi_thm_l to_string l) | Method_plus t => CodeConst.Printf.sprintf1 "(%s)+" (CodeConst.String.concat ", " (mapa (of_semi_method to_string to_nat) t))
    | Method_option t => CodeConst.Printf.sprintf1 "(%s)?" (CodeConst.String.concat ", " (mapa (of_semi_method to_string to_nat) t))
    | Method_or t => CodeConst.Printf.sprintf1 "(%s)" (CodeConst.String.concat " | " (mapa (of_semi_method to_string to_nat) t)) | Method_one a => of_semi_method_simp to_string "simp" a
    | Method_all a => of_semi_method_simp to_string "simp_all" a | Method_auto_simp_add_split (l_simp, l_split) => CodeConst.Printf.sprintf2 "auto%s%s" (of_semi_attrib to_string "simp" l_simp) (of_semi_attrib1 to_string "split" l_split)
    | Method_rename_tac l => CodeConst.Printf.sprintf1 "rename_tac %s" (CodeConst.String.concat " " (map to_string l)) | Method_case_tac e => CodeConst.Printf.sprintf1 "case_tac \"%s\"" (of_semi_terma to_string e)
    | Method_blast NONE => "blast" | Method_blast (SOME n) => CodeConst.Printf.sprintf1 "blast %d" (to_nat n) | Method_clarify => "clarify"
    | Method_metis (l_opt, l) => CodeConst.Printf.sprintf2 "metis %s%s" (if null l_opt then "" else CodeConst.Printf.sprintf1 "(%s) " (CodeConst.String.concat ", " (map to_string l_opt))) (of_semi_thm_attribute_l1 to_string l));

fun of_semi_command_final to_string to_nat =
  (fn a => (case a of Command_done => "done" | Command_by l_apply => CodeConst.Printf.sprintf1 "by(%s)" (CodeConst.String.concat ", " (map (of_semi_method to_string to_nat) l_apply)) | Command_sorry => "sorry"));

fun of_interpretation to_string to_nat uu =
  (fn Interpretation (n, loc_n, loc_param, tac) =>
    CodeConst.Printf.sprintf4 "interpretation %s: %s%s\n%s" (to_string n) (to_string loc_n) (CodeConst.String.concat "" (map (fn s => CodeConst.Printf.sprintf1 " \"%s\"" (of_semi_terma to_string s)) loc_param))
      (of_semi_command_final to_string to_nat tac));

fun of_axiomatization to_string uu = (fn Axiomatization (n, e) => CodeConst.Printf.sprintf2 "axiomatization where %s:\n\"%s\"" (to_string n) (of_semi_terma to_string e));

fun of_type_notation to_string uu = (fn Type_notation (n, e) => CodeConst.Printf.sprintf2 "type_notation %s (\"%s\")" (to_string n) (to_string e));

fun of_instantiation to_string uu =
  (fn Instantiation (n, n_def, expr) => let
                                          val name = to_string n;
                                        in
                                          CodeConst.Printf.sprintf4 "instantiation %s :: object\nbegin\n  definition %s_%s_def : \"%s\"\n  instance ..\nend" name (to_string n_def) name (of_semi_terma to_string expr)
                                        end);

fun of_code_reflect to_string uu =
  (fn Code_reflect (b, s, l) =>
    CodeConst.Printf.sprintf3 "code_reflect' %s%s%s" (if b then "open " else "") (to_string s) (case l of [] => "" | _ :: _ => CodeConst.Printf.sprintf1 " functions %s" (CodeConst.String.concat " " (map to_string l))));

fun of_semi_typa to_string = (fn (n, v) => (if null v then to_string n else of_semi_typ to_string (Typ_apply (Typ_base n, map Typ_base v))));

fun of_type_synonym to_string uu = (fn Type_synonym (n, l) => CodeConst.Printf.sprintf2 "type_synonym %s = \"%s\"" (of_semi_typa to_string n) (of_semi_typ to_string l));

fun of_abbreviation to_string uu = (fn Abbreviation e => CodeConst.Printf.sprintf1 "abbreviation \"%s\"" (of_semi_terma to_string e));

fun of_overloading to_string uu =
  (fn Overloading (n_c, e_c, n, e) => CodeConst.Printf.sprintf4 "overloading %s \092<equiv> \"%s\"\nbegin\n  definition %s : \"%s\"\nend" (to_string n_c) (of_semi_terma to_string e_c) (to_string n) (of_semi_terma to_string e));

fun of_hide_const to_string uu = (fn Hide_const (b, l) => CodeConst.Printf.sprintf2 "hide_const %s%s" (if b then "(open) " else "") (CodeConst.String.concat " " (map to_string l)));

fun of_definition to_string to_nat uu =
  (fn a => (case a of Definitiona e => CodeConst.Printf.sprintf1 "definition \"%s\"" (of_semi_terma to_string e)
             | Definition_where1 (name, (abbrev, prio), e) => CodeConst.Printf.sprintf4 "definition %s (\"(1%s)\" %d)\n  where \"%s\"" (to_string name) (of_semi_terma to_string abbrev) (to_nat prio) (of_semi_terma to_string e)
             | Definition_where2 (name, abbrev, e) => CodeConst.Printf.sprintf3 "definition %s (\"%s\")\n  where \"%s\"" (to_string name) (of_semi_terma to_string abbrev) (of_semi_terma to_string e)));

fun of_text_raw to_string uu = (fn Text_raw s => CodeConst.Printf.sprintf1 "text_raw \092<open>%s\092<close>" (to_string s));

fun of_datatype to_string uu =
  (fn a => (case a of Datatypea (_, []) => ""
             | Datatypea (x, d :: ds) =>
               let
                 val of_datatype =
                   (fn typea => fn (n, l) =>
                     CodeConst.Printf.sprintf3 "%s %s = %s" typea (of_semi_typa to_string n)
                       (CodeConst.String.concat "\n                        | "
                         (map (fn (na, la) => CodeConst.Printf.sprintf2 "%s %s" (to_string na) (CodeConst.String.concat " " (map (fn xa => CodeConst.Printf.sprintf1 "\"%s\"" (of_semi_typ to_string xa)) la))) l)));
               in
                 CodeConst.Printf.sprintf2 "%s%s"
                   (of_datatype (case x of Datatype_new => "datatype" | Datatype_old => "old_datatype" | Datatype_old_atomic => "atomic_old_datatype" | Datatype_old_atomic_sub => "sub_atomic_old_datatype") d)
                   (CodeConst.String.concat "" (map (of_datatype "\nand") ds))
               end));

fun of_semi_thm_attribute_l to_string l = CodeConst.String.concat "\n                            " (map (of_semi_thm_attribute to_string) l);

fun of_lemmas to_string uu =
  (fn a => (case a of Lemmas_simp_thm (simp, s, l) =>
                     CodeConst.Printf.sprintf3 "lemmas%s%s = %s" (if is_empty s then "" else CodeConst.Printf.sprintf1 " %s" (to_string s)) (if simp then "[simp,code_unfold]" else "") (of_semi_thm_attribute_l to_string l)
             | Lemmas_simp_thms (s, l) =>
               CodeConst.Printf.sprintf2 "lemmas%s [simp,code_unfold] = %s" (if is_empty s then "" else CodeConst.Printf.sprintf1 " %s" (to_string s)) (CodeConst.String.concat "\n                            " (map to_string l))));

fun of_consts to_string uu = (fn Consts (n, ty, symb) => CodeConst.Printf.sprintf4 "consts %s :: \"%s\" (\"%s %s\")" (to_string n) (of_semi_typ to_string ty) (to_string consts_value) (to_string symb));

fun of_semi_val_fun x = (fn a => (case a of Sval => "val" | Sfun => "fun")) x;

fun of_semi_term to_string e = let
                                 val SML_top l = e;
                               in
                                 CodeConst.String.concat " " (mapa (of_semi_term_1 to_string) l)
                               end
and of_semi_term_0 to_string e =
  (case e of SML_string s => CodeConst.Printf.sprintf1 "\"%s\"" (to_string (escape_sml s)) | SML_rewrite (e1, symb, e2) => CodeConst.Printf.sprintf3 "%s %s %s" (of_semi_term_0 to_string e1) (to_string symb) (of_semi_term_0 to_string e2)
    | SML_basic l => CodeConst.Printf.sprintf1 "%s" (CodeConst.String.concat " " (map to_string l))
    | SML_binop (e1, s, e2) => CodeConst.Printf.sprintf3 "%s %s %s" (of_semi_term_0 to_string e1) (of_semi_term_0 to_string (SML_basic [s])) (of_semi_term_0 to_string e2)
    | SML_annot (ea, s) => CodeConst.Printf.sprintf2 "(%s:%s)" (of_semi_term_0 to_string ea) (to_string s)
    | SML_function l => CodeConst.Printf.sprintf1 "(fn %s)" (CodeConst.String.concat "\n    | " (mapa (fn (s1, s2) => CodeConst.Printf.sprintf2 "%s => %s" (of_semi_term_0 to_string s1) (of_semi_term_0 to_string s2)) l))
    | SML_apply (ea, l) => CodeConst.Printf.sprintf2 "(%s %s)" (of_semi_term_0 to_string ea) (CodeConst.String.concat " " (mapa (fn x => CodeConst.Printf.sprintf1 "(%s)" (of_semi_term_0 to_string x)) l))
    | SML_paren (p_left, p_right, ea) => CodeConst.Printf.sprintf3 "%s%s%s" (to_string p_left) (of_semi_term_0 to_string ea) (to_string p_right)
    | SML_let (e1, e2) => CodeConst.Printf.sprintf2 "let %s in %s end" (of_semi_term to_string e1) (of_semi_term_0 to_string e2))
and of_semi_term_1 to_string e =
  (case e of SML_open s => CodeConst.Printf.sprintf1 "open %s" (to_string s)
    | SML_val_fun (val_fun, ea) => CodeConst.Printf.sprintf2 "%s%s" (case val_fun of NONE => "" | SOME val_funa => CodeConst.Printf.sprintf1 "%s " (of_semi_val_fun val_funa)) (of_semi_term_0 to_string ea));

fun of_setup to_string uu = (fn Setup e => CodeConst.Printf.sprintf1 "setup \092<open>%s\092<close>" (of_semi_term to_string e));

fun of_semi_command_state to_string to_nat =
  (fn Command_apply_end a => (case a of [] => "" | aa :: lista => CodeConst.Printf.sprintf1 "  apply_end(%s)\n" (CodeConst.String.concat ", " (map (of_semi_method to_string to_nat) (aa :: lista)))));

fun of_semi_command_proof to_string to_nat =
  let
    val thesis = "?thesis";
    val scope_thesis_gen =
      (fn proof => fn show => fn when =>
        CodeConst.Printf.sprintf3 "  proof - %s show %s%s\n" proof show
          (if null when then "" else CodeConst.Printf.sprintf1 " when %s" (CodeConst.String.concat " " (map (fn t => CodeConst.Printf.sprintf1 "\"%s\"" (of_semi_terma to_string t)) when))));
    val scope_thesis = (fn s => scope_thesis_gen s thesis []);
  in
    (fn a => (case a of Command_apply aa => (case aa of [] => "" | ab :: lista => CodeConst.Printf.sprintf1 "  apply(%s)\n" (CodeConst.String.concat ", " (map (of_semi_method to_string to_nat) (ab :: lista))))
               | Command_using l => CodeConst.Printf.sprintf1 "  using %s\n" (of_semi_thm_l to_string l) | Command_unfolding l => CodeConst.Printf.sprintf1 "  unfolding %s\n" (of_semi_thm_l to_string l)
               | Command_let (e_name, e_body) => scope_thesis (CodeConst.Printf.sprintf2 "let %s = \"%s\"" (of_semi_terma to_string e_name) (of_semi_terma to_string e_body))
               | Command_have (n, b, e, e_last) => scope_thesis (CodeConst.Printf.sprintf4 "have %s%s: \"%s\" %s" (to_string n) (if b then "[simp]" else "") (of_semi_terma to_string e) (of_semi_command_final to_string to_nat e_last))
               | Command_fix_let (l, l_let, o_show, _) =>
                 scope_thesis_gen
                   (CodeConst.Printf.sprintf2 "fix %s%s" (CodeConst.String.concat " " (map to_string l))
                     (CodeConst.String.concat "\n" (map (fn (e_name, e_body) => CodeConst.Printf.sprintf2 "          let %s = \"%s\"" (of_semi_terma to_string e_name) (of_semi_terma to_string e_body)) l_let)))
                   (case o_show of NONE => thesis | SOME (l_show, _) => CodeConst.Printf.sprintf1 "\"%s\"" (CodeConst.String.concat " \092<Longrightarrow> " (map (of_semi_terma to_string) l_show)))
                   (case o_show of NONE => [] | SOME (_, l_when) => l_when)))
  end;

fun of_lemma to_string to_nat uu =
  (fn a => (case a of Lemma (n, l_spec, l_apply, tactic_last) =>
                     CodeConst.Printf.sprintf4 "lemma %s : \"%s\"\n%s%s" (to_string n) (CodeConst.String.concat " \092<Longrightarrow> " (map (of_semi_terma to_string) l_spec))
                       (CodeConst.String.concat ""
                         (map (fn aa => (case aa of [] => "" | ab :: lista => CodeConst.Printf.sprintf1 "  apply(%s)\n" (CodeConst.String.concat ", " (map (of_semi_method to_string to_nat) (ab :: lista))))) l_apply))
                       (of_semi_command_final to_string to_nat tactic_last)
             | Lemma_assumes (n, l_spec, concl, l_apply, tactic_last) =>
               CodeConst.Printf.sprintf5 "lemma %s :%s\n%s%s%s" (to_string n)
                 (CodeConst.String.concat ""
                   (append (map (fn (na, (b, e)) =>
                                  CodeConst.Printf.sprintf2 "\nassumes %s\"%s\""
                                    (case (if b then (CodeConst.Printf.sprintf1 "%s[simp]" (to_string na), false) else (to_string na, is_empty na)) of (_, true) => "" | (nb, false) => CodeConst.Printf.sprintf1 "%s: " nb)
                                    (of_semi_terma to_string e))
                             l_spec)
                     [CodeConst.Printf.sprintf1 "\nshows \"%s\"" (of_semi_terma to_string concl)]))
                 (CodeConst.String.concat "" (map (of_semi_command_proof to_string to_nat) l_apply)) (of_semi_command_final to_string to_nat tactic_last)
                 (CodeConst.String.concat ""
                   (map (fn l_apply_e => CodeConst.Printf.sprintf1 "%s qed" (if null l_apply_e then "" else CodeConst.Printf.sprintf1 "\n%s" (CodeConst.String.concat "" (map (of_semi_command_state to_string to_nat) l_apply_e))))
                     (map_filter (fn aa => (case aa of Command_apply _ => NONE | Command_using _ => NONE | Command_unfolding _ => NONE | Command_let (_, _) => SOME [] | Command_have (_, _, _, _) => SOME []
                                             | Command_fix_let (_, _, _, ab) => SOME ab))
                       (rev l_apply))))));

fun of_text to_string uu = (fn Text s => CodeConst.Printf.sprintf1 "text \092<open>%s\092<close>" (to_string s));

fun of_thm to_string uu = (fn Thm thm => CodeConst.Printf.sprintf1 "thm %s" (of_semi_thm_attribute_l1 to_string thm));

fun of_ML to_string uu = (fn SMLa e => CodeConst.Printf.sprintf1 "ML \092<open>%s\092<close>" (of_semi_term to_string e));

fun of_semi_theory to_string to_nat env =
  (fn a => (case a of Theory_datatype aa => of_datatype to_string env aa | Theory_type_synonym aa => of_type_synonym to_string env aa | Theory_type_notation aa => of_type_notation to_string env aa
             | Theory_instantiation aa => of_instantiation to_string env aa | Theory_overloading aa => of_overloading to_string env aa | Theory_consts aa => of_consts to_string env aa
             | Theory_definition aa => of_definition to_string to_nat env aa | Theory_lemmas aa => of_lemmas to_string env aa | Theory_lemma aa => of_lemma to_string to_nat env aa
             | Theory_axiomatization aa => of_axiomatization to_string env aa | Theory_section aa => of_section to_string env aa | Theory_text aa => of_text to_string env aa | Theory_text_raw aa => of_text_raw to_string env aa
             | Theory_ML aa => of_ML to_string env aa | Theory_setup aa => of_setup to_string env aa | Theory_thm aa => of_thm to_string env aa | Theory_interpretation aa => of_interpretation to_string to_nat env aa
             | Theory_hide_const aa => of_hide_const to_string env aa | Theory_abbreviation aa => of_abbreviation to_string env aa | Theory_code_reflect aa => of_code_reflect to_string env aa));

fun of_e_n_v_semi_theory to_string to_nat env =
  (fn a => (case a of Theory_datatype datatypea => of_semi_theory to_string to_nat env (Theory_datatype datatypea) | Theory_type_synonym type_synonym => of_semi_theory to_string to_nat env (Theory_type_synonym type_synonym)
             | Theory_type_notation type_notation => of_semi_theory to_string to_nat env (Theory_type_notation type_notation)
             | Theory_instantiation instantiation => of_semi_theory to_string to_nat env (Theory_instantiation instantiation) | Theory_overloading overloading => of_semi_theory to_string to_nat env (Theory_overloading overloading)
             | Theory_consts consts => of_semi_theory to_string to_nat env (Theory_consts consts) | Theory_definition definition => of_semi_theory to_string to_nat env (Theory_definition definition)
             | Theory_lemmas lemmas => of_semi_theory to_string to_nat env (Theory_lemmas lemmas) | Theory_lemma lemma => of_semi_theory to_string to_nat env (Theory_lemma lemma)
             | Theory_axiomatization axiomatization => of_semi_theory to_string to_nat env (Theory_axiomatization axiomatization) | Theory_section aa => of_e_n_v_section to_string env aa
             | Theory_text text => of_semi_theory to_string to_nat env (Theory_text text) | Theory_text_raw text_raw => of_semi_theory to_string to_nat env (Theory_text_raw text_raw)
             | Theory_ML ml => of_semi_theory to_string to_nat env (Theory_ML ml) | Theory_setup setup => of_semi_theory to_string to_nat env (Theory_setup setup) | Theory_thm thm => of_semi_theory to_string to_nat env (Theory_thm thm)
             | Theory_interpretation interpretation => of_semi_theory to_string to_nat env (Theory_interpretation interpretation) | Theory_hide_const hide_const => of_semi_theory to_string to_nat env (Theory_hide_const hide_const)
             | Theory_abbreviation abbreviation => of_semi_theory to_string to_nat env (Theory_abbreviation abbreviation) | Theory_code_reflect code_reflect => of_semi_theory to_string to_nat env (Theory_code_reflect code_reflect)));

fun holThyLocale_header (Semi_locale_ext (holThyLocale_name, holThyLocale_header, more)) = holThyLocale_header;

fun holThyLocale_name (Semi_locale_ext (holThyLocale_name, holThyLocale_header, more)) = holThyLocale_name;

fun string_concat_map s f l = CodeConst.String.concat s (map f l);

fun of_semi_theories0 to_string =
  (fn of_semi_theory => fn env => fn a =>
    (case a of Theories_one aa => of_semi_theory env aa
      | Theories_locale (data, l) =>
        CodeConst.Printf.sprintf3 "locale %s%s\nbegin\n%s\nend" (to_string (holThyLocale_name data))
          (case holThyLocale_header data of [] => ""
            | aa :: lista =>
              CodeConst.Printf.sprintf1 " =\n%s"
                (string_concat_map "\n"
                  (fn (l_fix, o_assum) =>
                    CodeConst.Printf.sprintf2 "%s%s" (string_concat_map "\n" (fn (e, ty) => CodeConst.Printf.sprintf2 "fixes \"%s\" :: \"%s\"" (of_semi_terma to_string e) (of_semi_typ to_string ty)) l_fix)
                      (case o_assum of NONE => "" | SOME (name, e) => CodeConst.Printf.sprintf2 "\nassumes %s: \"%s\"" (to_string name) (of_semi_terma to_string e)))
                  (aa :: lista)))
          (string_concat_map "\n\n" (string_concat_map "\n\n" (of_semi_theory env)) l)));

fun of_e_n_v_semi_theories to_string to_nat = of_semi_theories0 to_string (of_e_n_v_semi_theory to_string to_nat);

fun of_boot_generation_syntax uu = (fn Boot_generation_syntax mode => CodeConst.Printf.sprintf1 "generation_syntax [ shallow%s ]" let
              val f = CodeConst.Printf.sprintf1 " (generation_semantics [ %s ])";
            in
              (case mode of Gen_only_design => f "design" | Gen_only_analysis => f "analysis" | Gen_default => "")
            end);

fun of_ocl_def_basea to_string =
  (fn a => (case a of OclDefInteger aa => to_string aa | OclDefReal (i1, i2) => CodeConst.Printf.sprintf2 "%s.%s" (to_string i1) (to_string i2) | OclDefString s => CodeConst.Printf.sprintf1 "\"%s\"" (to_string s)));

fun to_oid to_nat = (fn Oid a => to_nat a);

fun of_ocl_data_shallowa to_string to_nat e =
  (case e of ShallB_term a => of_ocl_def_basea to_string a | ShallB_str a => to_string a | ShallB_self s => CodeConst.Printf.sprintf1 "self %d" (to_oid to_nat s)
    | ShallB_list l => CodeConst.Printf.sprintf1 "[ %s ]" (CodeConst.String.concat ", " (mapa (of_ocl_data_shallowa to_string to_nat) l)));

fun of_ocl_list_attra to_string f e =
  (case e of OclAttrNoCast a => f a | OclAttrCast (ty, OclAttrNoCast x, _) => CodeConst.Printf.sprintf2 "(%s :: %s)" (f x) (to_string ty)
    | OclAttrCast (ty, OclAttrCast (abr_stringa, ocl_list_attr, aa), _) => CodeConst.Printf.sprintf2 "%s \092<rightarrow> oclAsType( %s )" (of_ocl_list_attra to_string f (OclAttrCast (abr_stringa, ocl_list_attr, aa))) (to_string ty));

fun of_ocl_instance_singlea to_string to_nat ocli =
  let
    val a = (case inst_namea ocli of NONE => let
                                               val SOME ty = inst_tya ocli;
                                             in
                                               ("(", CodeConst.Printf.sprintf1 " :: %s)" (to_string ty))
                                             end
              | SOME s => (CodeConst.Printf.sprintf2 "%s%s = " (to_string s) (case inst_tya ocli of NONE => "" | SOME ty => CodeConst.Printf.sprintf1 " :: %s" (to_string ty)), ""));
    val (s_left, aa) = a;
  in
    CodeConst.Printf.sprintf3 "%s%s%s" s_left
      (of_ocl_list_attra to_string
        (fn l => CodeConst.Printf.sprintf2 "[ %s%s ]" (case inst_attr_with ocli of NONE => "" | SOME s => CodeConst.Printf.sprintf1 "%s with_only " (to_string s))
                   (CodeConst.String.concat ", "
                     (map (fn (pre_post, (attr, v)) =>
                            CodeConst.Printf.sprintf3 "%s\"%s\" = %s" (case pre_post of NONE => "" | SOME (s1, s2) => CodeConst.Printf.sprintf2 "(\"%s\", \"%s\") |= " (to_string s1) (to_string s2)) (to_string attr)
                              (of_ocl_data_shallowa to_string to_nat v))
                       l)))
        (inst_attr ocli))
      aa
  end;

fun of_ocl_def_state_corea to_string to_nat l = CodeConst.String.concat ", " (map (fn a => (case a of OclDefCoreAdd aa => of_ocl_instance_singlea to_string to_nat aa | OclDefCoreBinding aa => to_string aa)) l);

fun of_ocl_def_pp_corea to_string to_nat = (fn a => (case a of OclDefPPCoreAdd l => CodeConst.Printf.sprintf1 "[ %s ]" (of_ocl_def_state_corea to_string to_nat l) | OclDefPPCoreBinding aa => to_string aa));

fun of_ocl_def_transitiona to_string to_nat uu floor =
  (fn OclDefPP (n, s_pre, s_post) =>
    CodeConst.Printf.sprintf4 "Transition%s %s%s%s" floor (case n of NONE => "" | SOME na => CodeConst.Printf.sprintf1 "%s = " (to_string na)) (of_ocl_def_pp_corea to_string to_nat s_pre)
      (case s_post of NONE => "" | SOME s_posta => CodeConst.Printf.sprintf1 " %s" (of_ocl_def_pp_corea to_string to_nat s_posta)));

fun of_ocl_def_statea to_string to_nat uu floor = (fn OclDefSt (n, l) => CodeConst.Printf.sprintf3 "State%s %s = [ %s ]" floor (to_string n) (of_ocl_def_state_corea to_string to_nat l));

fun of_ocl_instancea to_string to_nat uu = (fn OclInstance l => CodeConst.Printf.sprintf1 "Instance %s" (CodeConst.String.concat "\n     and " (map (of_ocl_instance_singlea to_string to_nat) l)));

fun of_ocl_generica to_string uu = (fn OclGeneric s => CodeConst.Printf.sprintf1 "meta_command \092<open>%s\092<close>" (to_string s));

fun concatWith to_string l = (if null l then id else CodeConst.Printf.sprintf2 "(%s. (%s))" (to_string (String_concatWith (SS_base (ST " "), SS_base (ST "\092<lambda>") :: rev l))));

fun of_ctxt2_term_aux to_string l e =
  (case e of T_pure (pure, a) => (case a of NONE => concatWith to_string l (of_pure_terma to_string true [] pure) | SOME aa => to_string aa) | T_to_be_parsed (_, s) => concatWith to_string l (to_string s)
    | T_lambda (s, a) => of_ctxt2_term_aux to_string (s :: l) a);

fun of_ctxt2_term to_string = of_ctxt2_term_aux to_string [];

fun of_ocl_ctxta to_string uu floor ctxt =
  let
    val f_inv = (fn T_inv (b, OclProp_ctxt (n, s)) => CodeConst.Printf.sprintf3 "  %sInv %s : \"%s\"" (if b then "Existential" else "") (case n of NONE => "" | SOME a => to_string a) (of_ctxt2_term to_string s));
  in
    CodeConst.Printf.sprintf4 "Context%s %s%s %s" floor (case ctxt_param ctxt of [] => "" | a :: lista => CodeConst.Printf.sprintf1 "%s : " (CodeConst.String.concat ", " (map to_string (a :: lista))))
      (to_string (ty_obj_to_string (ctxt_ty ctxt)))
      (CodeConst.String.concat "\n"
        (map (fn a => (case a of Ctxt_pp ctxta =>
                                CodeConst.Printf.sprintf4 ":: %s (%s) %s\n%s" (to_string (ctxt_fun_name ctxta))
                                  (CodeConst.String.concat ", " (map (fn (s, ty) => CodeConst.Printf.sprintf2 "%s : %s" (to_string s) (to_string (str_of_ty ty))) (ctxt_fun_ty_arg ctxta)))
                                  (case ctxt_fun_ty_out ctxta of NONE => "" | SOME ty => CodeConst.Printf.sprintf1 ": %s" (to_string (str_of_ty ty)))
                                  (CodeConst.String.concat "\n"
                                    (map (fn aa => (case aa of T_pp (pref, OclProp_ctxt (n, s)) =>
                                                              CodeConst.Printf.sprintf3 "  %s %s: \"%s\"" (case pref of OclCtxtPre => "Pre" | OclCtxtPost => "Post") (case n of NONE => "" | SOME ab => to_string ab)
                                                                (of_ctxt2_term to_string s)
                                                     | T_invariant ab => f_inv ab))
                                      (ctxt_expr ctxta)))
                        | Ctxt_inv aa => f_inv aa))
          (ctxt_clause ctxt)))
  end;

fun of_floora x = (fn a => (case a of Floor1 => "" | Floor2 => "[shallow]" | Floor3 => "[shallow_shallow]")) x;

fun of_all_meta_embeddinga to_string to_nat env =
  (fn a => (case a of META_ctxt (floor, aa) => of_ocl_ctxta to_string env (of_floora floor) aa | META_instance aa => of_ocl_instancea to_string to_nat env aa
             | META_def_state (floor, aa) => of_ocl_def_statea to_string to_nat env (of_floora floor) aa | META_def_transition (floor, aa) => of_ocl_def_transitiona to_string to_nat env (of_floora floor) aa
             | META_generic aa => of_ocl_generica to_string env aa));

fun sml_escape x =
  replace_integersa
    (fn xa => (if xa = (10 : IntInf.int) then SS_base (ST "\092n")
                else (if xa = (5 : IntInf.int) then SS_base (ST "\092005") else (if xa = (6 : IntInf.int) then SS_base (ST "\092006") else (if xa = (127 : IntInf.int) then SS_base (ST "\092127") else SS_base (STa [xa]))))))
    x;

fun of_string_b_a_s_e a b = (fn x => b (flattena [SS_base (ST "(META.ST \""), sml_escape (to_String x), SS_base (ST "\")")]));

fun rec_ocl_data_shallow f1 f2 f3 f4 (ShallB_term x1) = f1 x1
  | rec_ocl_data_shallow f1 f2 f3 f4 (ShallB_str x2) = f2 x2
  | rec_ocl_data_shallow f1 f2 f3 f4 (ShallB_self x3) = f3 x3
  | rec_ocl_data_shallow f1 f2 f3 f4 (ShallB_list x4) = f4 (mapa (fn ocl_data_shallow => (ocl_data_shallow, rec_ocl_data_shallow f1 f2 f3 f4 ocl_data_shallow)) x4);

fun rec_ocl_def_base f1 f2 f3 (OclDefInteger x1) = f1 x1
  | rec_ocl_def_base f1 f2 f3 (OclDefReal x2) = f2 x2
  | rec_ocl_def_base f1 f2 f3 (OclDefString x3) = f3 x3;

fun of_pair of_Pair a b f1 f2 = (fn (c, d) => ap2 a (b of_Pair) f1 f2 c d);

fun of_ocl_def_base of_string of_Pair a b =
  rec_ocl_def_base (ap1 a (b (SS_base (ST "OclDefInteger"))) (of_string a b)) (ap1 a (b (SS_base (ST "OclDefReal"))) (of_pair of_Pair a b (of_string a b) (of_string a b))) (ap1 a (b (SS_base (ST "OclDefString"))) (of_string a b));

fun rec_internal_oid f (Oid x) = f x;

fun of_internal_oid of_nat a b = rec_internal_oid (ap1 a (b (SS_base (ST "Oid"))) (of_nat a b));

fun of_list of_Nil of_Cons a b f = (rec_list (b of_Nil) o co1 k) (ar2 a (b of_Cons) f);

fun of_ocl_data_shallow of_string of_nat of_Pair of_Nil of_Cons a b =
  rec_ocl_data_shallow (ap1 a (b (SS_base (ST "ShallB_term"))) (of_ocl_def_base of_string of_Pair a b)) (ap1 a (b (SS_base (ST "ShallB_str"))) (of_string a b)) (ap1 a (b (SS_base (ST "ShallB_self"))) (of_internal_oid of_nat a b))
    (ap1 a (b (SS_base (ST "ShallB_list"))) (of_list of_Nil of_Cons a b snd));

fun ocl_instance_single_rec0 f ocl = f (inst_namea ocl) (inst_tya ocl) (inst_attr_with ocl) (inst_attr ocl);

fun moreh (Ocl_instance_single_ext (inst_name, inst_ty, inst_attr_with, inst_attr, more)) = more;

fun ocl_instance_single_rec f ocl = ocl_instance_single_rec0 f ocl (moreh ocl);

fun rec_ocl_list_attr f1 f2 (OclAttrNoCast x1) = f1 x1
  | rec_ocl_list_attr f1 f2 (OclAttrCast (x21, x22, x23)) = f2 x21 x22 x23 (rec_ocl_list_attr f1 f2 x22);

fun of_ocl_list_attr of_string a b f = co4 (fn f1 => rec_ocl_list_attr (ap1 a (b (SS_base (ST "OclAttrNoCast"))) f) (fn s => fn _ => fn aa => fn reca => f1 s reca aa)) (ap3 a) (b (SS_base (ST "OclAttrCast"))) (of_string a b) id f;

fun rec_option f1 f2 NONE = f1
  | rec_option f1 f2 (SOME x2) = f2 x2;

fun of_option of_None of_Some a b f = rec_option (b of_None) (ap1 a (b of_Some) f);

fun of_ocl_instance_single ext of_string of_nat of_Pair of_Nil of_Cons of_None of_Some a b f =
  ocl_instance_single_rec
    (ap5 a (b (ext (SS_base (ST "ocl_instance_single_ext")))) (of_option of_None of_Some a b (of_string a b)) (of_option of_None of_Some a b (of_string a b)) (of_option of_None of_Some a b (of_string a b))
      (of_ocl_list_attr of_string a b
        (of_list of_Nil of_Cons a b
          (of_pair of_Pair a b (of_option of_None of_Some a b (of_pair of_Pair a b (of_string a b) (of_string a b))) (of_pair of_Pair a b (of_string a b) (of_ocl_data_shallow of_string of_nat of_Pair of_Nil of_Cons a b)))))
      (f a b));

fun rec_ocl_def_state_core f1 f2 (OclDefCoreAdd x1) = f1 x1
  | rec_ocl_def_state_core f1 f2 (OclDefCoreBinding x2) = f2 x2;

fun of_ocl_def_state_core ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b f =
  rec_ocl_def_state_core (ap1 a (b (SS_base (ST "OclDefCoreAdd"))) (of_ocl_instance_single ext of_string of_nat of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit))) (ap1 a (b (SS_base (ST "OclDefCoreBinding"))) f);

fun rec_generation_semantics_ocl f1 f2 f3 Gen_only_design = f1
  | rec_generation_semantics_ocl f1 f2 f3 Gen_only_analysis = f2
  | rec_generation_semantics_ocl f1 f2 f3 Gen_default = f3;

fun of_generation_semantics_ocl a b = rec_generation_semantics_ocl (b (SS_base (ST "Gen_only_design"))) (b (SS_base (ST "Gen_only_analysis"))) (b (SS_base (ST "Gen_default")));

fun rec_internal_oids f (Oids (x1, x2, x3)) = f x1 x2 x3;

fun of_internal_oids of_nat a b = rec_internal_oids (ap3 a (b (SS_base (ST "Oids"))) (of_nat a b) (of_nat a b) (of_nat a b));

fun rec_generation_lemma_mode f1 f2 Gen_sorry = f1
  | rec_generation_lemma_mode f1 f2 Gen_no_dirty = f2;

fun of_generation_lemma_mode a b = rec_generation_lemma_mode (b (SS_base (ST "Gen_sorry"))) (b (SS_base (ST "Gen_no_dirty")));

fun rec_all_meta_embedding f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (META_enum x1) = f1 x1
  | rec_all_meta_embedding f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (META_class_raw (x21, x22)) = f2 x21 x22
  | rec_all_meta_embedding f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (META_association x3) = f3 x3
  | rec_all_meta_embedding f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (META_ass_class (x41, x42)) = f4 x41 x42
  | rec_all_meta_embedding f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (META_ctxt (x51, x52)) = f5 x51 x52
  | rec_all_meta_embedding f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (META_haskell x6) = f6 x6
  | rec_all_meta_embedding f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (META_class_synonym x7) = f7 x7
  | rec_all_meta_embedding f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (META_instance x8) = f8 x8
  | rec_all_meta_embedding f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (META_def_base_l x9) = f9 x9
  | rec_all_meta_embedding f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (META_def_state (x101, x102)) = f10 x101 x102
  | rec_all_meta_embedding f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (META_def_transition (x111, x112)) = f11 x111 x112
  | rec_all_meta_embedding f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (META_class_tree x12) = f12 x12
  | rec_all_meta_embedding f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (META_flush_all x13) = f13 x13
  | rec_all_meta_embedding f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (META_generic x14) = f14 x14;

fun rec_ocl_def_transition f (OclDefPP (x1, x2, x3)) = f x1 x2 x3;

fun rec_ocl_def_pp_core f1 f2 (OclDefPPCoreAdd x1) = f1 x1
  | rec_ocl_def_pp_core f1 f2 (OclDefPPCoreBinding x2) = f2 x2;

fun of_ocl_def_pp_core ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_def_pp_core (ap1 a (b (SS_base (ST "OclDefPPCoreAdd"))) (of_list of_Nil of_Cons a b (of_ocl_def_state_core ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b (of_string a b))))
    (ap1 a (b (SS_base (ST "OclDefPPCoreBinding"))) (of_string a b));

fun of_ocl_def_transition ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_def_transition
    (ap3 a (b (SS_base (ST "OclDefPP"))) (of_option of_None of_Some a b (of_string a b)) (of_ocl_def_pp_core ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b)
      (of_option of_None of_Some a b (of_ocl_def_pp_core ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b)));

fun rec_ocl_def_base_l f (OclDefBase x) = f x;

fun of_ocl_def_base_l of_string of_Pair of_Nil of_Cons a b = rec_ocl_def_base_l (ap1 a (b (SS_base (ST "OclDefBase"))) (of_list of_Nil of_Cons a b (of_ocl_def_base of_string of_Pair a b)));

fun rec_ocl_class_tree f (OclClassTree (x1, x2)) = f x1 x2;

fun of_ocl_class_tree of_nat a b = rec_ocl_class_tree (ap2 a (b (SS_base (ST "OclClassTree"))) (of_nat a b) (of_nat a b));

fun rec_ocl_def_state f (OclDefSt (x1, x2)) = f x1 x2;

fun of_ocl_def_state ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_def_state (ap2 a (b (SS_base (ST "OclDefSt"))) (of_string a b) (of_list of_Nil of_Cons a b (of_ocl_def_state_core ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b (of_string a b))));

fun rec_ocl_instance f (OclInstance x) = f x;

fun of_ocl_instance ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_instance (ap1 a (b (SS_base (ST "OclInstance"))) (of_list of_Nil of_Cons a b (of_ocl_instance_single ext of_string of_nat of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit))));

fun rec_ocl_class_synonym f (OclClassSynonym (x1, x2)) = f x1 x2;

fun rec_ocl_multiplicity_single f1 f2 f3 (Mult_nat x1) = f1 x1
  | rec_ocl_multiplicity_single f1 f2 f3 Mult_star = f2
  | rec_ocl_multiplicity_single f1 f2 f3 Mult_infinity = f3;

fun of_ocl_multiplicity_single of_nat a b = rec_ocl_multiplicity_single (ap1 a (b (SS_base (ST "Mult_nat"))) (of_nat a b)) (b (SS_base (ST "Mult_star"))) (b (SS_base (ST "Mult_infinity")));

fun rec_ocl_collection f1 f2 f3 f4 f5 f6 f7 f8 f9 Set = f1
  | rec_ocl_collection f1 f2 f3 f4 f5 f6 f7 f8 f9 Sequence = f2
  | rec_ocl_collection f1 f2 f3 f4 f5 f6 f7 f8 f9 Ordered0 = f3
  | rec_ocl_collection f1 f2 f3 f4 f5 f6 f7 f8 f9 Subsets0 = f4
  | rec_ocl_collection f1 f2 f3 f4 f5 f6 f7 f8 f9 Union0 = f5
  | rec_ocl_collection f1 f2 f3 f4 f5 f6 f7 f8 f9 Redefines0 = f6
  | rec_ocl_collection f1 f2 f3 f4 f5 f6 f7 f8 f9 Derived0 = f7
  | rec_ocl_collection f1 f2 f3 f4 f5 f6 f7 f8 f9 Qualifier0 = f8
  | rec_ocl_collection f1 f2 f3 f4 f5 f6 f7 f8 f9 Nonunique0 = f9;

fun of_ocl_collection b =
  rec_ocl_collection (b (SS_base (ST "Set"))) (b (SS_base (ST "Sequence"))) (b (SS_base (ST "Ordered0"))) (b (SS_base (ST "Subsets0"))) (b (SS_base (ST "Union0"))) (b (SS_base (ST "Redefines0"))) (b (SS_base (ST "Derived0")))
    (b (SS_base (ST "Qualifier0"))) (b (SS_base (ST "Nonunique0")));

fun ocl_multiplicity_rec0 f ocl = f (tyMult ocl) (tyRole ocl) (tyCollect ocl);

fun mored (Ocl_multiplicity_ext (tyMult, tyRole, tyCollect, more)) = more;

fun ocl_multiplicity_rec f ocl = ocl_multiplicity_rec0 f ocl (mored ocl);

fun of_ocl_multiplicity ext of_string of_nat of_Pair of_Nil of_Cons of_None of_Some a b f =
  ocl_multiplicity_rec
    (ap4 a (b (ext (SS_base (ST "ocl_multiplicity_ext")))) (of_list of_Nil of_Cons a b (of_pair of_Pair a b (of_ocl_multiplicity_single of_nat a b) (of_option of_None of_Some a b (of_ocl_multiplicity_single of_nat a b))))
      (of_option of_None of_Some a b (of_string a b)) (of_list of_Nil of_Cons a b (of_ocl_collection b)) (f a b));

fun rec_ocl_ty_obj_core f1 f2 (OclTyCore_pre x1) = f1 x1
  | rec_ocl_ty_obj_core f1 f2 (OclTyCore x2) = f2 x2;

fun ocl_ty_class_node_rec0 f ocl = f (tyObjN_ass_switch ocl) (tyObjN_role_multip ocl) (tyObjN_role_ty ocl);

fun moref (Ocl_ty_class_node_ext (tyObjN_ass_switch, tyObjN_role_multip, tyObjN_role_ty, more)) = more;

fun ocl_ty_class_node_rec f ocl = ocl_ty_class_node_rec0 f ocl (moref ocl);

fun of_ocl_ty_class_node ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b f =
  ocl_ty_class_node_rec (ap4 a (b (ext (SS_base (ST "ocl_ty_class_node_ext")))) (of_nat a b) (of_ocl_multiplicity ext of_string of_nat of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit)) (of_string a b) (f a b));

fun ocl_ty_class_rec0 f ocl = f (tyObj_name ocl) (tyObj_ass_id ocl) (tyObj_ass_arity ocl) (tyObj_from ocl) (tyObj_to ocl);

fun morea (Ocl_ty_class_ext (tyObj_name, tyObj_ass_id, tyObj_ass_arity, tyObj_from, tyObj_to, more)) = more;

fun ocl_ty_class_rec f ocl = ocl_ty_class_rec0 f ocl (morea ocl);

fun of_ocl_ty_class ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b f =
  ocl_ty_class_rec
    (ap6 a (b (ext (SS_base (ST "ocl_ty_class_ext")))) (of_string a b) (of_nat a b) (of_nat a b) (of_ocl_ty_class_node ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit))
      (of_ocl_ty_class_node ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit)) (f a b));

fun of_ocl_ty_obj_core ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_ty_obj_core (ap1 a (b (SS_base (ST "OclTyCore_pre"))) (of_string a b)) (ap1 a (b (SS_base (ST "OclTyCore"))) (of_ocl_ty_class ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit)));

fun rec_ocl_ty_obj f (OclTyObj (x1, x2)) = f x1 x2;

fun of_ocl_ty_obj ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_ty_obj
    (ap2 a (b (SS_base (ST "OclTyObj"))) (of_ocl_ty_obj_core ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b)
      (of_list of_Nil of_Cons a b (of_list of_Nil of_Cons a b (of_ocl_ty_obj_core ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b))));

fun rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OclTy_base_void = f1
  | rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OclTy_base_boolean = f2
  | rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OclTy_base_integer = f3
  | rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OclTy_base_unlimitednatural = f4
  | rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OclTy_base_real = f5
  | rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 OclTy_base_string = f6
  | rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (OclTy_object x7) = f7 x7
  | rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (OclTy_collection (x81, x82)) = f8 x81 x82 (rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 x82)
  | rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (OclTy_pair (x91, x92)) = f9 x91 x92 (rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 x91) (rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 x92)
  | rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (OclTy_binding x10) = f10 (map_prod id (fn ocl_ty => (ocl_ty, rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 ocl_ty)) x10)
  | rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (OclTy_arrow (x111, x112)) = f11 x111 x112 (rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 x111) (rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 x112)
  | rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (OclTy_class_syn x12) = f12 x12
  | rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (OclTy_enum x13) = f13 x13
  | rec_ocl_ty f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 (OclTy_raw x14) = f14 x14;

fun of_ocl_ty ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_ty (b (SS_base (ST "OclTy_base_void"))) (b (SS_base (ST "OclTy_base_boolean"))) (b (SS_base (ST "OclTy_base_integer"))) (b (SS_base (ST "OclTy_base_unlimitednatural"))) (b (SS_base (ST "OclTy_base_real")))
    (b (SS_base (ST "OclTy_base_string"))) (ap1 a (b (SS_base (ST "OclTy_object"))) (of_ocl_ty_obj ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b))
    (k o ar2 a (b (SS_base (ST "OclTy_collection"))) (of_ocl_multiplicity ext of_string of_nat of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit))) (fn _ => fn _ => ar2 a (b (SS_base (ST "OclTy_pair"))) id)
    (ap1 a (b (SS_base (ST "OclTy_binding"))) (of_pair of_Pair a b (of_option of_None of_Some a b (of_string a b)) id) o map_prod id snd) (fn _ => fn _ => ar2 a (b (SS_base (ST "OclTy_arrow"))) id)
    (ap1 a (b (SS_base (ST "OclTy_class_syn"))) (of_string a b)) (ap1 a (b (SS_base (ST "OclTy_enum"))) (of_string a b)) (ap1 a (b (SS_base (ST "OclTy_raw"))) (of_string a b));

fun of_ocl_class_synonym ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_class_synonym (ap2 a (b (SS_base (ST "OclClassSynonym"))) (of_string a b) (of_ocl_ty ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b));

fun rec_ocl_association_relation f (OclAssRel x) = f x;

fun of_ocl_association_relation ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_association_relation
    (ap1 a (b (SS_base (ST "OclAssRel")))
      (of_list of_Nil of_Cons a b
        (of_pair of_Pair a b (of_ocl_ty_obj ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b) (of_ocl_multiplicity ext of_string of_nat of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit)))));

fun rec_ocl_association_type f1 f2 f3 f4 OclAssTy_native_attribute = f1
  | rec_ocl_association_type f1 f2 f3 f4 OclAssTy_association = f2
  | rec_ocl_association_type f1 f2 f3 f4 OclAssTy_composition = f3
  | rec_ocl_association_type f1 f2 f3 f4 OclAssTy_aggregation = f4;

fun of_ocl_association_type a b = rec_ocl_association_type (b (SS_base (ST "OclAssTy_native_attribute"))) (b (SS_base (ST "OclAssTy_association"))) (b (SS_base (ST "OclAssTy_composition"))) (b (SS_base (ST "OclAssTy_aggregation")));

fun ocl_association_rec0 f ocl = f (oclAss_type ocl) (oclAss_relationa ocl);

fun morec (Ocl_association_ext (oclAss_type, oclAss_relation, more)) = more;

fun ocl_association_rec f ocl = ocl_association_rec0 f ocl (morec ocl);

fun of_ocl_association ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b f =
  ocl_association_rec (ap3 a (b (ext (SS_base (ST "ocl_association_ext")))) (of_ocl_association_type a b) (of_ocl_association_relation ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b) (f a b));

fun rec_ocl_flush_all f OclFlushAll = f;

fun of_ocl_flush_all a b = rec_ocl_flush_all (b (SS_base (ST "OclFlushAll")));

fun rec_ocl_ctxt_clause f1 f2 (Ctxt_pp x1) = f1 x1
  | rec_ocl_ctxt_clause f1 f2 (Ctxt_inv x2) = f2 x2;

fun rec_ocl_ctxt_term_inv f (T_inv (x1, x2)) = f x1 x2;

fun rec_ocl_ctxt_term f1 f2 f3 (T_pure (x11, x12)) = f1 x11 x12
  | rec_ocl_ctxt_term f1 f2 f3 (T_to_be_parsed (x21, x22)) = f2 x21 x22
  | rec_ocl_ctxt_term f1 f2 f3 (T_lambda (x31, x32)) = f3 x31 x32 (rec_ocl_ctxt_term f1 f2 f3 x32);

fun of_pure_indexname of_string of_nat of_Pair a b = of_pair of_Pair a b (of_string a b) (of_nat a b);

fun of_pure_class of_string = of_string;

fun of_pure_sort of_string of_Nil of_Cons a b = of_list of_Nil of_Cons a b (of_pure_class of_string a b);

fun rec_typ f1 f2 f3 (Typeb (x11, x12)) = f1 x11 (mapa (fn typ => (typ, rec_typ f1 f2 f3 typ)) x12)
  | rec_typ f1 f2 f3 (TFree (x21, x22)) = f2 x21 x22
  | rec_typ f1 f2 f3 (TVara (x31, x32)) = f3 x31 x32;

fun of_pure_typ of_string of_nat of_Pair of_Nil of_Cons a b =
  rec_typ (ap2 a (b (SS_base (ST "Type"))) (of_string a b) (of_list of_Nil of_Cons a b snd)) (ap2 a (b (SS_base (ST "TFree"))) (of_string a b) (of_pure_sort of_string of_Nil of_Cons a b))
    (ap2 a (b (SS_base (ST "TVar"))) (of_pure_indexname of_string of_nat of_Pair a b) (of_pure_sort of_string of_Nil of_Cons a b));

fun rec_term f1 f2 f3 f4 f5 f6 (Consta (x11, x12)) = f1 x11 x12
  | rec_term f1 f2 f3 f4 f5 f6 (Free (x21, x22)) = f2 x21 x22
  | rec_term f1 f2 f3 f4 f5 f6 (Var (x31, x32)) = f3 x31 x32
  | rec_term f1 f2 f3 f4 f5 f6 (Bound x4) = f4 x4
  | rec_term f1 f2 f3 f4 f5 f6 (Absa (x51, x52, x53)) = f5 x51 x52 x53 (rec_term f1 f2 f3 f4 f5 f6 x53)
  | rec_term f1 f2 f3 f4 f5 f6 (Appa (x61, x62)) = f6 x61 x62 (rec_term f1 f2 f3 f4 f5 f6 x61) (rec_term f1 f2 f3 f4 f5 f6 x62);

fun of_pure_term of_string of_nat of_Pair of_Nil of_Cons a b =
  rec_term (ap2 a (b (SS_base (ST "Const"))) (of_string a b) (of_pure_typ of_string of_nat of_Pair of_Nil of_Cons a b)) (ap2 a (b (SS_base (ST "Free"))) (of_string a b) (of_pure_typ of_string of_nat of_Pair of_Nil of_Cons a b))
    (ap2 a (b (SS_base (ST "Var"))) (of_pure_indexname of_string of_nat of_Pair a b) (of_pure_typ of_string of_nat of_Pair of_Nil of_Cons a b)) (ap1 a (b (SS_base (ST "Bound"))) (of_nat a b))
    (co2 k (ar3 a (b (SS_base (ST "Abs"))) (of_string a b) (of_pure_typ of_string of_nat of_Pair of_Nil of_Cons a b))) (fn _ => fn _ => ar2 a (b (SS_base (ST "App"))) id);

fun of_ocl_ctxt_term of_string of_nat of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_ctxt_term (ap2 a (b (SS_base (ST "T_pure"))) (of_pure_term of_string of_nat of_Pair of_Nil of_Cons a b) (of_option of_None of_Some a b (of_string a b)))
    (ap2 a (b (SS_base (ST "T_to_be_parsed"))) (of_string a b) (of_string a b)) (co1 k (ar2 a (b (SS_base (ST "T_lambda"))) (of_string a b)));

fun rec_ocl_prop f (OclProp_ctxt (x1, x2)) = f x1 x2;

fun of_ocl_prop of_string of_nat of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_prop (ap2 a (b (SS_base (ST "OclProp_ctxt"))) (of_option of_None of_Some a b (of_string a b)) (of_ocl_ctxt_term of_string of_nat of_Pair of_Nil of_Cons of_None of_Some a b));

fun of_ocl_ctxt_term_inv of_string of_nat of_bool of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_ctxt_term_inv (ap2 a (b (SS_base (ST "T_inv"))) (of_bool b) (of_ocl_prop of_string of_nat of_Pair of_Nil of_Cons of_None of_Some a b));

fun rec_ocl_ctxt_term_pp f1 f2 (T_pp (x11, x12)) = f1 x11 x12
  | rec_ocl_ctxt_term_pp f1 f2 (T_invariant x2) = f2 x2;

fun rec_ocl_ctxt_prefix f1 f2 OclCtxtPre = f1
  | rec_ocl_ctxt_prefix f1 f2 OclCtxtPost = f2;

fun of_ocl_ctxt_prefix a b = rec_ocl_ctxt_prefix (b (SS_base (ST "OclCtxtPre"))) (b (SS_base (ST "OclCtxtPost")));

fun of_ocl_ctxt_term_pp of_string of_nat of_bool of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_ctxt_term_pp (ap2 a (b (SS_base (ST "T_pp"))) (of_ocl_ctxt_prefix a b) (of_ocl_prop of_string of_nat of_Pair of_Nil of_Cons of_None of_Some a b))
    (ap1 a (b (SS_base (ST "T_invariant"))) (of_ocl_ctxt_term_inv of_string of_nat of_bool of_Pair of_Nil of_Cons of_None of_Some a b));

fun ocl_ctxt_pre_post_rec0 f ocl = f (ctxt_fun_name ocl) (ctxt_fun_ty ocl) (ctxt_expr ocl);

fun moree (Ocl_ctxt_pre_post_ext (ctxt_fun_name, ctxt_fun_ty, ctxt_expr, more)) = more;

fun ocl_ctxt_pre_post_rec f ocl = ocl_ctxt_pre_post_rec0 f ocl (moree ocl);

fun of_ocl_ctxt_pre_post ext of_string of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b f =
  ocl_ctxt_pre_post_rec
    (ap4 a (b (ext (SS_base (ST "ocl_ctxt_pre_post_ext")))) (of_string a b) (of_ocl_ty ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b)
      (of_list of_Nil of_Cons a b (of_ocl_ctxt_term_pp of_string of_nat of_bool of_Pair of_Nil of_Cons of_None of_Some a b)) (f a b));

fun of_ocl_ctxt_clause ext of_string of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_ctxt_clause (ap1 a (b (SS_base (ST "Ctxt_pp"))) (of_ocl_ctxt_pre_post ext of_string of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit)))
    (ap1 a (b (SS_base (ST "Ctxt_inv"))) (of_ocl_ctxt_term_inv of_string of_nat of_bool of_Pair of_Nil of_Cons of_None of_Some a b));

fun classRaw_abstract (Ocl_class_raw_ext (classRaw_name, classRaw_own, classRaw_clause, classRaw_abstract, more)) = classRaw_abstract;

fun ocl_class_raw_rec0 f ocl = f (classRaw_name ocl) (classRaw_own ocl) (classRaw_clause ocl) (classRaw_abstract ocl);

fun moreb (Ocl_class_raw_ext (classRaw_name, classRaw_own, classRaw_clause, classRaw_abstract, more)) = more;

fun ocl_class_raw_rec f ocl = ocl_class_raw_rec0 f ocl (moreb ocl);

fun of_ocl_class_raw ext of_string of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b f =
  ocl_class_raw_rec
    (ap5 a (b (ext (SS_base (ST "ocl_class_raw_ext")))) (of_ocl_ty_obj ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b)
      (of_list of_Nil of_Cons a b (of_pair of_Pair a b (of_string a b) (of_ocl_ty ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b)))
      (of_list of_Nil of_Cons a b (of_ocl_ctxt_clause ext of_string of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b)) (of_bool b) (f a b));

fun rec_ocl_ass_class f (OclAssClass (x1, x2)) = f x1 x2;

fun of_ocl_ass_class ext of_string of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_ass_class
    (ap2 a (b (SS_base (ST "OclAssClass"))) (of_ocl_association ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit))
      (of_ocl_class_raw ext of_string of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit)));

fun rec_ocl_generic f (OclGeneric x) = f x;

fun of_ocl_generic of_string a b = rec_ocl_generic (ap1 a (b (SS_base (ST "OclGeneric"))) (of_string a b));

fun rec_ocl_enum f (OclEnum (x1, x2)) = f x1 x2;

fun of_ocl_enum of_string of_Nil of_Cons a b = rec_ocl_enum (ap2 a (b (SS_base (ST "OclEnum"))) (of_string a b) (of_list of_Nil of_Cons a b (of_string a b)));

fun ocl_ctxt_rec0 f ocl = f (ctxt_param ocl) (ctxt_ty ocl) (ctxt_clause ocl);

fun more (Ocl_ctxt_ext (ctxt_param, ctxt_ty, ctxt_clause, more)) = more;

fun ocl_ctxt_rec f ocl = ocl_ctxt_rec0 f ocl (more ocl);

fun of_ocl_ctxt ext of_string of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b f =
  ocl_ctxt_rec (ap4 a (b (ext (SS_base (ST "ocl_ctxt_ext")))) (of_list of_Nil of_Cons a b (of_string a b)) (of_ocl_ty_obj ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b)
                 (of_list of_Nil of_Cons a b (of_ocl_ctxt_clause ext of_string of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b)) (f a b));

fun rec_gen_meta f1 f2 f3 f4 (Gen_apply_hol x1) = f1 x1
  | rec_gen_meta f1 f2 f3 f4 (Gen_apply_sml x2) = f2 x2
  | rec_gen_meta f1 f2 f3 f4 (Gen_apply_sml_cmd (x31, x32)) = f3 x31 x32
  | rec_gen_meta f1 f2 f3 f4 Gen_no_apply = f4;

fun of_gen_meta of_string a b =
  rec_gen_meta (ap1 a (b (SS_base (ST "Gen_apply_hol"))) (of_string a b)) (ap1 a (b (SS_base (ST "Gen_apply_sml"))) (of_string a b)) (ap2 a (b (SS_base (ST "Gen_apply_sml_cmd"))) (of_string a b) (of_string a b))
    (b (SS_base (ST "Gen_no_apply")));

fun rec_IsaUnit f (IsaUnit (x1, x2, x3, x4, x5)) = f x1 x2 x3 x4 x5;

fun rec_ThyName f (ThyName x) = f x;

fun of_ThyName of_string a b = rec_ThyName (ap1 a (b (SS_base (ST "ThyName"))) (of_string a b));

fun rec_Module f (Module (x1, x2, x3, x4)) = f x1 x2 x3 x4;

fun rec_Function_Stmt f (Function_Stmt (x1, x2, x3)) = f x1 x2 x3;

fun rec_Function_Kind f1 f2 f3 f4 Definition = f1
  | rec_Function_Kind f1 f2 f3 f4 Primrec = f2
  | rec_Function_Kind f1 f2 f3 f4 Fun = f3
  | rec_Function_Kind f1 f2 f3 f4 Function_Sorry = f4;

fun of_Function_Kind b = rec_Function_Kind (b (SS_base (ST "Definition"))) (b (SS_base (ST "Primrec"))) (b (SS_base (ST "Fun"))) (b (SS_base (ST "Function_Sorry")));

fun rec_TypeSign f (TypeSign (x1, x2, x3)) = f x1 x2 x3;

fun rec_Name f1 f2 (QName (x11, x12)) = f1 x11 x12
  | rec_Name f1 f2 (Name x2) = f2 x2;

fun of_Name of_string a b = rec_Name (ap2 a (b (SS_base (ST "QName"))) (of_ThyName of_string a b) (of_string a b)) (ap1 a (b (SS_base (ST "Name"))) (of_string a b));

fun rec_Type f1 f2 f3 f4 (Typea (x11, x12)) = f1 x11 (mapa (fn typea => (typea, rec_Type f1 f2 f3 f4 typea)) x12)
  | rec_Type f1 f2 f3 f4 (Func (x21, x22)) = f2 x21 x22 (rec_Type f1 f2 f3 f4 x21) (rec_Type f1 f2 f3 f4 x22)
  | rec_Type f1 f2 f3 f4 (TVar x3) = f3 x3
  | rec_Type f1 f2 f3 f4 NoType = f4;

fun of_Type of_string of_Nil of_Cons a b =
  rec_Type (ap2 a (b (SS_base (ST "Type"))) (of_Name of_string a b) (of_list of_Nil of_Cons a b snd)) (fn _ => fn _ => ar2 a (b (SS_base (ST "Func"))) id) (ap1 a (b (SS_base (ST "TVar"))) (of_Name of_string a b))
    (b (SS_base (ST "NoType")));

fun of_Sort of_string of_Nil of_Cons a b = of_list of_Nil of_Cons a b (of_Name of_string a b);

fun of_TypeSign of_string of_Pair of_Nil of_Cons a b =
  rec_TypeSign (ap3 a (b (SS_base (ST "TypeSign"))) (of_Name of_string a b) (of_list of_Nil of_Cons a b (of_pair of_Pair a b (of_Name of_string a b) (of_Sort of_string of_Nil of_Cons a b))) (of_Type of_string of_Nil of_Cons a b));

fun rec_Literal f1 f2 (Int x1) = f1 x1
  | rec_Literal f1 f2 (Stringa x2) = f2 x2;

fun of_Literal of_string of_nat a b = rec_Literal (ap1 a (b (SS_base (ST "Int"))) (of_nat a b)) (ap1 a (b (SS_base (ST "String"))) (of_string a b));

fun of_TLD_aux of_string of_nat of_Pair of_Nil of_Cons f_rec a b =
  f_rec (ap1 a (b (SS_base (ST "Literal"))) (of_Literal of_string of_nat a b)) (ap1 a (b (SS_base (ST "Const"))) (of_Name of_string a b)) (co1 k (ar2 a (b (SS_base (ST "Abs"))) (of_Name of_string a b)))
    (fn _ => fn _ => ar2 a (b (SS_base (ST "App"))) id)
    (fn _ => fn _ => fn _ => ar3 a (b (SS_base (ST "If"))) id id)
    (fn l => fn _ => ap2 a (b (SS_base (ST "Let"))) (of_list of_Nil of_Cons a b (of_pair of_Pair a b id id)) id (mapa (map_prod snd snd) l))
    (fn _ => fn l => ap2 a (b (SS_base (ST "Case"))) (of_list of_Nil of_Cons a b (of_pair of_Pair a b id id)) id (mapa (map_prod snd snd) l))
    (fn _ => fn l => ap2 a (b (SS_base (ST "ListCompr"))) (of_list of_Nil of_Cons a b id) id (mapa snd l))
    (fn aa => fn l => ap2 a (b (SS_base (ST "RecConstr"))) (of_Name of_string a b) (of_list of_Nil of_Cons a b (of_pair of_Pair a b (of_Name of_string a b) id)) aa (mapa (map_prod id snd) l))
    (k (ap2 a (b (SS_base (ST "RecUpdate"))) (of_list of_Nil of_Cons a b (of_pair of_Pair a b (of_Name of_string a b) id)) id o mapa (map_prod id snd)))
    (fn aa => fn l => ap3 a (b (SS_base (ST "DoBlock"))) (of_string a b) (of_list of_Nil of_Cons a b id) (of_string a b) aa (mapa snd l))
    (k (ar1 a (b (SS_base (ST "Parenthesized")))))
    (ap1 a (b (SS_base (ST "Generator"))) (of_pair of_Pair a b id id) o map_prod snd snd)
    (k (ar1 a (b (SS_base (ST "Guard")))))
    (fn _ => fn _ => ar2 a (b (SS_base (ST "DoGenerator"))) id)
    (k (ar1 a (b (SS_base (ST "DoQualifier")))))
    (ap1 a (b (SS_base (ST "DoLetStmt"))) (of_list of_Nil of_Cons a b (of_pair of_Pair a b id id)) o mapa (map_prod snd snd));

fun rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (Literal x11) = f11 x11
  | rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (Const x12) = f12 x12
  | rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (Abs (x131, x132)) = f13 x131 x132 (rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 x132)
  | rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (App (x141, x142)) =
    f14 x141 x142 (rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 x141) (rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 x142)
  | rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (If (x151, x152, x153)) =
    f15 x151 x152 x153 (rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 x151) (rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 x152)
      (rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 x153)
  | rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (Let (x161, x162)) =
    f16 (mapa (map_prod (fn term => (term, rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 term)) (fn term => (term, rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 term)))
          x161)
      x162
      (rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 x162)
  | rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (Case (x171, x172)) =
    f17 x171 (mapa (map_prod (fn term => (term, rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 term))
                     (fn term => (term, rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 term)))
               x172)
      (rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 x171)
  | rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (ListCompr (x181, x182)) =
    f18 x181 (mapa (fn listComprFragment => (listComprFragment, rec_ListComprFragment f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 listComprFragment)) x182)
      (rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 x181)
  | rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (RecConstr (x191, x192)) =
    f19 x191 (mapa (map_prod id (fn term => (term, rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 term))) x192)
  | rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (RecUpdate (x1101, x1102)) =
    f110 x1101 (mapa (map_prod id (fn term => (term, rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 term))) x1102) (rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 x1101)
  | rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (DoBlock (x1111, x1112, x1113)) =
    f111 x1111 (mapa (fn doBlockFragment => (doBlockFragment, rec_DoBlockFragment f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 doBlockFragment)) x1112) x1113
  | rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (Parenthesized x112) = f112 x112 (rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 x112)
and rec_DoBlockFragment f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (DoGenerator (x311, x312)) =
  f31 x311 x312 (rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 x311) (rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 x312)
  | rec_DoBlockFragment f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (DoQualifier x32) = f32 x32 (rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 x32)
  | rec_DoBlockFragment f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (DoLetStmt x33) =
    f33 (mapa (map_prod (fn term => (term, rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 term)) (fn term => (term, rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 term)))
          x33)
and rec_ListComprFragment f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (Generator x21) =
  f21 (map_prod (fn term => (term, rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 term)) (fn term => (term, rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 term)) x21)
  | rec_ListComprFragment f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 (Guard x22) = f22 x22 (rec_Term f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f21 f22 f31 f32 f33 x22);

fun of_Term of_string of_nat of_Pair of_Nil of_Cons = of_TLD_aux of_string of_nat of_Pair of_Nil of_Cons rec_Term;

fun of_Pat of_string of_nat of_Pair of_Nil of_Cons = of_Term of_string of_nat of_Pair of_Nil of_Cons;

fun of_Function_Stmt of_string of_nat of_Pair of_Nil of_Cons a b =
  rec_Function_Stmt
    (ap3 a (b (SS_base (ST "Function_Stmt"))) (of_Function_Kind b) (of_list of_Nil of_Cons a b (of_TypeSign of_string of_Pair of_Nil of_Cons a b))
      (of_list of_Nil of_Cons a b
        (of_pair of_Pair a b (of_pair of_Pair a b (of_Name of_string a b) (of_list of_Nil of_Cons a b (of_Pat of_string of_nat of_Pair of_Nil of_Cons a b))) (of_Term of_string of_nat of_Pair of_Nil of_Cons a b))));

fun rec_TypeSpec f (TypeSpec (x1, x2)) = f x1 x2;

fun of_TypeSpec of_string of_Nil of_Cons a b = rec_TypeSpec (ap2 a (b (SS_base (ST "TypeSpec"))) (of_list of_Nil of_Cons a b (of_Name of_string a b)) (of_Name of_string a b));

fun rec_Stmt f1 f2 f3 f4 f5 f6 f7 f8 (Datatype x1) = f1 x1
  | rec_Stmt f1 f2 f3 f4 f5 f6 f7 f8 (Record (x21, x22)) = f2 x21 x22
  | rec_Stmt f1 f2 f3 f4 f5 f6 f7 f8 (TypeSynonym x3) = f3 x3
  | rec_Stmt f1 f2 f3 f4 f5 f6 f7 f8 (Functiona x4) = f4 x4
  | rec_Stmt f1 f2 f3 f4 f5 f6 f7 f8 (Class (x51, x52, x53)) = f5 x51 x52 x53
  | rec_Stmt f1 f2 f3 f4 f5 f6 f7 f8 (Instance (x61, x62, x63, x64)) = f6 x61 x62 x63 x64
  | rec_Stmt f1 f2 f3 f4 f5 f6 f7 f8 (Comment x7) = f7 x7
  | rec_Stmt f1 f2 f3 f4 f5 f6 f7 f8 (SML x8) = f8 x8;

fun of_Stmt of_string of_nat of_Pair of_Nil of_Cons a b =
  rec_Stmt (ap1 a (b (SS_base (ST "Datatype")))
             (of_list of_Nil of_Cons a b
               (of_pair of_Pair a b (of_TypeSpec of_string of_Nil of_Cons a b) (of_list of_Nil of_Cons a b (of_pair of_Pair a b (of_Name of_string a b) (of_list of_Nil of_Cons a b (of_Type of_string of_Nil of_Cons a b)))))))
    (ap2 a (b (SS_base (ST "Record"))) (of_TypeSpec of_string of_Nil of_Cons a b) (of_list of_Nil of_Cons a b (of_pair of_Pair a b (of_Name of_string a b) (of_Type of_string of_Nil of_Cons a b))))
    (ap1 a (b (SS_base (ST "TypeSynonym"))) (of_list of_Nil of_Cons a b (of_pair of_Pair a b (of_TypeSpec of_string of_Nil of_Cons a b) (of_Type of_string of_Nil of_Cons a b))))
    (ap1 a (b (SS_base (ST "Function"))) (of_Function_Stmt of_string of_nat of_Pair of_Nil of_Cons a b))
    (ap3 a (b (SS_base (ST "Class"))) (of_Name of_string a b) (of_list of_Nil of_Cons a b (of_Name of_string a b)) (of_list of_Nil of_Cons a b (of_TypeSign of_string of_Pair of_Nil of_Cons a b)))
    (ap4 a (b (SS_base (ST "Instance"))) (of_Name of_string a b) (of_Name of_string a b) (of_list of_Nil of_Cons a b (of_pair of_Pair a b (of_Name of_string a b) (of_Sort of_string of_Nil of_Cons a b)))
      (of_list of_Nil of_Cons a b (of_Function_Stmt of_string of_nat of_Pair of_Nil of_Cons a b)))
    (ap1 a (b (SS_base (ST "Comment"))) (of_string a b)) (ap1 a (b (SS_base (ST "SML"))) (of_Function_Stmt of_string of_nat of_Pair of_Nil of_Cons a b));

fun of_Module of_string of_nat of_bool of_Pair of_Nil of_Cons a b =
  rec_Module (ap4 a (b (SS_base (ST "Module"))) (of_ThyName of_string a b) (of_list of_Nil of_Cons a b (of_ThyName of_string a b)) (of_list of_Nil of_Cons a b (of_Stmt of_string of_nat of_Pair of_Nil of_Cons a b)) (of_bool b));

fun of_IsaUnit of_string of_nat of_bool of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_IsaUnit (ap5 a (b (SS_base (ST "IsaUnit"))) (of_pair of_Pair a b (of_bool b) (of_nat a b)) (of_list of_Nil of_Cons a b (of_pair of_Pair a b (of_string a b) (of_option of_None of_Some a b (of_string a b))))
                (of_gen_meta of_string a b) (of_string a b) (of_pair of_Pair a b (of_list of_Nil of_Cons a b (of_Module of_string of_nat of_bool of_Pair of_Nil of_Cons a b)) (of_bool b)));

fun rec_floor f1 f2 f3 Floor1 = f1
  | rec_floor f1 f2 f3 Floor2 = f2
  | rec_floor f1 f2 f3 Floor3 = f3;

fun of_floor a b = rec_floor (b (SS_base (ST "Floor1"))) (b (SS_base (ST "Floor2"))) (b (SS_base (ST "Floor3")));

fun of_all_meta_embedding ext of_string of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_all_meta_embedding (ap1 a (b (SS_base (ST "META_enum"))) (of_ocl_enum of_string of_Nil of_Cons a b))
    (ap2 a (b (SS_base (ST "META_class_raw"))) (of_floor a b) (of_ocl_class_raw ext of_string of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit)))
    (ap1 a (b (SS_base (ST "META_association"))) (of_ocl_association ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit)))
    (ap2 a (b (SS_base (ST "META_ass_class"))) (of_floor a b) (of_ocl_ass_class ext of_string of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b))
    (ap2 a (b (SS_base (ST "META_ctxt"))) (of_floor a b) (of_ocl_ctxt ext of_string of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit)))
    (ap1 a (b (SS_base (ST "META_haskell"))) (of_IsaUnit of_string of_nat of_bool of_Pair of_Nil of_Cons of_None of_Some a b))
    (ap1 a (b (SS_base (ST "META_class_synonym"))) (of_ocl_class_synonym ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b))
    (ap1 a (b (SS_base (ST "META_instance"))) (of_ocl_instance ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b))
    (ap1 a (b (SS_base (ST "META_def_base_l"))) (of_ocl_def_base_l of_string of_Pair of_Nil of_Cons a b))
    (ap2 a (b (SS_base (ST "META_def_state"))) (of_floor a b) (of_ocl_def_state ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b))
    (ap2 a (b (SS_base (ST "META_def_transition"))) (of_floor a b) (of_ocl_def_transition ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b))
    (ap1 a (b (SS_base (ST "META_class_tree"))) (of_ocl_class_tree of_nat a b)) (ap1 a (b (SS_base (ST "META_flush_all"))) (of_ocl_flush_all a b)) (ap1 a (b (SS_base (ST "META_generic"))) (of_ocl_generic of_string a b));

fun rec_ocl_class f (OclClass (x1, x2, x3)) = f x1 x2 (mapa (fn ocl_class => (ocl_class, rec_ocl_class f ocl_class)) x3);

fun of_ocl_class ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b =
  rec_ocl_class
    (ap3 a (b (SS_base (ST "OclClass"))) (of_string a b) (of_list of_Nil of_Cons a b (of_pair of_Pair a b (of_string a b) (of_ocl_ty ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b)))
      (of_list of_Nil of_Cons a b snd));

fun of_compiler_env_config ext of_string of_string_b_a_s_e of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b f =
  compiler_env_config_rec
    (ap16 a (b (ext (SS_base (ST "compiler_env_config_ext")))) (of_bool b) (of_option of_None of_Some a b (of_pair of_Pair a b (of_string a b) (of_pair of_Pair a b (of_list of_Nil of_Cons a b (of_string a b)) (of_string a b))))
      (of_internal_oids of_nat a b) (of_pair of_Pair a b (of_nat a b) (of_nat a b)) (of_generation_semantics_ocl a b) (of_option of_None of_Some a b (of_ocl_class ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b))
      (of_list of_Nil of_Cons a b (of_all_meta_embedding ext of_string of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b))
      (of_list of_Nil of_Cons a b (of_pair of_Pair a b (of_string_b_a_s_e a b) (of_pair of_Pair a b (of_ocl_instance_single ext of_string of_nat of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit)) (of_internal_oids of_nat a b))))
      (of_list of_Nil of_Cons a b
        (of_pair of_Pair a b (of_string_b_a_s_e a b)
          (of_list of_Nil of_Cons a b
            (of_pair of_Pair a b (of_internal_oids of_nat a b)
              (of_ocl_def_state_core ext of_string of_nat of_unit of_Pair of_Nil of_Cons of_None of_Some a b
                (of_pair of_Pair a b (of_string a b) (of_ocl_instance_single ext of_string of_nat of_Pair of_Nil of_Cons of_None of_Some a b (k of_unit))))))))
      (of_bool b) (of_bool b) (of_pair of_Pair a b (of_list of_Nil of_Cons a b (of_string_b_a_s_e a b)) (of_list of_Nil of_Cons a b (of_string_b_a_s_e a b))) (of_list of_Nil of_Cons a b (of_string_b_a_s_e a b))
      (of_list of_Nil of_Cons a b (of_string_b_a_s_e a b)) (of_pair of_Pair a b (of_option of_None of_Some a b (of_generation_lemma_mode a b)) (of_bool b)) (f a b));

fun of_string a b = (fn x => b (flattena [SS_base (ST "(META.SS_base (META.ST \""), sml_escape x, SS_base (ST "\"))")]));

fun of_unit b = (fn () => b (SS_base (ST "()")));

fun of_bool b = (fn a => (case a of true => b (SS_base (ST "true")) | false => b (SS_base (ST "false"))));

val of_Some : abr_string = SS_base (ST "SOME");

val of_Pair : abr_string = SS_base (ST "I");

val of_None : abr_string = SS_base (ST "NONE");

val of_Cons : abr_string = SS_base (ST "uncurry cons");

fun of_nat a b = (fn x => b (flattena [SS_base (ST "(Code_Numeral.natural_of_integer "), natural_to_digit10 x, SS_base (ST ")")]));

val of_Nil : abr_string = SS_base (ST "nil");

fun compiler_env_config a b = of_compiler_env_config (fn c => let
                                                                val x :: xs = to_list c;
                                                              in
                                                                flattena [uppercase (SS_base (STa [x])), SS_base (STa xs)]
                                                              end)
                                of_string of_string_b_a_s_e of_nat of_unit of_bool of_Pair of_Nil of_Cons of_None of_Some a b (fn _ => of_unit);

fun sml_of_compiler_env_config x = compiler_env_config x;

fun sml_apply s l = flattena [s, SS_base (ST " ("), let
                                                      val x :: xs = l;
                                                    in
                                                      flattena [x, flattena (map (fn sa => flattena [SS_base (ST ", "), sa]) xs)]
                                                    end,
                               SS_base (ST ")")];

fun let_open s = (fn a => SML_let (SML_top [SML_open s], a));

fun of_boot_setup_env to_string env =
  (fn Boot_setup_env e => of_setup to_string env (Setup (app0 (SS_base (ST "Generation_mode.update_compiler_config")) [app (SS_base (ST "K")) [let_open (SS_base (ST "META")) (SML_basic [sml_of_compiler_env_config sml_apply id e])]])));

fun of_all_meta to_string to_nat env =
  (fn a => (case a of META_semi_theories aa => of_e_n_v_semi_theories to_string to_nat env aa | META_boot_generation_syntax aa => of_boot_generation_syntax env aa | META_boot_setup_env aa => of_boot_setup_env to_string env aa
             | META_all_meta_embedding aa => of_all_meta_embeddinga to_string to_nat env aa));

fun term_string s = Term_basic [flattena [SS_base (ST "\""), s, SS_base (ST "\"")]];

val integer_escape : int = (9 : IntInf.int);

fun of_all_meta_lists to_string to_nat env l_thy =
  let
    val (th_beg, th_end) =
      (case d_output_header_thy env of NONE => ([], [])
        | SOME (name, (fic_import, fic_import_boot)) =>
          ([CodeConst.Printf.sprintf2 "theory %s imports %s begin" (to_string name)
              (of_semi_terma to_string (term_binopa (SS_base (ST " ")) (map term_string (append fic_import (if d_output_header_force env orelse d_output_auto_bootstrap env then [fic_import_boot] else [])))))],
            ["", "end"]));
  in
    flatten [th_beg, flatten (fst (mapM (fn (msg, l) => fn (i, cpt) =>
                                          let
                                            val (l_thya, lg) = mapM (fn la => fn n => (of_all_meta to_string to_nat env la, succ (one_natural, plus_natural) n)) l Code_Numeral.zero_natural;
                                          in
                                            ("" :: CodeConst.Printf.sprintf5 "%s(* %d ************************************ %d + %d *)%s" (to_string (if moreg env then SS_base (ST "") else SS_base (STa [integer_escape])))
                                                     (to_nat (succ (one_natural, plus_natural) i)) (to_nat cpt) (to_nat lg) (case msg of NONE => "" | SOME msga => CodeConst.Printf.sprintf1 "  (* term %s *)" (to_string msga)) ::
                                                     l_thya,
                                              (succ (one_natural, plus_natural) i, Code_Numeral.plus_natural cpt lg))
                                          end)
                                    l_thy (d_output_position env))),
              th_end]
  end;

fun write_file0a to_string to_nat env =
  let
    val (_, sys_argv) = moreg env;
    val (is_file, f_output) =
      (case (d_output_header_thy env, sys_argv) of (NONE, _) => (false, CodeConst.outStand1) | (SOME (_, _), NONE) => (false, CodeConst.outStand1)
        | (SOME (file_out, _), SOME dir) =>
          let
            val dira = to_string dir;
          in
            (true, (fn f => CodeConst.Monad.bind (CodeConst.Sys.isDirectory2 dira)
                              (fn sys_is_directory2_dir => CodeConst.outFile1 f (if sys_is_directory2_dir then CodeConst.Printf.sprintf2 "%s/%s.thy" dira (to_string file_out) else dira))))
          end);
    val (enva, l) = fold_thya comp_env_save_deep (fn f => f ()) (fn _ => fn _ => []) (fn msg => fn x => fn acc1 => fn acc2 => (acc1, (msg, x) :: acc2)) (fst (moreg env)) (truncate env, []);
  in
    (f_output, of_all_meta_lists to_string to_nat (compiler_env_config_more_map (fn _ => is_file) enva) (rev l))
  end;

fun write_filea to_string to_nat env = let
                                         val (f_output, l) = write_file0a to_string to_nat env;
                                       in
                                         f_output (fn fprintf1 => list_iterM (fprintf1 "%s\n") l)
                                       end;

fun write_file x = print write_filea x;

val cAddOp : cBinaryOp = CAddOp0;

val cAdrOp : cUnaryOp = CAdrOp0;

val cAndOp : cBinaryOp = CAndOp0;

fun cBreak x = CBreak0 x;

fun cCases x = (fn a => fn b => fn c => CCases0 (x, a, b, c));

fun cChars x = (fn a => CChars0 (x, a));

fun cComma x = (fn a => CComma0 (x, a));

fun cConst x = CConst0 x;

fun cDeclr x = (fn a => fn b => fn c => fn d => CDeclr0 (x, a, b, c, d));

val cDivOp : cBinaryOp = CDivOp0;

fun cFloat x = CFloat0 x;

val cGeqOp : cBinaryOp = CGeqOp0;

val cIndOp : cUnaryOp = CIndOp0;

fun cIndex x = (fn a => fn b => CIndex0 (x, a, b));

fun cLabel x = (fn a => fn b => fn c => CLabel0 (x, a, b, c));

val cLeqOp : cBinaryOp = CLeqOp0;

val cLndOp : cBinaryOp = CLndOp0;

val cLorOp : cBinaryOp = CLorOp0;

val cMinOp : cUnaryOp = CMinOp0;

val cMulOp : cBinaryOp = CMulOp0;

val cNegOp : cUnaryOp = CNegOp0;

val cNeqOp : cBinaryOp = CNeqOp0;

val cRmdOp : cBinaryOp = CRmdOp0;

val cShlOp : cBinaryOp = CShlOp0;

val cShrOp : cBinaryOp = CShrOp0;

val cSubOp : cBinaryOp = CSubOp0;

fun cUnary x = (fn a => fn b => CUnary0 (x, a, b));

fun cWhile x = (fn a => fn b => fn c => CWhile0 (x, a, b, c));

val cXorOp : cBinaryOp = CXorOp0;

fun textstr_of_str f_flatten f_integer f_str str =
  let
    val str0 = to_list str;
    val f_letter = (fn c => is_letter c orelse (is_digit c orelse is_special c));
    val _ = SS_base (ST "c");
    val f_text = (fn a => (case a of Nsplit_text l => flattena [f_str (flattena [SS_base (ST "STR ''"), SS_base (STa l), SS_base (ST "''")])] | Nsplit_sep c => flattena [f_integer c]));
    val stra = (case nsplit_f str0 (not o f_letter) of [] => flattena [f_str (SS_base (ST "STR ''''"))] | [x] => f_text x
                 | x :: ab :: lista => flattenb (flattena (map (fn xa => flattenb (SS_base (ST "(")) (flattenb (f_text xa) (SS_base (ST ") # ")))) (x :: ab :: lista))) (SS_base (ST "[]")));
  in
    (if list_all f_letter str0 then stra else f_flatten (flattena [SS_base (ST "("), stra, SS_base (ST ")")]))
  end;

fun write_file0 x = print write_file0a x;

fun cAsmExt x = (fn a => CAsmExt0 (x, a));

fun cAssign x = (fn a => fn b => fn c => CAssign0 (x, a, b, c));

fun cBinary x = (fn a => fn b => fn c => CBinary0 (x, a, b, c));

val cCompOp : cUnaryOp = CCompOp0;

fun cExtern x = CExtern0 x;

fun cFunDef x = (fn a => fn b => fn c => fn d => CFunDef0 (x, a, b, c, d));

fun cMember x = (fn a => fn b => fn c => CMember0 (x, a, b, c));

val cPlusOp : cUnaryOp = CPlusOp0;

fun cReturn x = (fn a => CReturn0 (x, a));

fun cSUType x = (fn a => CSUType0 (x, a));

fun cStatic x = CStatic0 x;

fun cStrLit x = (fn a => CStrLit0 (x, a));

fun cString x = (fn a => CString0 (x, a));

fun cStruct x = (fn a => fn b => fn c => fn d => CStruct0 (x, a, b, c, d));

fun cSwitch x = (fn a => fn b => CSwitch0 (x, a, b));

fun cThread x = CThread0 x;

val decRepr : cIntRepr = DecRepr0;

val hexRepr : cIntRepr = HexRepr0;

fun onlyPos x = (fn a => OnlyPos0 (x, a));

fun head (Asmblock (x1, x2, x3, x4)) = x1;

fun mod1 (Asmblock (x1, x2, x3, x4)) = x2;

fun mod2 (Asmblock (x1, x2, x3, x4)) = x3;

fun mod3 (Asmblock (x1, x2, x3, x4)) = x4;

fun map_Region_Wrap f (Tb (x1, x2)) = Tb (f x1, x2);

fun map_ctype f (Signed x1) = Signed x1
  | map_ctype f (Unsigned x2) = Unsigned x2
  | map_ctype f Bool = Bool
  | map_ctype f PlainChar = PlainChar
  | map_ctype f (StructTy x5) = StructTy x5
  | map_ctype f (UnionTy x6) = UnionTy x6
  | map_ctype f (EnumTy x7) = EnumTy x7
  | map_ctype f (Ptr x8) = Ptr (map_ctype f x8)
  | map_ctype f (Array (x91, x92)) = Array (map_ctype f x91, map_optiona f x92)
  | map_ctype f (Bitfield (x101, x102)) = Bitfield (x101, f x102)
  | map_ctype f (Identa x11) = Identa x11
  | map_ctype f (Function (x121, x122)) = Function (map_ctype f x121, mapa (map_ctype f) x122)
  | map_ctype f Void = Void;

fun rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (E x2) =
  f2 (map_Region_Wrap (fn expr_node => (expr_node, rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 expr_node)) x2)
and rec_designator f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (DesignE x41) = f41 x41 (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x41)
  | rec_designator f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (DesignFld x42) = f42 x42
and rec_initializer f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (InitE x31) = f31 x31 (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x31)
  | rec_initializer f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (InitList x32) =
    f32 (mapa (map_prod (mapa (fn designator => (designator, rec_designator f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 designator)))
                (fn initializer => (initializer, rec_initializer f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 initializer)))
          x32)
and rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (BinOp (x111, x112, x113)) =
  f11 x111 x112 x113 (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x112) (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x113)
  | rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (UnOp (x121, x122)) =
    f12 x121 x122 (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x122)
  | rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (CondExp (x131, x132, x133)) =
    f13 x131 x132 x133 (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x131) (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x132)
      (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x133)
  | rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (Constant x14) = f14 x14
  | rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (Vara (x151, x152)) = f15 x151 x152
  | rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (StructDot (x161, x162)) =
    f16 x161 x162 (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x161)
  | rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (ArrayDeref (x171, x172)) =
    f17 x171 x172 (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x171) (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x172)
  | rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (Deref x18) = f18 x18 (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x18)
  | rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (TypeCast (x191, x192)) =
    f19 (map_Region_Wrap (map_ctype (fn expr => (expr, rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 expr))) x191) x192
      (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x192)
  | rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (Sizeof x110) = f110 x110 (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x110)
  | rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (SizeofTy x111a) =
    f111 (map_Region_Wrap (map_ctype (fn expr => (expr, rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 expr))) x111a)
  | rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (EFnCall (x1121, x1122)) =
    f112 x1121 (mapa (fn expr => (expr, rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 expr)) x1122)
      (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x1121)
  | rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (CompLiteral (x1131, x1132)) =
    f113 (map_ctype (fn expr => (expr, rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 expr)) x1131)
      (mapa (map_prod (mapa (fn designator => (designator, rec_designator f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 designator)))
              (fn initializer => (initializer, rec_initializer f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 initializer)))
        x1132)
  | rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (Arbitrary x114) =
    f114 (map_ctype (fn expr => (expr, rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 expr)) x114)
  | rec_expr_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 (MKBOOL x115) = f115 x115 (rec_expr f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f2 f31 f32 f41 f42 x115);

fun cArrSize x = (fn a => CArrSize0 (x, a));

fun cAsmStmt x = (fn a => fn b => fn c => fn d => fn e => CAsmStmt0 (x, a, b, c, d, e));

fun cDeclExt x = CDeclExt0 x;

fun cDefault x = (fn a => CDefault0 (x, a));

fun cFDefExt x = CFDefExt0 x;

fun cFunSpec x = CFunSpec0 x;

fun cGotoPtr x = (fn a => CGotoPtr0 (x, a));

fun cIntType x = CIntType0 x;

fun cInteger x = (fn a => fn b => CInteger0 (x, a, b));

val cOrAssOp : cAssignOp = COrAssOp0;

fun cTypeDef x = (fn a => CTypeDef0 (x, a));

fun cTypedef x = CTypedef0 x;

val flagImag : cIntFlag = FlagImag0;

val flagLong : cIntFlag = FlagLong0;

fun namedRef x = NamedRef0 x;

fun nodeInfo x = (fn a => fn b => NodeInfo0 (x, a, b));

fun position x = (fn a => fn b => fn c => Position0 (x, a, b, c));

fun fold_thy_shallow f_try f_accu_reset x = fold_thy comp_env_save f_try f_accu_reset (fn name => fn l => fn acc1 => map_prod (d_input_meta_update (fn _ => d_input_meta acc1)) id o x name l o (fn a => (acc1, a)));

val cAddAssOp : cAssignOp = CAddAssOp0;

val cAndAssOp : cAssignOp = CAndAssOp0;

fun cArrDeclr x = (fn a => fn b => CArrDeclr0 (x, a, b));

fun cArrDesig x = (fn a => CArrDesig0 (x, a));

val cAssignOp : cAssignOp = CAssignOp0;

fun cAttrQual x = CAttrQual0 x;

fun cBoolType x = CBoolType0 x;

fun cCharType x = CCharType0 x;

fun cCompound x = (fn a => fn b => CCompound0 (x, a, b));

val cDivAssOp : cAssignOp = CDivAssOp0;

fun cEnumType x = (fn a => CEnumType0 (x, a));

fun cFunDeclr x = (fn a => fn b => CFunDeclr0 (x, a, b));

fun cInitExpr x = (fn a => CInitExpr0 (x, a));

fun cInitList x = (fn a => CInitList0 (x, a));

fun cIntConst x = (fn a => CIntConst0 (x, a));

fun cLongType x = CLongType0 x;

val cMulAssOp : cAssignOp = CMulAssOp0;

val cPreDecOp : cUnaryOp = CPreDecOp0;

val cPreIncOp : cUnaryOp = CPreIncOp0;

fun cPtrDeclr x = (fn a => CPtrDeclr0 (x, a));

fun cRegister x = CRegister0 x;

val cRmdAssOp : cAssignOp = CRmdAssOp0;

val cShlAssOp : cAssignOp = CShlAssOp0;

val cShrAssOp : cAssignOp = CShrAssOp0;

fun cStatExpr x = (fn a => CStatExpr0 (x, a));

fun cStrConst x = (fn a => CStrConst0 (x, a));

val cSubAssOp : cAssignOp = CSubAssOp0;

fun cTypeQual x = CTypeQual0 x;

fun cTypeSpec x = CTypeSpec0 x;

val cUnionTag : cStructTag = CUnionTag0;

fun cVoidType x = CVoidType0 x;

val cXorAssOp : cAssignOp = CXorAssOp0;

val octalRepr : cIntRepr = OctalRepr0;

fun rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 (Signed x1) = f1 x1
  | rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 (Unsigned x2) = f2 x2
  | rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 Bool = f3
  | rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 PlainChar = f4
  | rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 (StructTy x5) = f5 x5
  | rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 (UnionTy x6) = f6 x6
  | rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 (EnumTy x7) = f7 x7
  | rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 (Ptr x8) = f8 x8 (rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 x8)
  | rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 (Array (x91, x92)) = f9 x91 x92 (rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 x91)
  | rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 (Bitfield (x101, x102)) = f10 x101 x102
  | rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 (Identa x11) = f11 x11
  | rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 (Function (x121, x122)) =
    f12 x121 (mapa (fn ctype => (ctype, rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 ctype)) x122) (rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 x121)
  | rec_ctype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 Void = f13;

fun cAlignSpec x = CAlignSpec0 x;

fun cBlockDecl x = CBlockDecl0 x;

fun cBlockStmt x = CBlockStmt0 x;

fun cCharConst x = (fn a => CCharConst0 (x, a));

fun cConstQual x = CConstQual0 x;

fun cFloatType x = CFloatType0 x;

fun cNoArrSize x = CNoArrSize0 x;

val cPostDecOp : cUnaryOp = CPostDecOp0;

val cPostIncOp : cUnaryOp = CPostIncOp0;

fun cRestrQual x = CRestrQual0 x;

fun cShortType x = CShortType0 x;

val cStructTag : cStructTag = CStructTag0;

fun cUnsigType x = CUnsigType0 x;

fun cVolatQual x = CVolatQual0 x;

val noPosition : positiona = NoPosition0;

fun cAsmOperand x = (fn a => fn b => fn c => CAsmOperand0 (x, a, b, c));

fun cAtomicQual x = CAtomicQual0 x;

fun cAtomicType x = (fn a => CAtomicType0 (x, a));

fun cDoubleType x = CDoubleType0 x;

fun cFloatConst x = (fn a => CFloatConst0 (x, a));

fun cInlineQual x = CInlineQual0 x;

fun cInt128Type x = CInt128Type0 x;

fun cRangeDesig x = (fn a => fn b => CRangeDesig0 (x, a, b));

fun cSignedType x = CSignedType0 x;

fun cSizeofExpr x = (fn a => CSizeofExpr0 (x, a));

fun cSizeofType x = (fn a => CSizeofType0 (x, a));

fun cTranslUnit x = (fn a => CTranslUnit0 (x, a));

fun cTypeOfExpr x = (fn a => CTypeOfExpr0 (x, a));

fun cTypeOfType x = (fn a => CTypeOfType0 (x, a));

fun map2_ctxt_term f =
  let
    val f_prop = (fn OclProp_ctxt (n, prop) => OclProp_ctxt (n, f prop));
    val f_inva = (fn T_inv (b, prop) => T_inv (b, f_prop prop));
  in
    (fn a => (case a of META_enum aa => META_enum aa | META_class_raw (aa, b) => META_class_raw (aa, b) | META_association aa => META_association aa | META_ass_class (aa, b) => META_ass_class (aa, b)
               | META_ctxt (Floor1, c) => META_ctxt (Floor1, c)
               | META_ctxt (Floor2, c) =>
                 META_ctxt (Floor2, ctxt_clause_update
                                      (map (fn aa => (case aa of Ctxt_pp pp => Ctxt_pp (ctxt_expr_update (map (fn ab => (case ab of T_pp (pref, prop) => T_pp (pref, f_prop prop) | T_invariant inva => T_invariant (f_inva inva)))) pp)
                                                       | Ctxt_inv l_inv => Ctxt_inv (f_inva l_inv))))
                                      c)
               | META_ctxt (Floor3, c) => META_ctxt (Floor3, c) | META_haskell aa => META_haskell aa | META_class_synonym aa => META_class_synonym aa | META_instance aa => META_instance aa | META_def_base_l aa => META_def_base_l aa
               | META_def_state (aa, b) => META_def_state (aa, b) | META_def_transition (aa, b) => META_def_transition (aa, b) | META_class_tree aa => META_class_tree aa | META_flush_all aa => META_flush_all aa
               | META_generic aa => META_generic aa))
  end;

fun rec_Region f1 f2 Bogus = f1
  | rec_Region f1 f2 (T (x21, x22)) = f2 x21 x22;

fun rec_fnspec f1 f2 f3 f4 f5 (Fnspec x1) = f1 x1
  | rec_fnspec f1 f2 f3 f4 f5 (Relspec x2) = f2 x2
  | rec_fnspec f1 f2 f3 f4 f5 (Fn_modifies x3) = f3 x3
  | rec_fnspec f1 f2 f3 f4 f5 Didnt_translate = f4
  | rec_fnspec f1 f2 f3 f4 f5 (Gcc_attribs x5) = f5 x5;

fun anonymousRef x = AnonymousRef0 x;

fun cAlignAsExpr x = (fn a => CAlignAsExpr0 (x, a));

fun cAlignAsType x = (fn a => CAlignAsType0 (x, a));

fun cAlignofExpr x = (fn a => CAlignofExpr0 (x, a));

fun cAlignofType x = (fn a => CAlignofType0 (x, a));

fun cBuiltinExpr x = CBuiltinExpr0 x;

fun cComplexImag x = (fn a => CComplexImag0 (x, a));

fun cComplexReal x = (fn a => CComplexReal0 (x, a));

fun cComplexType x = CComplexType0 x;

fun cCompoundLit x = (fn a => fn b => CCompoundLit0 (x, a, b));

fun cLabAddrExpr x = (fn a => CLabAddrExpr0 (x, a));

fun cMemberDesig x = (fn a => CMemberDesig0 (x, a));

fun cNonnullQual x = CNonnullQual0 x;

fun cStorageSpec x = CStorageSpec0 x;

val flagLongLong : cIntFlag = FlagLongLong0;

val flagUnsigned : cIntFlag = FlagUnsigned0;

fun oidInit x = (fn Oid n => Oids (n, n, n)) x;

fun cBuiltinVaArg x = (fn a => fn b => CBuiltinVaArg0 (x, a, b));

fun cNestedFunDef x = CNestedFunDef0 x;

fun cNoreturnQual x = CNoreturnQual0 x;

fun cNullableQual x = CNullableQual0 x;

fun cStaticAssert x = (fn a => fn b => CStaticAssert0 (x, a, b));

fun clangCVersion x = ClangCVersion0 x;

fun isabelle_apply s l = flattena [s, flattena (map (fn sa => flattena [SS_base (ST " ("), sa, SS_base (ST ")")]) l)];

val builtinPosition : positiona = BuiltinPosition0;

fun rec_ext_decl f1 f2 (FnDefn (x11, x12, x13, x14)) = f1 x11 x12 x13 x14
  | rec_ext_decl f1 f2 (Decl x2) = f2 x2;

fun rec_unoptype f1 f2 f3 f4 Negate = f1
  | rec_unoptype f1 f2 f3 f4 Not = f2
  | rec_unoptype f1 f2 f3 f4 Addr = f3
  | rec_unoptype f1 f2 f3 f4 BitNegate = f4;

fun cBuiltinOffsetOf x = (fn a => fn b => CBuiltinOffsetOf0 (x, a, b));

val internalPosition : positiona = InternalPosition0;

fun cGenericSelection x = (fn a => fn b => CGenericSelection0 (x, a, b));

fun check_export_code f_writeln f_warning f_error f_raise l_report msg_last =
  let
    val l_err = fold (fn a => (case a of (Warning, s) => (fn acc => let
                                                                      val () = f_warning s;
                                                                    in
                                                                      acc
                                                                    end)
                                | (Error, s) => (fn acc => let
                                                             val () = f_error s;
                                                           in
                                                             s :: acc
                                                           end)
                                | (Writeln, s) => (fn acc => let
                                                               val () = f_writeln s;
                                                             in
                                                               acc
                                                             end)))
                  l_report [];
  in
    (if null l_err then () else f_raise (flattenb (nat_to_digit10 (size_list l_err)) msg_last))
  end;

fun integer_to_digit16 x = let
                             val f = nth ((List.map (fn c => let val k = Char.ord c in if k < 128 then IntInf.fromInt k else raise Fail "Non-ASCII character in literal" end)  o String.explode) "0123456789ABCDEF") o nat_of_integer;
                           in
                             (fn xa => SS_base (STa [f (divide_integer xa (16 : IntInf.int)), f (modulo_integer xa (16 : IntInf.int))]))
                           end
                             x;

fun rec_SourcePos f (Ta (x1, x2, x3)) = f x1 x2 x3;

fun rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 LogOr = f1
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 LogAnd = f2
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 Equals = f3
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 NotEquals = f4
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 BitwiseAnd = f5
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 BitwiseOr = f6
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 BitwiseXOr = f7
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 Lt = f8
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 Gt = f9
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 Leq = f10
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 Geq = f11
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 Plus = f12
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 Minus = f13
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 Times = f14
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 Divides = f15
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 Modulus = f16
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 RShift = f17
  | rec_binoptype f1 f2 f3 f4 f5 f6 f7 f8 f9 f10 f11 f12 f13 f14 f15 f16 f17 f18 LShift = f18;

fun rec_more_info f1 f2 f3 (MungedVar (x11, x12)) = f1 x11 x12
  | rec_more_info f1 f2 f3 EnumC = f2
  | rec_more_info f1 f2 f3 FunctionName = f3;

fun rec_statement f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (Stmt x2) =
  f2 (map_Region_Wrap (fn statement_node => (statement_node, rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 statement_node)) x2)
and rec_block_item f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (BI_Stmt x31) =
  f31 x31 (rec_statement f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 x31)
  | rec_block_item f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (BI_Decl x32) = f32 x32
and rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (Assign (x111, x112)) = f11 x111 x112
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (AssignFnCall (x121, x122, x123)) = f12 x121 x122 x123
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (Chaos x13) = f13 x13
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (EmbFnCall (x141, x142, x143)) = f14 x141 x142 x143
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (Block x15) =
    f15 (mapa (fn block_item => (block_item, rec_block_item f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 block_item)) x15)
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (While (x161, x162, x163)) =
    f16 x161 x162 x163 (rec_statement f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 x163)
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (Trap (x171, x172)) =
    f17 x171 x172 (rec_statement f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 x172)
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (Return x18) = f18 x18
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (ReturnFnCall (x191, x192)) = f19 x191 x192
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 Break = f110
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 Continue = f111
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (IfStmt (x1121, x1122, x1123)) =
    f112 x1121 x1122 x1123 (rec_statement f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 x1122)
      (rec_statement f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 x1123)
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (Switch (x1131, x1132)) =
    f113 x1131 (mapa (map_prod id (mapa (fn block_item => (block_item, rec_block_item f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 block_item)))) x1132)
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 EmptyStmt = f114
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (Auxupd x115) = f115 x115
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (Ghostupd x116) = f116 x116
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (Spec x117) =
    f117 (map_prod id (map_prod (mapa (fn statement => (statement, rec_statement f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 statement))) id) x117)
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (AsmStmt (x1181, x1182)) = f118 x1181 x1182
  | rec_statement_node f11 f12 f13 f14 f15 f16 f17 f18 f19 f110 f111 f112 f113 f114 f115 f116 f117 f118 f119 f2 f31 f32 (LocalInit x119) = f119 x119;

fun rec_trappable f1 f2 BreakT = f1
  | rec_trappable f1 f2 ContinueT = f2;

fun d_output_sorry_dirty_update d_output_sorry_dirtya
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = Compiler_env_config_ext
      (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
        d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirtya d_output_sorry_dirty, more);

fun d_ocl_semantics_update d_ocl_semanticsa
  (Compiler_env_config_ext
    (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap, d_ocl_accessor,
      d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more))
  = Compiler_env_config_ext
      (d_output_disable_thy, d_output_header_thy, d_ocl_oid_start, d_output_position, d_ocl_semanticsa d_ocl_semantics, d_input_class, d_input_meta, d_input_instance, d_input_state, d_output_header_force, d_output_auto_bootstrap,
        d_ocl_accessor, d_ocl_HO_type, d_hsk_constr, d_output_sorry_dirty, more);

fun compiler_env_config_update f env =
  let
    val enva = f env;
  in
    (if null (d_input_meta env)
      then d_output_sorry_dirty_update (fn _ => d_output_sorry_dirty env)
             (d_ocl_semantics_update (fn _ => d_ocl_semantics env) (d_output_header_thy_update (fn _ => d_output_header_thy env) (d_output_disable_thy_update (fn _ => d_output_disable_thy env) enva)))
      else fst (fold_thya comp_env_save_deep (fn fa => fa ()) (fn _ => id) (fn _ => fn _ => (fn a => fn b => (a, b))) (d_input_meta enva) (env, ())))
  end;

val of_Nila : abr_string = SS_base (ST "Nil");

fun of_nata a b = b o natural_to_digit10;

fun compiler_env_config_reset_all env =
  let
    val enva = compiler_env_config_reset_no_env env;
  in
    (d_input_meta_update (fn _ => []) enva,
      let
        val (l_class, l_env) = find_class_ass enva;
      in
        flatten [l_class, filter (fn a => (case a of META_enum _ => true | META_class_raw (_, _) => true | META_association _ => true | META_ass_class (_, _) => true | META_ctxt (_, _) => true | META_haskell _ => true
                                            | META_class_synonym _ => true | META_instance _ => true | META_def_base_l _ => true | META_def_state (_, _) => true | META_def_transition (_, _) => true | META_class_tree _ => true
                                            | META_flush_all _ => false | META_generic _ => true))
                            l_env,
                  [META_flush_all OclFlushAll]]
      end)
  end;

val of_Consa : abr_string = SS_base (ST "Cons");

val of_Nonea : abr_string = SS_base (ST "None");

val of_Paira : abr_string = SS_base (ST "Pair");

val of_Somea : abr_string = SS_base (ST "Some");

fun of_boolb b = (fn a => (case a of true => b (SS_base (ST "True")) | false => b (SS_base (ST "False"))));

fun of_lista a b f = (rec_list (b of_Nila) o co1 k) (ar2 a (b of_Consa) f);

fun of_paira a b f1 f2 = (fn (c, d) => ap2 a (b of_Paira) f1 f2 c d);

fun of_unita b = (fn () => b (SS_base (ST "()")));

fun rec_Region_Wrap f (Tb (x1, x2)) = f x1 x2;

fun rec_declaration f1 f2 f3 f4 f5 (VarDecl x1) = f1 x1
  | rec_declaration f1 f2 f3 f4 f5 (StructDecl (x21, x22)) = f2 x21 x22
  | rec_declaration f1 f2 f3 f4 f5 (TypeDecl x3) = f3 x3
  | rec_declaration f1 f2 f3 f4 f5 (ExtFnDecl (x41, x42, x43, x44)) = f4 x41 x42 x43 x44
  | rec_declaration f1 f2 f3 f4 f5 (EnumDecl (x51, x52)) = f5 x51 x52;

fun cBuiltinTypesCompatible x = (fn a => fn b => CBuiltinTypesCompatible0 (x, a, b));

fun of_optiona a b f = rec_option (b of_Nonea) (ap1 a (b of_Somea) f);

fun of_string_gen s_flatten s_st0 s_st a b s =
  b let
      val sa = textstr_of_str (fn c => flattenb (SS_base (ST "(")) (flattenb s_flatten (flattenb (SS_base (ST " ")) (flattenb c (SS_base (ST ")")))))) (fn x => s_st0 (flattena [SS_base (ST " 0x"), integer_to_digit16 x]))
                 (fn c => s_st (flattena [SS_base (ST " ("), c, SS_base (ST ")")])) s;
    in
      flattena [SS_base (ST "("), sa, SS_base (ST ")")]
    end;

fun of_stringa x =
  of_string_gen (SS_base (ST "Init.S.flatten")) (fn s => flattena [SS_base (ST "(Init.ST0"), s, SS_base (ST ")")])
    (fn s => flattena [SS_base (ST "(Init.abr_string.SS_base (Init.string\092<^sub>b\092<^sub>a\092<^sub>s\092<^sub>e.ST"), s, SS_base (ST "))")]) x;

fun rec_base_inttype f1 f2 f3 f4 f5 f6 f7 Charb = f1
  | rec_base_inttype f1 f2 f3 f4 f5 f6 f7 Short = f2
  | rec_base_inttype f1 f2 f3 f4 f5 f6 f7 Inta = f3
  | rec_base_inttype f1 f2 f3 f4 f5 f6 f7 Long = f4
  | rec_base_inttype f1 f2 f3 f4 f5 f6 f7 LongLong = f5
  | rec_base_inttype f1 f2 f3 f4 f5 f6 f7 Double = f6
  | rec_base_inttype f1 f2 f3 f4 f5 f6 f7 Float = f7;

fun rec_gcc_attribute f1 f2 f3 (GCC_AttribID x1) = f1 x1
  | rec_gcc_attribute f1 f2 f3 (GCC_AttribFn (x21, x22)) = f2 x21 x22
  | rec_gcc_attribute f1 f2 f3 (OWNED_BY x3) = f3 x3;

fun rec_storage_class f1 f2 f3 f4 f5 SC_EXTERN = f1
  | rec_storage_class f1 f2 f3 f4 f5 SC_STATIC = f2
  | rec_storage_class f1 f2 f3 f4 f5 SC_AUTO = f3
  | rec_storage_class f1 f2 f3 f4 f5 SC_REGISTER = f4
  | rec_storage_class f1 f2 f3 f4 f5 SC_THRD_LOCAL = f5;

fun rec_StringCvt_radix f1 f2 f3 f4 BIN = f1
  | rec_StringCvt_radix f1 f2 f3 f4 OCT = f2
  | rec_StringCvt_radix f1 f2 f3 f4 DEC = f3
  | rec_StringCvt_radix f1 f2 f3 f4 HEX = f4;

fun of_string_b_a_s_ea a b s =
  of_string_gen (SS_base (ST "Init.String\092<^sub>b\092<^sub>a\092<^sub>s\092<^sub>e.flatten")) (fn sa => flattena [SS_base (ST "(Init.ST0_base"), sa, SS_base (ST ")")])
    (fn sa => flattena [SS_base (ST "(Init.string\092<^sub>b\092<^sub>a\092<^sub>s\092<^sub>e.ST"), sa, SS_base (ST ")")]) a b (to_String s);

fun compiler_env_configa a b =
  of_compiler_env_config id of_stringa of_string_b_a_s_ea of_nata of_unita of_boolb of_Paira of_Nila of_Consa of_Nonea of_Somea a b
    (fn aa => fn ba => of_paira aa ba (of_lista aa ba (of_all_meta_embedding id of_stringa of_nata of_unita of_boolb of_Paira of_Nila of_Consa of_Nonea of_Somea aa ba)) (of_optiona aa ba (of_stringa aa ba)));

fun isabelle_of_compiler_env_config x = compiler_env_configa x;

fun rec_Unsynchronized_ref f (Unsynchronized_ref x) = f x;

fun rec_literalconstant_node f1 f2 (NUMCONST (x11, x12, x13)) = f1 x11 x12 x13
  | rec_literalconstant_node f1 f2 (STRING_LIT x2) = f2 x2;

end; (*struct C_Ast*)
